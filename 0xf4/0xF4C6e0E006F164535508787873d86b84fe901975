{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"},"IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account\u0027s ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\u0027t\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\u0027s tokens,\n     * given ``owner``\u0027s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\u0027s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\u0027s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\u0027s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))) \u0026\u0026 Address.isContract(address(token));\n    }\n}"},"YearnBoostedStaker.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.22;\n\nimport {IERC20, SafeERC20} from \"./SafeERC20.sol\";\nimport {IERC20Metadata} from \"./IERC20Metadata.sol\";\n\ncontract YearnBoostedStaker {\n    using SafeERC20 for IERC20;\n\n    uint public immutable MAX_STAKE_GROWTH_WEEKS;\n    uint8 public immutable MAX_WEEK_BIT;\n    uint public immutable START_TIME;\n    IERC20 public immutable stakeToken;\n\n    // Account weight tracking state vars.\n    mapping(address account =\u003e AccountData data) public accountData;\n    mapping(address account =\u003e mapping(uint week =\u003e uint weight)) private accountWeeklyWeights;\n    mapping(address account =\u003e mapping(uint week =\u003e ToRealize weight)) public accountWeeklyToRealize;\n    mapping(address account =\u003e mapping(uint week =\u003e uint amount)) public accountWeeklyMaxStake;\n\n    // Global weight tracking stats vars.\n    uint112 public globalGrowthRate;\n    uint16 public globalLastUpdateWeek;\n    mapping(uint week =\u003e uint weight) private globalWeeklyWeights;\n    mapping(uint week =\u003e ToRealize weight) public globalWeeklyToRealize;\n    mapping(uint week =\u003e uint amount) public globalWeeklyMaxStake;\n\n    // Generic token interface.\n    uint public totalSupply;\n    uint8 public immutable decimals;\n\n    // Permissioned roles\n    address public owner;\n    address public pendingOwner;\n    mapping(address account =\u003e mapping(address caller =\u003e ApprovalStatus approvalStatus)) public approvedCaller;\n    mapping(address staker =\u003e bool approved) public approvedWeightedStaker;\n\n    struct ToRealize {\n        uint128 weightPersistent;\n        uint128 weight;\n    }\n\n    struct AccountData {\n        uint112 realizedStake;  // Amount of stake that has fully realized weight.\n        uint112 pendingStake;   // Amount of stake that has not yet fully realized weight.\n        uint16 lastUpdateWeek;  // Week of last sync.\n\n        // One byte member to represent weeks in which an account has pending weight changes.\n        // A bit is set to true when the account has a non-zero token balance to be realized in\n        // the corresponding week. We use this as a \"map\", allowing us to reduce gas consumption\n        // by avoiding unnecessary lookups on weeks which an account has zero pending stake.\n        //\n        // Example: 01000001\n        // The left-most bit represents the final week of pendingStake.\n        // Therefore, we can see that account has stake updates to process only in weeks 7 and 1.\n        uint8 updateWeeksBitmap;\n    }\n\n    enum ApprovalStatus {\n        None,               // 0. Default value, indicating no approval\n        StakeOnly,          // 1. Approved for stake only\n        UnstakeOnly,        // 2. Approved for unstake only\n        StakeAndUnstake     // 3. Approved for both stake and unstake\n    }\n\n    event Staked(address indexed account, uint indexed week, uint amount, uint newUserWeight, uint weightAdded);\n    event Unstaked(address indexed account, uint indexed week, uint amount, uint newUserWeight, uint weightRemoved);\n    event ApprovedCallerSet(address indexed account, address indexed caller, ApprovalStatus status);\n    event OwnershipTransferred(address indexed newOwner);\n    event WeightedStakerSet(address indexed staker, bool approved);\n\n    /**\n        @param _token The token to be staked.\n        @param _max_stake_growth_weeks The number of weeks a stake will grow for.\n                            Not including desposit week.\n        @param _start_time  allows deployer to optionally set a custom start time.\n                            useful if needed to line up with week count in another system.\n                            Passing a value of 0 will start at block.timestamp.\n        @param _owner       Owner is able to grant access to stake with max boost.\n    */\n    constructor(address _token, uint _max_stake_growth_weeks, uint _start_time, address _owner) {\n        owner = _owner;\n        emit OwnershipTransferred(_owner);\n        stakeToken = IERC20(_token);\n        decimals = IERC20Metadata(_token).decimals();\n        require(\n            _max_stake_growth_weeks \u003e 0 \u0026\u0026\n            _max_stake_growth_weeks \u003c= 7,\n            \"Invalid weeks\"\n        );\n        MAX_STAKE_GROWTH_WEEKS = _max_stake_growth_weeks;\n        MAX_WEEK_BIT = uint8(1 \u003c\u003c MAX_STAKE_GROWTH_WEEKS);\n        if (_start_time == 0){\n            START_TIME = block.timestamp;\n        }\n        else {\n            require(_start_time \u003c= block.timestamp, \"!Past\");\n            START_TIME = _start_time;\n        }\n    }\n\n    /**\n        @notice Stake tokens into the staking contract.\n        @param _amount Amount of tokens to stake.\n    */\n    function stake(uint _amount) external returns (uint) {\n        return _stake(msg.sender, _amount);\n    }\n\n    function stakeFor(address _account, uint _amount) external returns (uint) {\n        if (msg.sender != _account) {\n            ApprovalStatus status = approvedCaller[_account][msg.sender];\n            require(\n                status == ApprovalStatus.StakeAndUnstake ||\n                status == ApprovalStatus.StakeOnly,\n                \"!Permission\"\n            );\n        }\n        \n        return _stake(_account, _amount);\n    }\n\n    function _stake(address _account, uint _amount) internal returns (uint) {\n        require(_amount \u003e 1 \u0026\u0026 _amount \u003c type(uint112).max, \"invalid amount\");\n\n        // Before going further, let\u0027s sync our account and global weights\n        uint systemWeek = getWeek();\n        (AccountData memory acctData, uint accountWeight) = _checkpointAccount(_account, systemWeek);\n        uint112 globalWeight = uint112(_checkpointGlobal(systemWeek));\n\n        uint weight = _amount \u003e\u003e 1;\n        _amount = weight \u003c\u003c 1; // This helps prevent balance/weight discrepencies.\n        \n        acctData.pendingStake += uint112(weight);\n        globalGrowthRate += uint112(weight);\n\n        uint realizeWeek = systemWeek + MAX_STAKE_GROWTH_WEEKS;\n        ToRealize memory toRealize = accountWeeklyToRealize[_account][realizeWeek];\n        toRealize.weight += uint128(weight);\n        toRealize.weightPersistent += uint128(weight);\n        accountWeeklyToRealize[_account][realizeWeek] = toRealize;\n\n        toRealize = globalWeeklyToRealize[realizeWeek];\n        toRealize.weight += uint128(weight);\n        toRealize.weightPersistent += uint128(weight);\n        globalWeeklyToRealize[realizeWeek] = toRealize;\n        \n        accountWeeklyWeights[_account][systemWeek] = accountWeight + weight;\n        globalWeeklyWeights[systemWeek] = globalWeight + weight;\n\n        acctData.updateWeeksBitmap |= 1; // Use bitwise or to ensure bit is flipped at least weighted position.\n        accountData[_account] = acctData;\n        totalSupply += _amount;\n        \n        stakeToken.safeTransferFrom(msg.sender, address(this), uint(_amount));\n        emit Staked(_account, systemWeek, _amount, accountWeight + weight, weight);\n        \n        return _amount;\n    }\n\n    /**\n        @notice Allows an option for an approved helper to stake to any account at any weight week.\n        @dev A stake using this method only effects weight in current and future weeks. It does not backfill prior weeks.\n        @param _amount Amount to stake\n        @return amount of tokens staked\n    */\n    function stakeAsMaxWeighted(address _account, uint _amount) external returns (uint) {\n        require(\n            approvedWeightedStaker[msg.sender],\n            \"!approvedStaker\"\n        );\n        require(_amount \u003e 1 \u0026\u0026 _amount \u003c type(uint112).max, \"invalid amount\");\n\n        // Before going further, let\u0027s sync our account and global weights\n        uint systemWeek = getWeek();\n        (AccountData memory acctData, uint accountWeight) = _checkpointAccount(_account, systemWeek);\n        uint112 globalWeight = uint112(_checkpointGlobal(systemWeek));\n\n        uint weight = _amount \u003e\u003e 1;\n        _amount = weight \u003c\u003c 1;\n        acctData.realizedStake += uint112(weight);\n        weight = weight * (MAX_STAKE_GROWTH_WEEKS + 1);\n\n        // Note: The usage of `stakeAsMaxWeighted` breaks an ability to reliably derive account + global\n        // amount deposited at any week using `weeklyToRealize` variables.\n        // To make up for this, we introduce the following two variables that are meant to recover that same\n        // ability for any on-chain integrators. They may combine this new data with `weeklyToRealize`.\n        accountWeeklyMaxStake[_account][systemWeek] += _amount;\n        globalWeeklyMaxStake[systemWeek] += _amount;\n\n        accountWeeklyWeights[_account][systemWeek] = accountWeight + weight;\n        globalWeeklyWeights[systemWeek] = globalWeight + weight;\n\n        \n\n        accountData[_account] = acctData;\n        totalSupply += _amount;\n\n        stakeToken.safeTransferFrom(msg.sender, address(this), uint(_amount));\n        emit Staked(_account, systemWeek, _amount, accountWeight + weight, weight);\n\n        return _amount;\n    }\n\n    /**\n        @notice Unstake tokens from the contract.\n        @dev During partial unstake, this will always remove from the least-weighted first.\n    */\n    function unstake(uint _amount, address _receiver) external returns (uint) {\n        return _unstake(msg.sender, _amount, _receiver);\n    }\n\n    /**\n        @notice Unstake tokens from the contract on behalf of another user.\n        @dev During partial unstake, this will always remove from the least-weighted first.\n    */\n    function unstakeFor(address _account, uint _amount, address _receiver) external returns (uint) {\n        if (msg.sender != _account) {\n            ApprovalStatus status = approvedCaller[_account][msg.sender];\n            require(\n                status == ApprovalStatus.StakeAndUnstake ||\n                status == ApprovalStatus.UnstakeOnly,\n                \"!Permission\"\n            );\n        }\n        return _unstake(_account, _amount, _receiver);\n    }\n\n    function _unstake(address _account, uint _amount, address _receiver) internal returns (uint) {\n        require(_amount \u003e 1 \u0026\u0026 _amount \u003c type(uint112).max, \"invalid amount\");\n        uint systemWeek = getWeek();\n\n        // Before going further, let\u0027s sync our account and global weights\n        (AccountData memory acctData, ) = _checkpointAccount(_account, systemWeek);\n        _checkpointGlobal(systemWeek);\n\n        // Here we do work to pull from most recent (least weighted) stake first\n        uint8 bitmap = acctData.updateWeeksBitmap;\n        uint128 weightToRemove;\n\n        uint128 amountNeeded = uint128(_amount \u003e\u003e 1);\n        _amount = amountNeeded \u003c\u003c 1; // This helps prevent balance/weight discrepencies.\n\n        if (bitmap \u003e 0) {\n            for (uint128 weekIndex; weekIndex \u003c MAX_STAKE_GROWTH_WEEKS;) {\n                // Move right to left, checking each bit if there\u0027s an update for corresponding week.\n                uint8 mask = uint8(1 \u003c\u003c weekIndex);\n                if (bitmap \u0026 mask == mask) {\n                    uint weekToCheck = systemWeek + MAX_STAKE_GROWTH_WEEKS - weekIndex;\n                    uint128 pending = accountWeeklyToRealize[_account][weekToCheck].weight;\n                    if (amountNeeded \u003e pending){\n                        weightToRemove += pending * (weekIndex + 1);\n                        accountWeeklyToRealize[_account][weekToCheck].weight = 0;\n                        globalWeeklyToRealize[weekToCheck].weight -= pending;\n                        if (weekIndex == 0) { // Current system week\n                            accountWeeklyToRealize[_account][weekToCheck].weightPersistent = 0;\n                            globalWeeklyToRealize[weekToCheck].weightPersistent -= pending;\n                        }\n                        bitmap = bitmap ^ mask;\n                        amountNeeded -= pending;\n                    }\n                    else { \n                        // handle the case where we have more pending than needed\n                        weightToRemove += amountNeeded * (weekIndex + 1);\n                        accountWeeklyToRealize[_account][weekToCheck].weight -= amountNeeded;\n                        globalWeeklyToRealize[weekToCheck].weight -= amountNeeded;\n                        if (weekIndex == 0) { // Current system week\n                            accountWeeklyToRealize[_account][weekToCheck].weightPersistent -= amountNeeded;\n                            globalWeeklyToRealize[weekToCheck].weightPersistent -= amountNeeded;\n                        }\n                        if (amountNeeded == pending) bitmap = bitmap ^ mask;\n                        amountNeeded = 0;\n                        break;\n                    }\n                }\n                unchecked{weekIndex++;}\n            }\n            acctData.updateWeeksBitmap = bitmap;\n        }\n        \n        uint pendingRemoved = (_amount \u003e\u003e 1) - amountNeeded;\n        if (amountNeeded \u003e 0) {\n            weightToRemove += amountNeeded * uint128(1 + MAX_STAKE_GROWTH_WEEKS);\n            acctData.realizedStake -= uint112(amountNeeded);\n            acctData.pendingStake = 0;\n        }\n        else{\n            acctData.pendingStake -= uint112(pendingRemoved);\n        }\n        \n        accountData[_account] = acctData;\n\n        globalGrowthRate -= uint112(pendingRemoved);\n        globalWeeklyWeights[systemWeek] -= weightToRemove;\n        uint newAccountWeight = accountWeeklyWeights[_account][systemWeek] - weightToRemove;\n        accountWeeklyWeights[_account][systemWeek] = newAccountWeight;\n        \n        totalSupply -= _amount;\n\n        emit Unstaked(_account, systemWeek, _amount, newAccountWeight, weightToRemove);\n        \n        stakeToken.safeTransfer(_receiver, _amount);\n        \n        return _amount;\n    }\n    \n    /**\n        @notice Get the current realized weight for an account\n        @param _account Account to checkpoint.\n        @return acctData Most recent account data written to storage.\n        @return weight Most current account weight.\n        @dev Prefer to use this function over it\u0027s view counterpart for\n             contract -\u003e contract interactions.\n    */\n    function checkpointAccount(address _account) external returns (AccountData memory acctData, uint weight) {\n        (acctData, weight) = _checkpointAccount(_account, getWeek());\n        accountData[_account] = acctData;\n    }\n\n    /**\n        @notice Checkpoint an account using a specified week limit.\n        @dev    To use in the event that significant number of weeks have passed since last \n                heckpoint and single call becomes too expensive.\n        @param _account Account to checkpoint.\n        @param _week Week which we want to checkpoint to.\n        @return acctData Most recent account data written to storage.\n        @return weight Account weight for provided week.\n    */\n    function checkpointAccountWithLimit(address _account, uint _week) external returns (AccountData memory acctData, uint weight) {\n        uint systemWeek = getWeek();\n        if (_week \u003e= systemWeek) _week = systemWeek;\n        (acctData, weight) = _checkpointAccount(_account, _week);\n        accountData[_account] = acctData;\n    }\n\n    function _checkpointAccount(address _account, uint _systemWeek) internal returns (AccountData memory acctData, uint weight){\n        acctData = accountData[_account];\n        uint lastUpdateWeek = acctData.lastUpdateWeek;\n\n        if (_systemWeek == lastUpdateWeek) {\n            return (acctData, accountWeeklyWeights[_account][lastUpdateWeek]);\n        }\n\n        require(_systemWeek \u003e lastUpdateWeek, \"specified week is older than last update.\");\n\n        uint pending = uint(acctData.pendingStake);\n        uint realized = acctData.realizedStake;\n\n        if (pending == 0) {\n            if (realized != 0) {\n                weight = accountWeeklyWeights[_account][lastUpdateWeek];\n                while (lastUpdateWeek \u003c _systemWeek) {\n                    unchecked{lastUpdateWeek++;}\n                    // Fill in any missing weeks\n                    accountWeeklyWeights[_account][lastUpdateWeek] = weight;\n                }\n            }\n            accountData[_account].lastUpdateWeek = uint16(_systemWeek);\n            acctData.lastUpdateWeek = uint16(_systemWeek);\n            return (acctData, weight);\n        }\n\n        weight = accountWeeklyWeights[_account][lastUpdateWeek];\n        uint8 bitmap = acctData.updateWeeksBitmap;\n        uint targetSyncWeek = min(_systemWeek, lastUpdateWeek + MAX_STAKE_GROWTH_WEEKS);\n\n        // Populate data for missed weeks\n        while (lastUpdateWeek \u003c targetSyncWeek) {\n            unchecked{ lastUpdateWeek++; }\n            weight += pending; // Increment weights by weekly growth factor.\n            accountWeeklyWeights[_account][lastUpdateWeek] = weight;\n\n            // Shift left on bitmap as we pass over each week.\n            bitmap = bitmap \u003c\u003c 1;\n            if (bitmap \u0026 MAX_WEEK_BIT == MAX_WEEK_BIT){ // If left-most bit is true, we have something to realize; push pending to realized.\n                // Do any updates needed to realize an amount for an account.\n                uint toRealize = accountWeeklyToRealize[_account][lastUpdateWeek].weight;\n                pending -= toRealize;\n                realized += toRealize;\n                if (pending == 0) break; // All pending has been realized. No need to continue.\n            }\n        }\n\n        // Fill in any missed weeks.\n        while (lastUpdateWeek \u003c _systemWeek){\n            unchecked{lastUpdateWeek++;}\n            accountWeeklyWeights[_account][lastUpdateWeek] = weight;\n        }   \n\n        // Write new account data to storage.\n        acctData = AccountData({\n            updateWeeksBitmap: bitmap,\n            pendingStake: uint112(pending),\n            realizedStake: uint112(realized),\n            lastUpdateWeek: uint16(_systemWeek)\n        });\n    }\n\n    /**\n        @notice View function to get the current weight for an account\n    */\n    function getAccountWeight(address account) external view returns (uint) {\n        return getAccountWeightAt(account, getWeek());\n    }\n\n    /**\n        @notice Get the weight for an account in a given week\n    */\n    function getAccountWeightAt(address _account, uint _week) public view returns (uint) {\n        if (_week \u003e getWeek()) return 0;\n        \n        AccountData memory acctData = accountData[_account];\n        \n        uint16 lastUpdateWeek = acctData.lastUpdateWeek;\n\n        if (lastUpdateWeek \u003e= _week) return accountWeeklyWeights[_account][_week]; \n\n        uint weight = accountWeeklyWeights[_account][lastUpdateWeek];\n\n        uint pending = uint(acctData.pendingStake);\n        if (pending == 0) return weight;\n\n        uint8 bitmap = acctData.updateWeeksBitmap;\n\n        while (lastUpdateWeek \u003c _week) { // Populate data for missed weeks\n            unchecked{lastUpdateWeek++;}\n            weight += pending; // Increment weight by 1 week\n\n            // Our bitmap is used to determine if week has any amount to realize.\n            bitmap = bitmap \u003c\u003c 1;\n            if (bitmap \u0026 MAX_WEEK_BIT == MAX_WEEK_BIT){ // If left-most bit is true, we have something to realize; push pending to realized.\n                pending -= accountWeeklyToRealize[_account][lastUpdateWeek].weight;\n                if (pending == 0) break; // All pending has now been realized, let\u0027s exit.\n            }            \n        }\n        \n        return weight;\n    }\n\n    /**\n        @notice Get the current total system weight\n        @dev Also updates local storage values for total weights. Using\n             this function over it\u0027s `view` counterpart is preferred for\n             contract -\u003e contract interactions.\n    */\n    function checkpointGlobal() external returns (uint) {\n        uint systemWeek = getWeek();\n        return _checkpointGlobal(systemWeek);\n    }\n\n    /**\n        @notice Get the current total system weight\n        @dev Also updates local storage values for total weights. Using\n             this function over it\u0027s `view` counterpart is preferred for\n             contract -\u003e contract interactions.\n    */\n    function _checkpointGlobal(uint systemWeek) internal returns (uint) {\n        // These two share a storage slot.\n        uint16 lastUpdateWeek = globalLastUpdateWeek;\n        uint rate = globalGrowthRate;\n\n        uint weight = globalWeeklyWeights[lastUpdateWeek];\n\n        if (weight == 0) {\n            globalLastUpdateWeek = uint16(systemWeek);\n            return 0;\n        }\n\n        if (lastUpdateWeek == systemWeek){\n            return weight;\n        }\n\n        while (lastUpdateWeek \u003c systemWeek) {\n            unchecked{lastUpdateWeek++;}\n            weight += rate;\n            globalWeeklyWeights[lastUpdateWeek] = weight;\n            rate -= globalWeeklyToRealize[lastUpdateWeek].weight;\n        }\n\n        globalGrowthRate = uint112(rate);\n        globalLastUpdateWeek = uint16(systemWeek);\n\n        return weight;\n    }\n\n    /**\n        @notice Get the system weight for current week.\n    */\n    function getGlobalWeight() external view returns (uint) {\n        return getGlobalWeightAt(getWeek());\n    }\n\n    /**\n        @notice Get the system weight for a specified week in the past.\n        @dev querying a week in the future will always return 0.\n        @param week the week number to query global weight for.\n    */\n    function getGlobalWeightAt(uint week) public view returns (uint) {\n        uint systemWeek = getWeek();\n        if (week \u003e systemWeek) return 0;\n\n        // Read these together since they are packed in the same slot.\n        uint16 lastUpdateWeek = globalLastUpdateWeek;\n        uint rate = globalGrowthRate;\n\n        if (week \u003c= lastUpdateWeek) return globalWeeklyWeights[week];\n\n        uint weight = globalWeeklyWeights[lastUpdateWeek];\n        if (rate == 0) {\n            return weight;\n        }\n\n        while (lastUpdateWeek \u003c week) {\n            unchecked {lastUpdateWeek++;}\n            weight += rate;\n            rate -= globalWeeklyToRealize[lastUpdateWeek].weight;\n        }\n\n        return weight;\n    }\n\n    /**\n        @notice Returns the balance of underlying staked tokens for an account\n        @param _account Account to query balance.\n        @return balance of account.\n    */\n    function balanceOf(address _account) external view returns (uint) {\n        AccountData memory acctData = accountData[_account];\n        return 2 * (acctData.pendingStake + acctData.realizedStake);\n    }\n\n    /**\n        @notice Allow another address to stake or unstake on behalf of. Useful for zaps and other functionality.\n        @param _caller Address of the caller to approve or unapprove.\n        @param _status Enum representing various approval status states.\n    */\n    function setApprovedCaller(address _caller, ApprovalStatus _status) external {\n        approvedCaller[msg.sender][_caller] = _status;\n        emit ApprovedCallerSet(msg.sender, _caller, _status);\n    }\n\n    /**\n        @notice Allow owner to specify an account which has ability to stakeAsWeighted.\n        @param _staker Address of account with staker permissions.\n        @param _approved Approve or unapprove the staker.\n    */\n    function setWeightedStaker(address _staker, bool _approved) external {\n        require(msg.sender == owner, \"!authorized\");\n        approvedWeightedStaker[_staker] = _approved;\n        emit WeightedStakerSet(_staker, _approved);\n    }\n\n    /**\n        @notice Set a pending owner which can later be accepted.\n        @param _pendingOwner Address of the new owner.\n    */\n    function transferOwnership(address _pendingOwner) external {\n        require(msg.sender == owner, \"!authorized\");\n        pendingOwner = _pendingOwner;\n    }\n\n    /**\n        @notice Allow pending owner to accept ownership\n    */\n    function acceptOwnership() external {\n        require(msg.sender == pendingOwner, \"!authorized\");\n        owner = msg.sender;\n        pendingOwner = address(0);\n        emit OwnershipTransferred(msg.sender);\n    }\n\n    function sweep(address _token) external {\n        require(msg.sender == owner, \"!authorized\");\n        uint amount = IERC20(_token).balanceOf(address(this));\n        if (_token == address(stakeToken)) {\n            amount = amount - totalSupply;\n        }\n        if (amount \u003e 0) IERC20(_token).safeTransfer(owner, amount);\n    }\n\n    function getWeek() public view returns (uint week) {\n        unchecked{\n            return (block.timestamp - START_TIME) / 1 weeks;\n        }\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a \u003c b ? a : b;\n    }\n}"}}