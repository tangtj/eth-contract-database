
// File: @openzeppelin/contracts/token/ERC20/ERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * The default value of {decimals} is 18. To change this, you should override
 * this function so it returns a different value.
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the default value returned by this function, unless
     * it's overridden.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(address from, address to, uint256 amount) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}


// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    /**
     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    /**
     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }

    /**
     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }

    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
     * Revert on invalid signature.
     */
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     *
     * Furthermore, `isContract` will also return true if the target contract within
     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
     * which only has an effect at the end of a transaction.
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/math/Math.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                // Solidity will revert if denominator == 0, unlike the div opcode on its own.
                // The surrounding unchecked block does not change this fact.
                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1, "Math: mulDiv overflow");

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10 ** 64) {
                value /= 10 ** 64;
                result += 64;
            }
            if (value >= 10 ** 32) {
                value /= 10 ** 32;
                result += 32;
            }
            if (value >= 10 ** 16) {
                value /= 10 ** 16;
                result += 16;
            }
            if (value >= 10 ** 8) {
                value /= 10 ** 8;
                result += 8;
            }
            if (value >= 10 ** 4) {
                value /= 10 ** 4;
                result += 4;
            }
            if (value >= 10 ** 2) {
                value /= 10 ** 2;
                result += 2;
            }
            if (value >= 10 ** 1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
        }
    }
}


// File: @openzeppelin/contracts/utils/math/SignedMath.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard signed math utilities missing in the Solidity language.
 */
library SignedMath {
    /**
     * @dev Returns the largest of two signed numbers.
     */
    function max(int256 a, int256 b) internal pure returns (int256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two signed numbers.
     */
    function min(int256 a, int256 b) internal pure returns (int256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two signed numbers without overflow.
     * The result is rounded towards zero.
     */
    function average(int256 a, int256 b) internal pure returns (int256) {
        // Formula from the book "Hacker's Delight"
        int256 x = (a & b) + ((a ^ b) >> 1);
        return x + (int256(uint256(x) >> 255) & (a ^ b));
    }

    /**
     * @dev Returns the absolute unsigned value of a signed value.
     */
    function abs(int256 n) internal pure returns (uint256) {
        unchecked {
            // must be unchecked in order to support `n = type(int256).min`
            return uint256(n >= 0 ? n : -n);
        }
    }
}


// File: @openzeppelin/contracts/utils/Strings.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

import "./math/Math.sol";
import "./math/SignedMath.sol";

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `int256` to its ASCII `string` decimal representation.
     */
    function toString(int256 value) internal pure returns (string memory) {
        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }

    /**
     * @dev Returns true if the two strings are equal.
     */
    function equal(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(bytes(a)) == keccak256(bytes(b));
    }
}


// File: contracts/base/ERC4626.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.1) (token/ERC20/extensions/ERC4626.sol)

// ####################################################
// ################## IMPORTANT #######################
// ####################################################
// NOTE fija Finance: ETH native compatibility -- Forked OZ contract and updated deposit method to become payable.

pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../interfaces/IERC4626.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @dev Implementation of the ERC4626 "Tokenized Vault Standard" as defined in
 * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].
 *
 * This extension allows the minting and burning of "shares" (represented using the ERC20 inheritance) in exchange for
 * underlying "assets" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends
 * the ERC20 standard. Any additional extensions included along it would affect the "shares" token represented by this
 * contract and not the "assets" token which is an independent contract.
 *
 * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with
 * a "donation" to the vault that inflates the price of a share. This is variously known as a donation or inflation
 * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial
 * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may
 * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by
 * verifying the amount received is as expected, using a wrapper that performs these checks such as
 * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].
 *
 * _Available since v4.7._
 */
abstract contract ERC4626 is ERC20, IERC4626 {
    using Math for uint256;

    IERC20 private immutable _asset;
    uint8 private immutable _decimals;

    /**
     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).
     */
    constructor(IERC20 asset_) {
        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);
        _decimals = success ? assetDecimals : super.decimals();
        _asset = asset_;
    }

    /**
     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.
     */
    function _tryGetAssetDecimals(
        IERC20 asset_
    ) private view returns (bool, uint8) {
        (bool success, bytes memory encodedDecimals) = address(asset_)
            .staticcall(
                abi.encodeWithSelector(IERC20Metadata.decimals.selector)
            );
        if (success && encodedDecimals.length >= 32) {
            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));
            if (returnedDecimals <= type(uint8).max) {
                return (true, uint8(returnedDecimals));
            }
        }
        return (false, 0);
    }

    /**
     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset
     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on
     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.
     * See {IERC20Metadata-decimals}.
     */
    function decimals()
        public
        view
        virtual
        override(IERC20Metadata, ERC20)
        returns (uint8)
    {
        return _decimals;
    }

    /** @dev See {IERC4626-asset}. */
    function asset() public view virtual override returns (address) {
        return address(_asset);
    }

    /** @dev See {IERC4626-totalAssets}. */
    function totalAssets() public view virtual override returns (uint256) {
        return _asset.balanceOf(address(this));
    }

    /** @dev See {IERC4626-convertToShares}. */
    function convertToShares(
        uint256 assets
    ) public view virtual override returns (uint256 shares) {
        return _convertToShares(assets, Math.Rounding.Down);
    }

    /** @dev See {IERC4626-convertToAssets}. */
    function convertToAssets(
        uint256 shares
    ) public view virtual override returns (uint256 assets) {
        return _convertToAssets(shares, Math.Rounding.Down);
    }

    /** @dev See {IERC4626-maxDeposit}. */
    function maxDeposit(
        address
    ) public view virtual override returns (uint256) {
        return _isVaultCollateralized() ? type(uint256).max : 0;
    }

    /** @dev See {IERC4626-maxMint}. */
    function maxMint(address) public view virtual override returns (uint256) {
        return type(uint256).max;
    }

    /** @dev See {IERC4626-maxWithdraw}. */
    function maxWithdraw(
        address owner
    ) public view virtual override returns (uint256) {
        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);
    }

    /** @dev See {IERC4626-maxRedeem}. */
    function maxRedeem(
        address owner
    ) public view virtual override returns (uint256) {
        return balanceOf(owner);
    }

    /** @dev See {IERC4626-previewDeposit}. */
    function previewDeposit(
        uint256 assets
    ) public view virtual override returns (uint256) {
        return _convertToShares(assets, Math.Rounding.Down);
    }

    /** @dev See {IERC4626-previewMint}. */
    function previewMint(
        uint256 shares
    ) public view virtual override returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Up);
    }

    /** @dev See {IERC4626-previewWithdraw}. */
    function previewWithdraw(
        uint256 assets
    ) public view virtual override returns (uint256) {
        return _convertToShares(assets, Math.Rounding.Up);
    }

    /** @dev See {IERC4626-previewRedeem}. */
    function previewRedeem(
        uint256 shares
    ) public view virtual override returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Down);
    }

    /** @dev See {IERC4626-deposit}. */
    function deposit(
        uint256 assets,
        address receiver
    ) public payable virtual override returns (uint256) {
        require(
            assets <= maxDeposit(receiver),
            "ERC4626: deposit more than max"
        );

        uint256 shares = previewDeposit(assets);
        _deposit(_msgSender(), receiver, assets, shares);

        return shares;
    }

    /** @dev See {IERC4626-mint}.
     *
     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.
     * In this case, the shares will be minted without requiring any assets to be deposited.
     */
    function mint(
        uint256 shares,
        address receiver
    ) public virtual override returns (uint256) {
        require(shares <= maxMint(receiver), "ERC4626: mint more than max");

        uint256 assets = previewMint(shares);
        _deposit(_msgSender(), receiver, assets, shares);

        return assets;
    }

    /** @dev See {IERC4626-withdraw}. */
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public virtual override returns (uint256) {
        require(
            assets <= maxWithdraw(owner),
            "ERC4626: withdraw more than max"
        );

        uint256 shares = previewWithdraw(assets);
        _withdraw(_msgSender(), receiver, owner, assets, shares);

        return shares;
    }

    /** @dev See {IERC4626-redeem}. */
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public virtual override returns (uint256) {
        require(shares <= maxRedeem(owner), "ERC4626: redeem more than max");
        uint256 assets = previewRedeem(shares);

        _withdraw(_msgSender(), receiver, owner, assets, shares);

        return assets;
    }

    /**
     * @dev Internal conversion function (from assets to shares) with support for rounding direction.
     *
     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset
     * would represent an infinite amount of shares.
     */
    function _convertToShares(
        uint256 assets,
        Math.Rounding rounding
    ) internal view virtual returns (uint256 shares) {
        uint256 supply = totalSupply();
        return
            (assets == 0 || supply == 0)
                ? _initialConvertToShares(assets, rounding)
                : assets.mulDiv(supply, totalAssets(), rounding);
    }

    /**
     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.
     *
     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.
     */
    function _initialConvertToShares(
        uint256 assets,
        Math.Rounding /*rounding*/
    ) internal view virtual returns (uint256 shares) {
        return assets;
    }

    /**
     * @dev Internal conversion function (from shares to assets) with support for rounding direction.
     */
    function _convertToAssets(
        uint256 shares,
        Math.Rounding rounding
    ) internal view virtual returns (uint256 assets) {
        uint256 supply = totalSupply();
        return
            (supply == 0)
                ? _initialConvertToAssets(shares, rounding)
                : shares.mulDiv(totalAssets(), supply, rounding);
    }

    /**
     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.
     *
     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.
     */
    function _initialConvertToAssets(
        uint256 shares,
        Math.Rounding /*rounding*/
    ) internal view virtual returns (uint256 assets) {
        return shares;
    }

    /**
     * @dev Deposit/mint common workflow.
     */
    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    ) internal virtual {
        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the
        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the
        // assets are transferred and before the shares are minted, which is a valid state.
        // slither-disable-next-line reentrancy-no-eth
        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);
        _mint(receiver, shares);

        emit Deposit(caller, receiver, assets, shares);
    }

    /**
     * @dev Withdraw/redeem common workflow.
     */
    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256 assets,
        uint256 shares
    ) internal virtual {
        if (caller != owner) {
            _spendAllowance(owner, caller, shares);
        }

        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the
        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the
        // shares are burned and after the assets are transferred, which is a valid state.
        _burn(owner, shares);

        SafeERC20.safeTransfer(_asset, receiver, assets);

        emit Withdraw(caller, receiver, owner, assets, shares);
    }

    /**
     * @dev Checks if vault is "healthy" in the sense of having assets backing the circulating shares.
     */
    function _isVaultCollateralized() private view returns (bool) {
        return totalAssets() > 0 || totalSupply() == 0;
    }
}


// File: contracts/base/errors.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

// FijaVault errors
error VaultNoAssetMatching();
error VaultNotWhitelisted();
error VaultNoUpdateCandidate();
error VaultUpdateStrategyTimeError();
error VaultStrategyUndefined();

// FijaACL errors
error ACLOwnerZero();
error ACLGovZero();
error ACLResellZero();
error ACLNotOwner();
error ACLNotGov();
error ACLNotGovOwner();
error ACLNotReseller();
error ACLNotWhitelist();
error ACLTransferUserNotWhitelist();
error ACLDepositReceiverNotWhitelist();
error ACLRedeemWithdrawReceiverOwnerNotWhitelist();
error ACLWhitelistAddressZero();

// Strategy errors
error FijaUnauthorizedFlash();
error FijaInvalidAssetFlash();

// Transfer errors
error TransferDisbalance();
error TransferFailed();

// emergency mode restriction
error FijaInEmergencyMode();

error FijaInsufficientAmountToWithdraw();
error FijaZeroInput();


// File: contracts/base/FijaACL.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../interfaces/IFijaACL.sol";
import "./errors.sol";

///
/// @title Access control contract
/// @author Fija
/// @notice Provides access rights management to child contracts
/// @dev some of the methods have default access modifiers and
/// some do not have restrictions. Please verify and override to have expected behaviour
/// *********** IMPORTANT **************
/// whitelist functions in the contract are not protected
/// it is responsibility of child contracts to define access rights
///
abstract contract FijaACL is IFijaACL {
    address private _owner;
    address private _governance;
    address private _reseller;
    mapping(address => bool) private _whitelist;

    constructor(address governance_, address reseller_) {
        _transferOwnership(msg.sender);
        _transferGovernance(governance_);
        _transferReseller(reseller_);
    }

    ///
    /// @dev Throws if called by any account that's not whitelisted.
    ///
    modifier onlyWhitelisted() {
        _checkWhitelist();
        _;
    }

    ///
    /// @dev Throws if called by any account other than the owner.
    ///
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    ///
    /// @dev Throws if called by any account other than the Governance.
    ///
    modifier onlyGovernance() {
        _checkGovernance();
        _;
    }

    ///
    /// @dev Throws if called by any account other than the Reseller.
    ///
    modifier onlyReseller() {
        _checkReseller();
        _;
    }

    ///
    /// @dev Throws if called by any account other than the Governance or Owner.
    ///
    modifier onlyOwnerOrGovernance() {
        _checkOwnerOrGovernance();
        _;
    }

    ///
    /// @dev Throws if receiver and owner are not in the whitelist
    ///
    modifier onlyReceiverOwnerWhitelisted(address receiver, address owner_) {
        _checkReceiverOwnerWhitelisted(receiver, owner_);
        _;
    }

    ///
    /// @dev Throws if receiver is not in the whitelist
    ///
    modifier onlyReceiverWhitelisted(address receiver) {
        _checkReceiverWhitelisted(receiver);
        _;
    }

    ///
    /// NOTE: emits IFijaACL.WhitelistedAddressAdded
    /// @inheritdoc IFijaACL
    ///
    function addAddressToWhitelist(
        address addr
    ) public virtual override returns (bool) {
        if (isWhitelisted(addr)) {
            return false;
        }
        _addAddressToWhitelist(addr);

        return true;
    }

    ///
    /// NOTE: emits IFijaACL.WhitelistedAddressRemoved
    /// @inheritdoc IFijaACL
    ///
    function removeAddressFromWhitelist(
        address addr
    ) public virtual override returns (bool) {
        if (!isWhitelisted(addr)) {
            return false;
        }
        _removeAddressFromWhitelist(addr);

        return true;
    }

    ///
    /// @inheritdoc IFijaACL
    ///
    function owner() public view virtual override returns (address) {
        return _owner;
    }

    ///
    /// @inheritdoc IFijaACL
    ///
    function governance() public view virtual override returns (address) {
        return _governance;
    }

    ///
    /// @inheritdoc IFijaACL
    ///
    function reseller() public view virtual override returns (address) {
        return _reseller;
    }

    ///
    /// @inheritdoc IFijaACL
    ///
    function isWhitelisted(
        address addr
    ) public view virtual override returns (bool) {
        return _whitelist[addr];
    }

    ///
    /// NOTE: only owner access, emits IFijaACL.OwnershipTransferred
    /// @inheritdoc IFijaACL
    ///
    function transferOwnership(
        address newOwner
    ) external virtual override onlyOwner {
        _transferOwnership(newOwner);
    }

    ///
    /// NOTE: only owner or governance access, emits IFijaACL.GovernanceTransferred
    /// @inheritdoc IFijaACL
    ///
    function transferGovernance(
        address newGovernance
    ) external virtual override onlyOwnerOrGovernance {
        if (newGovernance == address(0)) {
            revert ACLGovZero();
        }
        _transferGovernance(newGovernance);
    }

    ///
    /// NOTE: only governance access, emits IFijaACL.ResellerTransferred
    /// @inheritdoc IFijaACL
    ///
    function transferReseller(
        address newReseller
    ) external virtual override onlyGovernance {
        if (newReseller == address(0)) {
            revert ACLResellZero();
        }
        _transferReseller(newReseller);
    }

    ///
    /// NOTE: only governance access, emits IFijaACL.GovernanceTransferred
    /// @inheritdoc IFijaACL
    ///
    function renounceGovernance() external virtual override onlyGovernance {
        _transferGovernance(address(0));
    }

    ///
    /// NOTE: only reseller access, emits IFijaACL.ResellerTransferred
    /// @inheritdoc IFijaACL
    ///
    function renounceReseller() external virtual override onlyReseller {
        _transferReseller(address(0));
    }

    ///
    /// NOTE: owner cannot be zero address
    /// @dev Helper method for transferOwnership.
    /// Changes ownership access to new owner address.
    /// @param newOwner address of new owner
    ///
    function _transferOwnership(address newOwner) internal virtual {
        if (newOwner == address(0)) {
            revert ACLOwnerZero();
        }
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    ///
    /// @dev Helper method for transferGovernance.
    /// Changes governance access to new governance address.
    /// @param newGovernance address of new governance
    ///
    function _transferGovernance(address newGovernance) internal virtual {
        address oldGovernance = _governance;
        _governance = newGovernance;
        emit GovernanceTransferred(oldGovernance, newGovernance);
    }

    ///
    /// @dev Helper method for transferReseller.
    /// Changes reseller access to new reseller address.
    /// @param newReseller address of new reseller
    ///
    function _transferReseller(address newReseller) internal virtual {
        address oldReseller = _reseller;
        _reseller = newReseller;
        emit ResellerTransferred(oldReseller, newReseller);
    }

    ///
    /// @dev Helper method for onlyOwner modifier
    ///
    function _checkOwner() internal view virtual {
        if (owner() != msg.sender) {
            revert ACLNotOwner();
        }
    }

    ///
    /// @dev Helper method for onlyGovernance modifier
    ///
    function _checkGovernance() internal view virtual {
        if (governance() != msg.sender) {
            revert ACLNotGov();
        }
    }

    ///
    /// @dev Helper method for onlyOwnerOrGovernance modifier
    ///
    function _checkOwnerOrGovernance() internal view virtual {
        if (governance() != msg.sender && owner() != msg.sender) {
            revert ACLNotGovOwner();
        }
    }

    ///
    /// @dev Helper method for onlyReseller modifier
    ///
    function _checkReseller() internal view virtual {
        if (reseller() != msg.sender) {
            revert ACLNotReseller();
        }
    }

    ///
    /// @dev Helper method for onlyWhitelisted modifier
    ///
    function _checkWhitelist() internal view virtual {
        if (!isWhitelisted(msg.sender)) {
            revert ACLNotWhitelist();
        }
    }

    ///
    /// @dev Helper method for onlyReceiverOwnerWhitelisted modifier
    ///
    function _checkReceiverOwnerWhitelisted(
        address receiver,
        address owner_
    ) internal view virtual {
        if (!isWhitelisted(receiver) || !isWhitelisted(owner_)) {
            revert ACLRedeemWithdrawReceiverOwnerNotWhitelist();
        }
    }

    ///
    /// @dev Helper method for onlyReceiverWhitelisted modifier
    ///
    function _checkReceiverWhitelisted(address receiver) internal view virtual {
        if (!isWhitelisted(receiver)) {
            revert ACLDepositReceiverNotWhitelist();
        }
    }

    ///
    /// @dev Helper method for adding address to contract whitelist.
    /// @param addr address to be added to the whitelist
    ///
    function _addAddressToWhitelist(address addr) internal {
        if (addr == address(0)) {
            revert ACLWhitelistAddressZero();
        }
        _whitelist[addr] = true;
        emit WhitelistedAddressAdded(addr);
    }

    ///
    /// @dev Helper method for removing address from contract whitelist.
    /// @param addr address to be removed from the whitelist
    ///
    function _removeAddressFromWhitelist(address addr) internal {
        _whitelist[addr] = false;
        emit WhitelistedAddressRemoved(addr);
    }
}


// File: contracts/base/FijaERC4626Base.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "./ERC4626.sol";
import "./FijaACL.sol";
import "../interfaces/IFijaERC4626Base.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

///
/// @title Fija ERC4626 Base contract
/// @author Fija
/// @notice Used as template for implementing ERC4626
/// @dev This is mainly used for adding access rights to specific methods.
/// NOTE: All mint related methods are disabled from ERC4626
///
abstract contract FijaERC4626Base is IFijaERC4626Base, FijaACL, ERC4626 {
    using Math for uint256;
    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    ///
    /// @dev maximum amount to deposit/redeem/withdraw in assets in single call
    /// NOTE: if user wants to deposits/withdrawls/redeem with amounts above this limit
    /// transaction will be rejected
    ///
    uint256 internal immutable MAX_TICKET_SIZE;

    ///
    /// @dev maximum value of vault in assets
    /// NOTE: all deposits above this value will be rejected
    ///
    uint256 internal immutable MAX_VAULT_VALUE;

    constructor(
        IERC20 asset_,
        address governance_,
        address reseller_,
        string memory tokenName_,
        string memory tokenSymbol_,
        uint256 maxTicketSize_,
        uint256 maxVaultValue_
    )
        ERC4626(asset_)
        ERC20(tokenName_, tokenSymbol_)
        FijaACL(governance_, reseller_)
    {
        MAX_TICKET_SIZE = maxTicketSize_;
        MAX_VAULT_VALUE = maxVaultValue_;
    }

    ///
    /// @dev Throws if zero input amount (on deposit, withdraw, redeem)
    ///
    modifier nonZeroAmount(uint256 amount) {
        if (amount == 0) {
            revert FijaZeroInput();
        }
        _;
    }

    ///
    /// @inheritdoc IERC4626
    ///
    function totalAssets()
        public
        view
        virtual
        override(IERC4626, ERC4626)
        returns (uint256)
    {
        if (asset() == ETH) {
            return address(this).balance;
        } else {
            return IERC20(asset()).balanceOf(address(this));
        }
    }

    ///
    /// @inheritdoc IFijaERC4626Base
    ///
    function convertToTokens(
        uint256 assets
    ) public view virtual returns (uint256) {
        return convertToShares(assets);
    }

    ///
    /// NOTE: caller and "to" must be whitelisted
    /// @inheritdoc IERC20
    ///
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(ERC20, IERC20) onlyWhitelisted returns (bool) {
        if (!isWhitelisted(to)) {
            revert ACLTransferUserNotWhitelist();
        }
        super.transfer(to, amount);

        return true;
    }

    ///
    /// NOTE: caller and "to" must be whitelisted
    /// @inheritdoc IERC20
    ///
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(ERC20, IERC20) onlyWhitelisted returns (bool) {
        if (!isWhitelisted(from) || !isWhitelisted(to)) {
            revert ACLTransferUserNotWhitelist();
        }
        super.transferFrom(from, to, amount);

        return true;
    }

    ///
    /// NOTE: only whitelisted access
    /// @inheritdoc IERC20
    ///
    function approve(
        address spender,
        uint256 amount
    ) public virtual override(ERC20, IERC20) onlyWhitelisted returns (bool) {
        return super.approve(spender, amount);
    }

    ///
    /// NOTE: only whitelisted access
    /// @inheritdoc ERC20
    ///
    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public virtual override onlyWhitelisted returns (bool) {
        return super.increaseAllowance(spender, addedValue);
    }

    ///
    /// NOTE: only whitelisted access
    /// @inheritdoc ERC20
    ///
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public virtual override onlyWhitelisted returns (bool) {
        return super.decreaseAllowance(spender, subtractedValue);
    }

    ///
    /// NOTE: DISABLED
    /// @return 0
    /// @inheritdoc IERC4626
    ///
    function mint(
        uint256,
        address
    ) public virtual override(ERC4626, IERC4626) returns (uint256) {
        return 0;
    }

    ///
    /// NOTE: DISABLED
    /// @return 0
    /// @inheritdoc IERC4626
    ///
    function previewMint(
        uint256
    ) public view virtual override(ERC4626, IERC4626) returns (uint256) {
        return 0;
    }

    ///
    /// NOTE: DISABLED
    /// @return 0
    /// @inheritdoc IERC4626
    ///
    function maxMint(
        address
    ) public view virtual override(ERC4626, IERC4626) returns (uint256) {
        return 0;
    }

    ///
    /// @dev calculates maximum amount user is allowed to deposit in assets,
    /// this depends of current value of vault and user deposit amount.
    /// It is controlled by MAX_TICKET_SIZE and MAX_VAULT_VALUE
    /// @return maximum amount user can deposit to the vault in assets
    ///
    function maxDeposit(
        address receiver
    ) public view virtual override(ERC4626, IERC4626) returns (uint256) {
        return _maxDeposit(receiver, totalAssets());
    }

    ///
    /// @dev calculates maximum amount user is allowed to withdraw in assets,
    /// this on user withdrawal amount request.
    /// It is controlled by MAX_TICKET_SIZE
    /// @return maximum amount user can withdraw from the vault in assets
    ///
    function maxWithdraw(
        address owner
    ) public view virtual override(ERC4626, IERC4626) returns (uint256) {
        uint256 assets = _convertToAssets(balanceOf(owner), Math.Rounding.Down);

        return assets > MAX_TICKET_SIZE ? MAX_TICKET_SIZE : assets;
    }

    ///
    /// @dev calculates maximum amount user is allowed to redeem in tokens from the vault
    /// It is controlled by MAX_TICKET_SIZE
    /// @return maximum amount user can redeem from the vault in tokens
    ///
    function maxRedeem(
        address owner
    ) public view virtual override(ERC4626, IERC4626) returns (uint256) {
        uint256 tokens = balanceOf(owner);
        uint256 assets = _convertToAssets(tokens, Math.Rounding.Down);

        return
            assets > MAX_TICKET_SIZE
                ? convertToTokens(MAX_TICKET_SIZE)
                : tokens;
    }

    ///
    /// @dev calculates amount of tokens receiver will get based on asset deposit.
    /// @param assets amount of assets caller wants to deposit
    /// @param receiver address of the owner of deposit once deposit completes, this address will receive tokens.
    /// @return amount of tokens receiver will receive
    /// NOTE: this is protected generic template method for deposits and child contracts
    /// should provide necessary overriding.
    /// Ensure to call super.deposit from child contract to enforce access rights.
    /// Caller and receiver must be whitelisted
    /// Emits IERC4626.Deposit
    ///
    function deposit(
        uint256 assets,
        address receiver
    )
        public
        payable
        virtual
        override(ERC4626, IERC4626)
        onlyWhitelisted
        nonZeroAmount(assets)
        onlyReceiverWhitelisted(receiver)
        returns (uint256)
    {
        if (asset() == ETH) {
            if (assets != msg.value) {
                revert TransferDisbalance();
            }
            uint256 totalAssetBeforeDeposit = totalAssets() - msg.value;
            require(
                assets <= _maxDeposit(receiver, totalAssetBeforeDeposit),
                "ERC4626: deposit more than max"
            );

            uint256 supply = totalSupply();
            uint256 tokens = (assets == 0 || supply == 0)
                ? _initialConvertToShares(assets, Math.Rounding.Down)
                : assets.mulDiv(
                    supply,
                    totalAssetBeforeDeposit,
                    Math.Rounding.Down
                );

            _mint(receiver, tokens);

            emit Deposit(msg.sender, receiver, assets, tokens);

            return tokens;
        } else {
            return super.deposit(assets, receiver);
        }
    }

    ///
    /// @dev Burns exact number of tokens from owner and sends assets to receiver.
    /// @param tokens amount of tokens caller wants to redeem
    /// @param receiver address of the asset receiver
    /// @param owner address of the owner of tokens
    /// @return amount of assets receiver will receive based on exact burnt tokens
    /// NOTE: this is protected generic template method for redeeming and child contracts
    /// should provide necessary overriding.
    /// Ensure to call super.redeem from child contract to enforce access rights.
    /// Caller, receiver and owner must be whitelisted
    /// Emits IERC4626.Withdraw
    ///
    function redeem(
        uint256 tokens,
        address receiver,
        address owner
    )
        public
        virtual
        override(ERC4626, IERC4626)
        onlyWhitelisted
        nonZeroAmount(tokens)
        onlyReceiverOwnerWhitelisted(receiver, owner)
        returns (uint256)
    {
        if (asset() == ETH) {
            require(
                tokens <= maxRedeem(owner),
                "ERC4626: redeem more than max"
            );
            uint256 assets = previewRedeem(tokens);

            _burn(owner, tokens);

            (bool success, ) = payable(receiver).call{value: assets}("");
            if (!success) {
                revert TransferFailed();
            }
            emit Withdraw(msg.sender, receiver, owner, assets, tokens);

            return assets;
        } else {
            return super.redeem(tokens, receiver, owner);
        }
    }

    ///
    /// @dev Burns tokens from owner and sends exact number of assets to receiver
    /// @param assets amount of assets caller wants to withdraw
    /// @param receiver address of the asset receiver
    /// @param owner address of the owner of tokens
    /// @return amount of tokens burnt based on exact assets requested
    /// NOTE: this is protected generic template method for withdrawing and child contracts
    /// should provide necessary overriding.
    /// Ensure to call super.withdraw from child contract to enforce access rights.
    /// Caller, receiver and owner must be whitelisted
    /// Emits IERC4626.Withdraw
    ///
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    )
        public
        virtual
        override(ERC4626, IERC4626)
        onlyWhitelisted
        nonZeroAmount(assets)
        onlyReceiverOwnerWhitelisted(receiver, owner)
        returns (uint256)
    {
        if (asset() == ETH) {
            require(
                assets <= maxWithdraw(owner),
                "ERC4626: withdraw more than max"
            );

            uint256 tokens = previewWithdraw(assets);

            _burn(owner, tokens);
            (bool success, ) = payable(receiver).call{value: assets}("");
            if (!success) {
                revert TransferFailed();
            }
            emit Withdraw(msg.sender, receiver, owner, assets, tokens);

            return tokens;
        } else {
            return super.withdraw(assets, receiver, owner);
        }
    }

    ///
    /// @dev helper method - calculates maximum amount user is allowed to deposit in assets,
    /// this depends of current value of vault and user deposit amount.
    /// It is controlled by MAX_TICKET_SIZE and MAX_VAULT_VALUE
    /// @param totalAsset total assets in deposit currency
    /// @return maximum amount user can deposit to the vault in assets
    ///
    function _maxDeposit(
        address,
        uint256 totalAsset
    ) internal view returns (uint256) {
        if (MAX_VAULT_VALUE >= totalAsset) {
            uint256 maxValueDiff = MAX_VAULT_VALUE - totalAsset;
            if (maxValueDiff <= MAX_TICKET_SIZE) {
                return maxValueDiff;
            } else {
                return MAX_TICKET_SIZE;
            }
        } else {
            return 0;
        }
    }
}


// File: contracts/base/FijaStrategy.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;
pragma abicoder v2;

import "@openzeppelin/contracts/utils/Strings.sol";

import "./FijaERC4626Base.sol";
import "../interfaces/IFijaStrategy.sol";

///
/// @title Strategy Base contract
/// @author Fija
/// @notice Used as template for implementing strategy
/// @dev there are methods with minimum or no functionality
/// it is responsibility of child contracts to override them
///
contract FijaStrategy is IFijaStrategy, FijaERC4626Base {
    bool internal _isEmergencyMode = false;

    constructor(
        IERC20 asset_,
        address governance_,
        string memory tokenName_,
        string memory tokenSymbol_,
        uint256 maxTicketSize_,
        uint256 maxVaultValue_
    )
        FijaERC4626Base(
            asset_,
            governance_,
            address(0),
            tokenName_,
            tokenSymbol_,
            maxTicketSize_,
            maxVaultValue_
        )
    {}

    modifier emergencyModeRestriction() {
        if (_isEmergencyMode) {
            revert FijaInEmergencyMode();
        }
        _;
    }

    ///
    /// NOTE: only governance access
    /// @inheritdoc IFijaACL
    ///
    function addAddressToWhitelist(
        address addr
    ) public virtual override onlyGovernance returns (bool) {
        return super.addAddressToWhitelist(addr);
    }

    ///
    /// NOTE: only governance access
    /// @inheritdoc IFijaACL
    ///
    function removeAddressFromWhitelist(
        address addr
    ) public virtual override onlyGovernance returns (bool) {
        return super.removeAddressFromWhitelist(addr);
    }

    ///
    /// @inheritdoc IFijaStrategy
    ///
    function needRebalance() external view virtual override returns (bool) {
        return false;
    }

    ///
    /// NOTE: Only governance access; Not implemented
    /// emits IFijaStrategy.Rebalance
    /// @inheritdoc IFijaStrategy
    ///
    function rebalance()
        external
        virtual
        override
        onlyGovernance
        emergencyModeRestriction
    {
        emit Rebalance(block.timestamp, "");
    }

    ///
    /// @inheritdoc IFijaStrategy
    ///
    function needHarvest() external view virtual override returns (bool) {
        return false;
    }

    ///
    /// NOTE: Only governance access; Not implemented
    /// emits IFijaStrategy.Harvest
    /// @inheritdoc IFijaStrategy
    ///
    function harvest()
        external
        virtual
        override
        onlyGovernance
        emergencyModeRestriction
    {
        emit Harvest(block.timestamp, 0, 0, asset(), "");
    }

    ///
    /// @inheritdoc IFijaStrategy
    ///
    function needEmergencyMode() external view virtual override returns (bool) {
        return false;
    }

    ///
    /// NOTE: Only governance access; Not implemented
    /// emits IFijaStrategy.EmergencyMode
    /// @inheritdoc IFijaStrategy
    ///
    function setEmergencyMode(
        bool turnOn
    ) external virtual override onlyGovernance {
        _isEmergencyMode = turnOn;
        emit EmergencyMode(block.timestamp, turnOn);
    }

    ///
    /// @inheritdoc IFijaStrategy
    ///
    function emergencyMode() external view virtual override returns (bool) {
        return _isEmergencyMode;
    }

    ///
    /// @inheritdoc IFijaStrategy
    ///
    function status() external view virtual override returns (string memory) {
        string memory str = string(
            abi.encodePacked("totalAssets=", Strings.toString(totalAssets()))
        );

        return str;
    }

    ///
    /// NOTE: emergency mode check
    /// @inheritdoc FijaERC4626Base
    ///
    function deposit(
        uint256 assets,
        address receiver
    )
        public
        payable
        virtual
        override(FijaERC4626Base, IERC4626)
        emergencyModeRestriction
        returns (uint256)
    {
        return super.deposit(assets, receiver);
    }

    receive() external payable virtual {}
}


// File: contracts/interfaces/IERC4626.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)

// ####################################################
// ################## IMPORTANT #######################
// ####################################################
// NOTE fija Finance: ETH native compatibility -- Forked OZ contract and updated deposit method to become payable.

pragma solidity 0.8.10;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @dev Interface of the ERC4626 "Tokenized Vault Standard", as defined in
 * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].
 *
 * _Available since v4.7._
 */
interface IERC4626 is IERC20, IERC20Metadata {
    event Deposit(
        address indexed sender,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    event Withdraw(
        address indexed sender,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /**
     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.
     *
     * - MUST be an ERC-20 token contract.
     * - MUST NOT revert.
     */
    function asset() external view returns (address assetTokenAddress);

    /**
     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.
     *
     * - SHOULD include any compounding that occurs from yield.
     * - MUST be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT revert.
     */
    function totalAssets() external view returns (uint256 totalManagedAssets);

    /**
     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal
     * scenario where all the conditions are met.
     *
     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
     * - MUST NOT revert.
     *
     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the
     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and
     * from.
     */
    function convertToShares(
        uint256 assets
    ) external view returns (uint256 shares);

    /**
     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal
     * scenario where all the conditions are met.
     *
     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
     * - MUST NOT revert.
     *
     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the
     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and
     * from.
     */
    function convertToAssets(
        uint256 shares
    ) external view returns (uint256 assets);

    /**
     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,
     * through a deposit call.
     *
     * - MUST return a limited value if receiver is subject to some deposit limit.
     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.
     * - MUST NOT revert.
     */
    function maxDeposit(
        address receiver
    ) external view returns (uint256 maxAssets);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given
     * current on-chain conditions.
     *
     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit
     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called
     *   in the same transaction.
     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the
     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.
     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by depositing.
     */
    function previewDeposit(
        uint256 assets
    ) external view returns (uint256 shares);

    /**
     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.
     *
     * - MUST emit the Deposit event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   deposit execution, and are accounted for during deposit.
     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not
     *   approving enough underlying tokens to the Vault contract, etc).
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.
     */
    function deposit(
        uint256 assets,
        address receiver
    ) external payable returns (uint256 shares);

    /**
     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.
     * - MUST return a limited value if receiver is subject to some mint limit.
     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.
     * - MUST NOT revert.
     */
    function maxMint(
        address receiver
    ) external view returns (uint256 maxShares);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given
     * current on-chain conditions.
     *
     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call
     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the
     *   same transaction.
     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint
     *   would be accepted, regardless if the user has enough tokens approved, etc.
     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by minting.
     */
    function previewMint(uint256 shares) external view returns (uint256 assets);

    /**
     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.
     *
     * - MUST emit the Deposit event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint
     *   execution, and are accounted for during mint.
     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not
     *   approving enough underlying tokens to the Vault contract, etc).
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.
     */
    function mint(
        uint256 shares,
        address receiver
    ) external returns (uint256 assets);

    /**
     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the
     * Vault, through a withdraw call.
     *
     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
     * - MUST NOT revert.
     */
    function maxWithdraw(
        address owner
    ) external view returns (uint256 maxAssets);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,
     * given current on-chain conditions.
     *
     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw
     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if
     *   called
     *   in the same transaction.
     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though
     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.
     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by depositing.
     */
    function previewWithdraw(
        uint256 assets
    ) external view returns (uint256 shares);

    /**
     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.
     *
     * - MUST emit the Withdraw event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   withdraw execution, and are accounted for during withdraw.
     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner
     *   not having enough shares, etc).
     *
     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
     * Those methods should be performed separately.
     */
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256 shares);

    /**
     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,
     * through a redeem call.
     *
     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.
     * - MUST NOT revert.
     */
    function maxRedeem(address owner) external view returns (uint256 maxShares);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,
     * given current on-chain conditions.
     *
     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call
     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the
     *   same transaction.
     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the
     *   redemption would be accepted, regardless if the user has enough shares, etc.
     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.
     */
    function previewRedeem(
        uint256 shares
    ) external view returns (uint256 assets);

    /**
     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.
     *
     * - MUST emit the Withdraw event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   redeem execution, and are accounted for during redeem.
     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner
     *   not having enough shares, etc).
     *
     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
     * Those methods should be performed separately.
     */
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256 assets);
}


// File: contracts/interfaces/IFijaACL.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

///
/// @title Access control interface
/// @author Fija
/// @notice Defines methods and events for access control manipulation in contracts
///
interface IFijaACL {
    ///
    /// @dev emits when address is added to whitelist
    /// @param addr address added to the whitelist
    ///
    event WhitelistedAddressAdded(address addr);

    ///
    /// @dev emits when address is removed from whitelist
    /// @param addr address removed from the whitelist
    ///
    event WhitelistedAddressRemoved(address addr);

    ///
    /// @dev emits when owner is changed
    /// @param previousOwner address of previous owner
    /// @param newOwner address of new owner
    ///
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    ///
    /// @dev emits when governance is changed
    /// @param previousGovernance address of previous governance
    /// @param newGovernance address of new governance
    ///
    event GovernanceTransferred(
        address indexed previousGovernance,
        address indexed newGovernance
    );

    ///
    /// @dev emits when reseller is changed
    /// @param previousReseller address of previous reseller
    /// @param newReseller address of new reseller
    ///
    event ResellerTransferred(
        address indexed previousReseller,
        address indexed newReseller
    );

    ///
    /// @dev adds address to whitelist
    /// @param addr address to be added to whitelist
    /// @return true if address was added, false if it already in whitelist
    ///
    function addAddressToWhitelist(address addr) external returns (bool);

    ///
    /// @dev removes address from whitelist
    /// @param addr address to be removed from whitelist
    /// @return true if address was removed, false if it not in the whitelist
    ///
    function removeAddressFromWhitelist(address addr) external returns (bool);

    ///
    /// @dev contract owner
    /// @return address of the current owner
    ///
    function owner() external view returns (address);

    ///
    /// @dev contract governance
    /// @return address of the current governance
    ///
    function governance() external view returns (address);

    ///
    /// @dev contract reseller
    /// @return address of the current reseller
    ///
    function reseller() external view returns (address);

    ///
    /// @dev checks if address is in whitelist
    /// @param addr address to check if it is in whitelist
    /// @return true if address is in contract whitelist, false if it is not.
    ///
    function isWhitelisted(address addr) external view returns (bool);

    ///
    /// @dev changes ownership to new owner address
    /// @param newOwner address of new owner
    ///
    function transferOwnership(address newOwner) external;

    ///
    /// @dev changes governance to new governance address.
    /// @param newGovernance address of new governance
    ///
    function transferGovernance(address newGovernance) external;

    ///
    /// @dev changes reseller to new reseller address.
    /// @param newReseller address of new reseller
    ///
    function transferReseller(address newReseller) external;

    ///
    /// @dev Leaves the contract without governance.
    /// It will not be possible to call `onlyGovernance` functions anymore.
    /// Renouncing governance will leave the contract without governance,
    /// thereby removing any functionality that is only available to the governance.
    ///
    function renounceGovernance() external;

    ///
    /// @dev Leaves the contract without reseller.
    /// It will not be possible to call `onlyReseller` functions anymore.
    /// Renouncing reseller will leave the contract without reseller,
    /// thereby removing any functionality that is only available to the reseller.
    ///
    function renounceReseller() external;
}


// File: contracts/interfaces/IFijaERC4626Base.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "./IERC4626.sol";
import "./IFijaACL.sol";

///
/// @title Base interface
/// @author Fija
/// @notice Interface base layer for vault and strategy interfaces
///
interface IFijaERC4626Base is IFijaACL, IERC4626 {
    ///
    /// @dev Returns the amount of tokens that the Vault would exchange for the amount of assets provided, in an ideal
    /// scenario where all the conditions are met.
    ///
    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
    /// - MUST NOT show any variations depending on the caller.
    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
    /// - MUST NOT revert.
    ///
    /// NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the
    /// “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and
    /// from.
    /// @param assets amount to be converted to tokens amount
    ///
    function convertToTokens(
        uint256 assets
    ) external view returns (uint256 tokens);
}


// File: contracts/interfaces/IFijaStrategy.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "./IFijaERC4626Base.sol";

interface IFijaStrategy is IFijaERC4626Base {
    ///
    /// @dev emits when rebalance executes
    /// @param timestamp current timestamp when rebalance is executed
    /// @param data metadata associated with event
    ///
    event Rebalance(uint256 indexed timestamp, string data);

    ///
    /// @dev emits when harvest executes
    /// @param timestamp current timestamp when harvest is executed
    /// @param harvestResult amount of harvested funds
    /// @param profitShare amount of profits
    /// @param profitToken address of profit token
    /// @param data metadata associated with event
    ///
    event Harvest(
        uint256 indexed timestamp,
        uint256 harvestResult,
        uint256 profitShare,
        address profitToken,
        string data
    );

    ///
    /// @dev emits when emergency mode is toggled
    /// @param timestamp current timestamp when emergency mode is toggled
    /// @param turnOn flag for turning on/off emergency mode
    ///
    event EmergencyMode(uint256 indexed timestamp, bool turnOn);

    ///
    /// @dev check if there is a need to rebalance strategy funds
    /// @return bool indicating need for rebalance
    ///
    function needRebalance() external view returns (bool);

    ///
    /// @dev executes strategy rebalancing
    ///
    function rebalance() external;

    ///
    /// @dev check if there is a need to harvest strategy funds
    /// @return bool indicating need for harvesting
    ///
    function needHarvest() external view returns (bool);

    ///
    /// @dev executes strategy harvesting
    ///
    function harvest() external;

    ///
    /// @dev gets emergency mode status of strategy
    /// @return flag indicting emergency mode status
    ///
    function emergencyMode() external view returns (bool);

    ///
    /// @dev sets emergency mode on/off
    /// @param turnOn toggle flag
    ///
    function setEmergencyMode(bool turnOn) external;

    ///
    /// @dev check if there is a need for setting strategy in emergency mode
    /// @return bool indicating need for emergency mode
    ///
    function needEmergencyMode() external view returns (bool);

    ///
    /// @dev gets various strategy status parameters
    /// @return status parameters as string
    ///
    function status() external view returns (string memory);
}


// File: contracts/protocols/convex/interfaces/IApr.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface IApr {
    function apr(
        uint256 _rate,
        uint256 _priceOfRewards,
        uint256 _priceOfDeposits
    ) external view returns (uint256);

    function rewardRates(
        uint256 _pid
    ) external view returns (address[] calldata, uint256[] calldata);
}


// File: contracts/protocols/convex/interfaces/IBooster.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface IBooster {
    function owner() external view returns (address);

    function feeToken() external view returns (address);

    function feeDistro() external view returns (address);

    function lockFees() external view returns (address);

    function stakerRewards() external view returns (address);

    function lockRewards() external view returns (address);

    function setVoteDelegate(address _voteDelegate) external;

    function vote(
        uint256 _voteId,
        address _votingAddress,
        bool _support
    ) external returns (bool);

    function voteGaugeWeight(
        address[] calldata _gauge,
        uint256[] calldata _weight
    ) external returns (bool);

    function poolInfo(
        uint256 _pid
    )
        external
        view
        returns (
            address _lptoken,
            address _token,
            address _gauge,
            address _crvRewards,
            address _stash,
            bool _shutdown
        );

    function earmarkRewards(uint256 _pid) external returns (bool);

    function earmarkFees() external returns (bool);

    function isShutdown() external view returns (bool);

    function poolLength() external view returns (uint256);

    function depositAll(uint256 _pid, bool _stake) external returns (bool);

    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool _stake
    ) external returns (bool);

    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);

    function withdrawAll(uint256 _pid) external returns (bool);

    function withdrawTo(
        uint256 _pid,
        uint256 _amount,
        address _to
    ) external returns (bool);
}


// File: contracts/protocols/convex/interfaces/ICvxMining.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface ICvxMining {
    function ConvertCrvToCvx(uint256 _amount) external view returns (uint256);
}


// File: contracts/protocols/convex/interfaces/IRewardStaking.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface IRewardStaking {
    function stakeFor(address, uint256) external;

    function stake(uint256) external;

    function withdraw(uint256 amount, bool claim) external;

    function withdrawAndUnwrap(uint256 amount, bool claim) external;

    function earned(address account) external view returns (uint256);

    function getReward() external;

    function getReward(address _account, bool _claimExtras) external;

    function extraRewardsLength() external view returns (uint256);

    function extraRewards(uint256 _pid) external view returns (address);

    function rewardToken() external view returns (address);

    function balanceOf(address _account) external view returns (uint256);

    function rewardRate() external view returns (uint256);

    function totalSupply() external view returns (uint256);
}


// File: contracts/protocols/curve/interfaces/IAddressProvider.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface IAddressProvider {
    function get_registry() external view returns (address);

    function max_id() external view returns (uint256);

    function get_address(uint256 _id) external view returns (address);
}


// File: contracts/protocols/curve/interfaces/ICurve.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface ICurve {
    // add liquidity

    // 0
    function add_liquidity(
        uint256[3] calldata _amounts,
        uint256 _min_mint_amount
    ) external payable;

    // 1
    function add_liquidity(
        uint256[3] calldata _amounts,
        uint256 _min_mint_amount,
        bool _use_underlying_or_use_eth
    ) external payable;

    // 2
    function add_liquidity(
        uint256[2] calldata _amounts,
        uint256 _min_mint_amount
    ) external payable;

    // 3
    function add_liquidity(
        uint256[4] calldata _amounts,
        uint256 _min_mint_amount
    ) external;

    // 4
    function add_liquidity(
        uint256[2] calldata _amounts,
        uint256 _min_mint_amount,
        bool _use_underlying_or_use_eth
    ) external payable;

    // 5 meta zap
    function add_liquidity(
        address _pool,
        uint256[4] calldata _amounts,
        uint256 _min_mint_amount
    ) external;

    // 6 meta zap
    function add_liquidity(
        address _pool,
        uint256[3] calldata _amounts,
        uint256 _min_mint_amount
    ) external;

    // remove liquidity one coin

    // 0
    function remove_liquidity_one_coin(
        uint256 _burn_amount,
        int128 i,
        uint256 _min_received
    ) external;

    // 1
    function remove_liquidity_one_coin(
        uint256 _burn_amount,
        int128 i,
        uint256 _min_received,
        bool _use_underlying
    ) external;

    // 2
    function remove_liquidity_one_coin(
        uint256 _burn_amount,
        uint256 i,
        uint256 _min_received,
        bool _use_eth
    ) external;

    // 3
    function remove_liquidity_one_coin(
        uint256 _burn_amount,
        uint256 i,
        uint256 _min_received
    ) external;

    // 4 meta zap
    function remove_liquidity_one_coin(
        address _pool,
        uint256 _burn_amount,
        int128 i,
        uint256 _min_received
    ) external;

    // calc token amount

    // 0
    function calc_token_amount(
        uint256[3] calldata _amounts,
        bool _is_deposit
    ) external view returns (uint256);

    // 1
    function calc_token_amount(
        uint256[2] calldata _amounts,
        bool _is_deposit
    ) external view returns (uint256);

    // 2
    function calc_token_amount(
        uint256[4] calldata _amounts,
        bool _is_deposit
    ) external view returns (uint256);

    // 3
    function calc_token_amount(
        uint256[2] calldata _amounts
    ) external view returns (uint256);

    // 4 meta zap
    function calc_token_amount(
        address _pool,
        uint256[4] calldata _amounts,
        bool _is_deposit
    ) external view returns (uint256);

    // 5 meta zap
    function calc_token_amount(
        address _pool,
        uint256[3] calldata _amounts,
        bool _is_deposit
    ) external view returns (uint256);

    // cal withdraw one coin

    // 0
    function calc_withdraw_one_coin(
        uint256 _burn_amount,
        int128 i
    ) external view returns (uint256);

    // 1
    function calc_withdraw_one_coin(
        uint256 _burn_amount,
        int128 i,
        bool _use_underlying
    ) external view returns (uint256);

    // 2
    function calc_withdraw_one_coin(
        uint256 _burn_amount,
        uint256 i
    ) external view returns (uint256);

    // 3
    function calc_withdraw_one_coin(
        address _pool,
        uint256 _burn_amount,
        int128 i
    ) external view returns (uint256);

    // get exchange amount;

    //

    // 1
    function get_dy(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    // 4
    function get_dy(
        address pool,
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    // 5
    function get_dy_underlying(
        address pool,
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    // 6
    function get_dy(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256);

    // 2
    function get_dy_underlying(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256);

    // 3
    function get_dy_underlying(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    ///
    // exchange

    // 3
    function exchange_underlying(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    // 2
    function exchange_underlying(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    // 5
    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    // 1
    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        bool use_eth
    ) external payable returns (uint256);

    // 4
    function exchange(
        address pool,
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    // 6
    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    function coins(uint256 index) external view returns (address);

    function underlying_coins(uint256 index) external view returns (address);
}


// File: contracts/protocols/curve/interfaces/ICurveMetaRegistry.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface ICurveMetaRegistry {
    function get_lp_token(address pool) external view returns (address);

    function get_underlying_coins(
        address pool
    ) external view returns (address[8] calldata);

    function is_meta(address pool) external view returns (bool);

    function get_coins(
        address pool
    ) external view returns (address[8] calldata);

    function get_balances(
        address pool
    ) external view returns (uint256[8] calldata);
}


// File: contracts/protocols/curve/interfaces/IExchangeRegistry.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface IExchangeRegistry {
    function get_best_rate(
        address _from,
        address _to,
        uint256 _amount
    ) external view returns (address, uint256);

    function get_exchange_amount(
        address _pool,
        address _from,
        address _to,
        uint256 _amount
    ) external view returns (uint256);

    function exchange(
        address _pool,
        address _from,
        address _to,
        uint256 _amount,
        uint256 _expected,
        address _receiver
    ) external payable returns (uint256);

    function exchange_with_best_rate(
        address _from,
        address _to,
        uint256 _amount,
        uint256 _expected,
        address _receiver
    ) external returns (uint256);
}


// File: contracts/strategies/CurveConvex/CurveConvexBase.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../../base/FijaStrategy.sol";
import "./CurveConvexStrategyProtocol.sol";
import "./errors.sol";
import "../../protocols/curve/interfaces/ICurve.sol";
import "./ICurveConvexPeriphery.sol";

struct CoinRating {
    // token address used in liquidity pools
    address coinAddr;
    // rating of token used in liquidity pools
    uint8 rating;
}

struct Pool {
    // pool address
    address addr;
    // deposit zap for the pool
    address deposit;
    // pool category to reference correct interface
    uint8[4] category;
}

struct EmergencyPool {
    // pool address
    address addr;
    // deposit zap for pool
    address deposit;
    // exchange category to reference correct interface
    uint8[2] exchangeCategory;
}

struct RewardPoolInput {
    // address of pool used in reward route
    address addr;
    // deposit zap for the pool
    address deposit;
    // "from" address in exchange pair
    address from;
    // "to" address in exchange pair
    address to;
    // exchange category to reference correct interface
    uint8[2] exchangeCategory;
}

struct RewardPool {
    // address of pool used in reward route
    address addr;
    // "from" address in exchange pair
    address from;
    // "to" address in exchange pair
    address to;
}

struct ConstructorData {
    // flag for checking depeg
    bool dePegCheck;
    // flag for disabling emergency pool
    bool isEmePoolDisabled;
    // emergency token address
    address emergencyCurrency;
    //address used for linking contracts
    address linkAddr;
    // harvest time frequency
    uint256 harvestTime;
    // rebalance time param
    uint256 rebalanceTimeLower;
    // rebalance time param
    uint256 rebalanceTimeUpper;
    // depeg deviation in bps
    uint256 depegDev;
    // swap slippage in bps
    uint256 slippageSwap;
    // slippage during emergency mode in bps
    uint256 slippageEmergency;
    // threshold used in rebalance procedure
    uint256 rebalanceThreshold1;
    // threshold used in rebalance procedure
    uint256 rebalanceThreshold2;
    // liquidity threshold in bps
    uint256 liquidityThresholdBps;
    // list of liquidity pools used in strategy
    Pool[] curvePools;
    // list of token ratings used in strategy
    CoinRating[] coinRating;
    // emergency pool data
    EmergencyPool emergencyPool;
    // list of pools used in CRV reward route
    RewardPoolInput[] crvRewardRoute;
    // list of pools used in CVX reward route
    RewardPoolInput[] cvxRewardRoute;
}

///
/// @title Curve Convex Base contrat
/// @author Fija
/// @notice Used to initalize main and periphery contract variables
/// @dev Enables spliting contracts to main and periphery with access to same data
/// NOTE: Parent contract to CurveConvexPeriphery and CurveConvexStrategy
///
abstract contract CurveConvexBase is FijaStrategy, CurveConvexStrategyProtocol {
    ///
    /// @dev number of liquidity pools used in strategy
    ///
    uint8 internal immutable POOL_NUM;

    ///
    /// @dev deposit token used in strategy
    ///
    address internal immutable DEPOSIT_CCY;

    ///
    /// @dev flag is depeg checked in the strategy
    ///
    bool internal DE_PEG_CHECK;

    ///
    /// @dev flag is emergency pool disabled
    ///
    bool internal EME_POOL_DISABLED;

    ///
    /// @dev harvest time frequency
    ///
    uint256 internal HARVEST_TIME;

    ///
    /// @dev rebalance time parameter
    ///
    uint256 internal REBALANCE_TIME_UPPER;

    ///
    /// @dev rebalance time parameter
    ///
    uint256 internal REBALANCE_TIME_LOWER;

    ///
    /// @dev depeg deviation in bps
    ///
    uint256 internal DEPEG_DEVIATION;

    ///
    /// @dev slippage swap in bps
    ///
    uint256 internal SLIPPAGE_SWAP;

    ///
    /// @dev rebalance threshold used when calling needRebalance()
    ///
    uint256 internal REBALANCE_THR1;

    ///
    /// @dev rebalance threshold used when calling needRebalance()
    ///
    uint256 internal REBALANCE_THR2;

    ///
    /// @dev slippage when in emergency mode
    ///
    uint256 internal SLIPPAGE_EMERGENCY;

    ///
    /// @dev liquidity threshold for low-liquidity pool checks
    ///
    uint256 internal LIQUIDITY_THR_BPS;

    ///
    /// @dev timestamp for last harvest time in seconds
    ///
    uint256 internal _lastHarvestTime;

    ///
    /// @dev timestamp for last rebalance time in seconds
    ///
    uint256 internal _lastRebalanceTime;

    ///
    /// @dev emergency token address
    ///
    address internal EMERGENCY_CCY;

    ///
    /// @dev pool used to transfer assets to emergency token when emergency mode is triggered
    ///
    address internal _emergencyPool;

    ///
    /// @dev list of Curve pools used for providing liquidity
    ///
    address[] internal _curvePools;

    ///
    /// @dev list of pools data for CRV reward route
    ///
    RewardPool[] internal _crvRewardRoute;

    ///
    /// @dev list of pools data for CVX reward route
    ///
    RewardPool[] internal _cvxRewardRoute;

    ///
    /// @dev maps address of reward pool to token address index indicating
    /// token position in pool, used in reward route swaps
    ///
    mapping(address => mapping(address => uint256))
        internal _rewardPoolCoinIndex;

    ///
    /// @dev maps pool to deposit contract, needed when
    /// providing liquidity and swaps requires use of seperate deposit contracts
    ///
    mapping(address => address) internal _poolDepositCtr;

    ///
    /// @dev maps Curve liquidity pool to corresponding reward contract on Convex
    ///
    mapping(address => address) internal _poolRewardContract;

    ///
    /// @dev maps Curve liquidity pool to it's LP token
    ///
    mapping(address => address) internal _poolLpToken;

    ///
    /// @dev maps Curve liquidity pool to it's rating
    /// 2 decimals precision
    ///
    mapping(address => uint256) internal _poolRating;

    ///
    /// @dev maps Curve liquidity pool deposit token index,
    /// this indicates deposit token position in the pool, used for swaps
    ///
    mapping(address => int128) internal _poolDepositCcyIndex;

    ///
    /// @dev maps Curve liquidity pool to corresponding Convex pool id
    ///
    mapping(address => uint16) internal _poolConvexPoolId;

    ///
    /// @dev maps Curve liquidity pool to list of categories,
    /// used to invoke correct interface method when working with liquidity
    ///
    mapping(address => uint8[4]) internal _poolCategory;

    ///
    /// @dev maps emergency or reward route pool to list of exchange categories,
    /// used to invoke correct interface method when performing swaps
    ///
    mapping(address => uint8[2]) internal _poolExchangeCategory;

    constructor(
        address depositCurrency_,
        address governance_,
        string memory tokenName_,
        string memory tokenSymbol_,
        uint256 maxTicketSize_,
        uint256 maxVaultValue_,
        ConstructorData memory data_
    )
        FijaStrategy(
            IERC20(depositCurrency_),
            governance_,
            tokenName_,
            tokenSymbol_,
            maxTicketSize_,
            maxVaultValue_
        )
    {
        _lastHarvestTime = block.timestamp;
        _lastRebalanceTime = block.timestamp;

        DEPEG_DEVIATION = data_.depegDev;
        REBALANCE_TIME_LOWER = data_.rebalanceTimeLower;
        REBALANCE_TIME_UPPER = data_.rebalanceTimeUpper;
        HARVEST_TIME = data_.harvestTime;

        REBALANCE_THR1 = data_.rebalanceThreshold1;
        REBALANCE_THR2 = data_.rebalanceThreshold2;

        SLIPPAGE_EMERGENCY = data_.slippageEmergency;
        SLIPPAGE_SWAP = data_.slippageSwap;

        LIQUIDITY_THR_BPS = data_.liquidityThresholdBps;
        DE_PEG_CHECK = data_.dePegCheck;
        EME_POOL_DISABLED = data_.isEmePoolDisabled;

        DEPOSIT_CCY = depositCurrency_;
        EMERGENCY_CCY = data_.emergencyCurrency;
        POOL_NUM = uint8(data_.curvePools.length);

        // #### build CRV route storage var #####
        RewardPoolInput[] memory crvRewardRoute = data_.crvRewardRoute;
        for (uint8 i = 0; i < crvRewardRoute.length; i++) {
            _crvRewardRoute.push(
                RewardPool(
                    crvRewardRoute[i].addr,
                    crvRewardRoute[i].from,
                    crvRewardRoute[i].to
                )
            );

            _poolDepositCtr[crvRewardRoute[i].addr] = crvRewardRoute[i].deposit;
            _poolExchangeCategory[crvRewardRoute[i].addr] = crvRewardRoute[i]
                .exchangeCategory;

            // no exchange support, build rewardRoute coin indexes for swaps
            if (crvRewardRoute[i].exchangeCategory[0] != 0) {
                address rewardRoutePool = crvRewardRoute[i].addr;
                address[8] memory poolCoins = _underlyingCoins(rewardRoutePool);

                for (uint8 j = 0; j < poolCoins.length; j++) {
                    if (poolCoins[j] == address(0)) {
                        break;
                    }
                    _rewardPoolCoinIndex[rewardRoutePool][poolCoins[j]] = j;
                }
            }
        }
        // #### build CVX route storage var #####
        RewardPoolInput[] memory cvxRewardRoute = data_.cvxRewardRoute;
        for (uint8 i = 0; i < cvxRewardRoute.length; i++) {
            _cvxRewardRoute.push(
                RewardPool(
                    cvxRewardRoute[i].addr,
                    cvxRewardRoute[i].from,
                    cvxRewardRoute[i].to
                )
            );
            _poolDepositCtr[cvxRewardRoute[i].addr] = cvxRewardRoute[i].deposit;
            _poolExchangeCategory[cvxRewardRoute[i].addr] = cvxRewardRoute[i]
                .exchangeCategory;

            // no exchange support, build rewardRoute coin indexes
            if (cvxRewardRoute[i].exchangeCategory[0] != 0) {
                address rewardRoutePool = cvxRewardRoute[i].addr;
                address[8] memory poolCoins = _underlyingCoins(rewardRoutePool);

                for (uint8 j = 0; j < poolCoins.length; j++) {
                    if (poolCoins[j] == address(0)) {
                        break;
                    }
                    _rewardPoolCoinIndex[rewardRoutePool][poolCoins[j]] = j;
                }
            }
        }
        // #### build curve pool storage variables #####
        Pool[] memory curvePools = data_.curvePools;
        CoinRating[] memory coinRating = data_.coinRating;
        for (uint8 i = 0; i < curvePools.length; i++) {
            address curveAddr = curvePools[i].addr;
            _curvePools.push(curveAddr);
            _poolDepositCtr[curveAddr] = curvePools[i].deposit;
            _poolCategory[curveAddr] = curvePools[i].category;
            _poolLpToken[curveAddr] = Curve_ICurveMetaRegistry.get_lp_token(
                curveAddr
            );

            address[8] memory poolCoins = _underlyingCoins(curveAddr);

            _poolDepositCcyIndex[curveAddr] = _findCoinIndex(
                poolCoins,
                depositCurrency_
            );

            // create pool ratings
            bool isFound;
            uint16 ratingSum = 0;
            for (uint8 j = 0; j < poolCoins.length; j++) {
                if (poolCoins[j] == address(0)) {
                    break;
                }
                isFound = false;
                for (uint8 k = 0; k < coinRating.length; k++) {
                    if (poolCoins[j] == coinRating[k].coinAddr) {
                        isFound = true;
                        ratingSum += coinRating[k].rating;
                        break;
                    }
                }
                if (!isFound) {
                    revert FijaPoolRatingInvalid();
                }
            }

            _poolRating[curveAddr] = (ratingSum * 100) / poolCoins.length;

            // associate convex pool with curve pool through curve LP token
            uint256 convexPoolLength = Convex_IBooster.poolLength();
            isFound = false;
            for (uint16 j = 0; j < convexPoolLength; j++) {
                // gets curveLP token from convex pool
                (
                    address clpToken,
                    ,
                    ,
                    address rewardContract,
                    ,
                    bool isShutdown
                ) = Convex_IBooster.poolInfo(j);
                // check if convex curveLP tokens matches with curve pool lp token
                if (!isShutdown && clpToken == _poolLpToken[curveAddr]) {
                    isFound = true;
                    _poolConvexPoolId[curveAddr] = j;
                    _poolRewardContract[curveAddr] = rewardContract;

                    break;
                }
            }
            if (!isFound) {
                revert FijaConvexPoolUnknown();
            }
        }

        // #### initalize emergency pool #####
        _emergencyPool = data_.emergencyPool.addr;
        _poolExchangeCategory[_emergencyPool] = data_
            .emergencyPool
            .exchangeCategory;
        _poolDepositCtr[_emergencyPool] = data_.emergencyPool.deposit;

        // no exchange support, build emergency coin indexes
        if (data_.emergencyPool.exchangeCategory[0] != 0) {
            address[8] memory emeCoins = _underlyingCoins(_emergencyPool);

            for (uint8 j = 0; j < emeCoins.length; j++) {
                if (emeCoins[j] == address(0)) {
                    break;
                }
                _rewardPoolCoinIndex[_emergencyPool][emeCoins[j]] = j;
            }
        }
    }

    ///
    /// @dev Helper method querying which tokens pool supports. Only non-wrapped.
    /// @param pool address for which addresses of pool tokens are fetched
    /// @return array with token addresses inside pool
    ///
    function _underlyingCoins(
        address pool
    ) internal view returns (address[8] memory) {
        bool isMeta = Curve_ICurveMetaRegistry.is_meta(pool);

        address[8] memory underCoins = Curve_ICurveMetaRegistry
            .get_underlying_coins(pool);

        if (!isMeta) {
            address[8] memory coins = Curve_ICurveMetaRegistry.get_coins(pool);
            if (_isEqualAddr(coins, underCoins)) {
                if (!_isTokenAddrIn(coins, WETH)) {
                    // plain or plain eth pool
                    return coins;
                } else {
                    // pool which takes eth and wrapped eth
                    // but replaces WETH with ETH address as it's underlying
                    address[8] memory replacedCoins = _findAddrReplace(
                        coins,
                        WETH,
                        ETH
                    );
                    return replacedCoins;
                }
            } else {
                if (
                    _isTokenAddrIn(coins, ETH) &&
                    _isTokenAddrIn(underCoins, ETH)
                ) {
                    // plain eth pool
                    return coins;
                } else {
                    // normal lending pool
                    if (_isAllDiffAddr(coins, underCoins)) {
                        return underCoins;
                    } else {
                        revert FijaUnknownPoolForCoins();
                    }
                }
            }
        } else {
            return underCoins;
        }
    }

    ///
    /// @dev Helper method finding correct index in array of coins
    /// @param coins array of token addresses
    /// @param coin address of token for queried index
    /// @return token index in coins array
    /// NOTE: throws if index is not found
    ///
    function _findCoinIndex(
        address[8] memory coins,
        address coin
    ) internal pure returns (int128) {
        for (uint256 i = 0; i < coins.length; i++) {
            if (coins[i] == coin && coins[i] != address(0)) {
                return int128(int256(i));
            }
        }
        revert FijaCoinIndexNotFound();
    }

    ///
    /// @dev Helper method to build array which is provided to liquidity methods
    /// There is always 1 non-zero value in array, as there is only 1 token to
    /// use as deposit token in strategy
    /// @param amount array of token addresses
    /// @param index indicating token position in the pool
    /// @return array of values with 1 non-zero value on index which indicates
    /// deposit token index inside pool
    ///
    function _buildInputAmount(
        uint256 amount,
        int128 index
    ) internal pure returns (uint256[4] memory) {
        uint256[4] memory inputs = [
            uint256(0),
            uint256(0),
            uint256(0),
            uint256(0)
        ];
        inputs[uint256(uint128(index))] = amount;
        return inputs;
    }

    ///
    /// @dev Helper method which finds address in array and replaces it with different address
    /// @param inputAddrs array of token address on which to perform find and replace
    /// @param find address of token to replace
    /// @param replaceWith address of token to replace with
    /// @return array of addresses modified with replaceWith if flag is true
    ///
    function _findAddrReplace(
        address[8] memory inputAddrs,
        address find,
        address replaceWith
    ) private pure returns (address[8] memory) {
        for (uint8 i = 0; i < inputAddrs.length; i++) {
            if (inputAddrs[i] == find) {
                inputAddrs[i] = replaceWith;
                break;
            }
        }
        return inputAddrs;
    }

    ///
    /// @dev Helper method which checks if token address exists in array
    /// @param inputAddrs array of token address on which to perform find
    /// @param token address of token to find
    /// @return flag indicating if token is found in the inputAddrs
    ///
    function _isTokenAddrIn(
        address[8] memory inputAddrs,
        address token
    ) private pure returns (bool) {
        for (uint8 i = 0; i < inputAddrs.length; i++) {
            if (inputAddrs[i] == token) {
                return true;
            }
        }
        return false;
    }

    ///
    /// @dev Helper method to verify if 2 array are equal
    /// @param A array of token addresses to compare
    /// @param B array of token addresses to compare
    /// @return flag indicting if arrays are equal
    ///
    function _isEqualAddr(
        address[8] memory A,
        address[8] memory B
    ) private pure returns (bool) {
        for (uint8 i = 0; i < A.length; i++) {
            if (A[i] != B[i]) {
                return false;
            }
        }
        return true;
    }

    ///
    /// @dev Helper method to verify if 2 array are different on all positions
    /// @param A array of token addresses to compare
    /// @param B array of token addresses to compare
    /// @return flag indicting if arrays are not equal
    ///
    function _isAllDiffAddr(
        address[8] memory A,
        address[8] memory B
    ) private pure returns (bool) {
        for (uint8 i = 0; i < A.length; i++) {
            if (A[i] == B[i] && A[i] != address(0)) {
                return false;
            }
        }
        return true;
    }
}


// File: contracts/strategies/CurveConvex/CurveConvexPeriphery.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "./CurveConvexStrategyProtocol.sol";
import "./errors.sol";
import "./ICurveConvexPeriphery.sol";
import "./CurveConvexBase.sol";
import "../../interfaces/IFijaStrategy.sol";

///
/// @title Curve Convex Periphery
/// @author Fija
/// @notice View methods to support main strategy contract operations
/// @dev To offload size and heavy view methods for off-chain usage
///
contract CurveConvexPeriphery is CurveConvexBase, ICurveConvexPeriphery {
    ///
    /// @dev reference to main strategy contract
    ///
    address internal STRATEGY;

    constructor(
        address depositCurrency_,
        address governance_,
        string memory tokenName_,
        string memory tokenSymbol_,
        uint256 maxTicketSize_,
        uint256 maxVaultValue_,
        ConstructorData memory data_
    )
        CurveConvexBase(
            depositCurrency_,
            governance_,
            tokenName_,
            tokenSymbol_,
            maxTicketSize_,
            maxVaultValue_,
            data_
        )
    {}

    ///
    /// @dev link to base strategy contract
    /// @param strategy address to associate periphery contract with main strategy contract
    ///
    function setStrategy(address strategy) public onlyOwner {
        STRATEGY = strategy;
    }

    ///
    /// NOTE: uses pool categories and deposit zap addresses to identify the interface and invoke methods on proper contracts
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function calcTokenAmount(
        address pool,
        uint256 depositAmount,
        bool isDeposit
    ) external view override returns (uint256) {
        uint8 id = _poolCategory[pool][2];
        uint256[4] memory amounts = _buildInputAmount(
            depositAmount,
            _poolDepositCcyIndex[pool]
        );
        if (id == 0) {
            uint256[3] memory inputs = [amounts[0], amounts[1], amounts[2]];

            return ICurve(pool).calc_token_amount(inputs, isDeposit);
        } else if (id == 1) {
            uint256[2] memory inputs = [amounts[0], amounts[1]];

            return ICurve(pool).calc_token_amount(inputs, isDeposit);
        } else if (id == 2) {
            if (_poolDepositCtr[pool] != address(0)) {
                pool = _poolDepositCtr[pool];
            }
            return ICurve(pool).calc_token_amount(amounts, isDeposit);
        } else if (id == 3) {
            uint256[2] memory inputs = [amounts[0], amounts[1]];

            return ICurve(pool).calc_token_amount(inputs);
        } else if (id == 4) {
            return
                ICurve(_poolDepositCtr[pool]).calc_token_amount(
                    pool,
                    amounts,
                    isDeposit
                );
        } else if (id == 5) {
            uint256[3] memory inputs = [amounts[0], amounts[1], amounts[2]];
            return
                ICurve(_poolDepositCtr[pool]).calc_token_amount(
                    pool,
                    inputs,
                    isDeposit
                );
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    ///
    /// NOTE: uses pool categories and deposit zap addresses to identify the interface and invoke methods on proper contracts
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function calcWithdrawOneCoin(
        address pool,
        uint256 burnAmount,
        int128 i
    ) public view returns (uint256) {
        uint8 id = _poolCategory[pool][3];
        if (id == 0) {
            if (_poolDepositCtr[pool] != address(0)) {
                pool = _poolDepositCtr[pool];
            }
            try ICurve(pool).calc_withdraw_one_coin(burnAmount, i) returns (
                uint256 amount
            ) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 1) {
            try
                ICurve(pool).calc_withdraw_one_coin(burnAmount, i, true)
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 2) {
            try
                ICurve(pool).calc_withdraw_one_coin(
                    burnAmount,
                    uint256(int256(i))
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 3) {
            try
                ICurve(_poolDepositCtr[pool]).calc_withdraw_one_coin(
                    pool,
                    burnAmount,
                    i
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    ///
    /// NOTE: uses pool categories and deposit zap addresses to identify the interface and invoke methods on proper contracts
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function getExchangeAmount(
        address pool,
        address from,
        address to,
        uint256 input
    ) public view override returns (uint256) {
        uint8 id = _poolExchangeCategory[pool][0];
        if (id == 0) {
            IExchangeRegistry ex = IExchangeRegistry(
                Curve_IAddressProvider.get_address(CURVE_EXCHANGE_ID)
            );
            try ex.get_exchange_amount(pool, from, to, input) returns (
                uint256 amount
            ) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 1) {
            address depo = pool;
            if (_poolDepositCtr[pool] != address(0)) {
                depo = _poolDepositCtr[pool];
            }
            try
                ICurve(depo).get_dy(
                    _rewardPoolCoinIndex[pool][from],
                    _rewardPoolCoinIndex[pool][to],
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 2) {
            address depo = pool;
            if (_poolDepositCtr[pool] != address(0)) {
                depo = _poolDepositCtr[pool];
            }
            try
                ICurve(depo).get_dy_underlying(
                    int128(uint128(_rewardPoolCoinIndex[pool][from])),
                    int128(uint128(_rewardPoolCoinIndex[pool][to])),
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 3) {
            // deposit zap
            try
                ICurve(_poolDepositCtr[pool]).get_dy_underlying(
                    _rewardPoolCoinIndex[pool][from],
                    _rewardPoolCoinIndex[pool][to],
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 4) {
            // deposit zap
            try
                ICurve(_poolDepositCtr[pool]).get_dy(
                    pool,
                    _rewardPoolCoinIndex[pool][from],
                    _rewardPoolCoinIndex[pool][to],
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 5) {
            // deposit zap
            try
                ICurve(_poolDepositCtr[pool]).get_dy_underlying(
                    pool,
                    _rewardPoolCoinIndex[pool][from],
                    _rewardPoolCoinIndex[pool][to],
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else if (id == 6) {
            try
                ICurve(pool).get_dy(
                    int128(uint128(_rewardPoolCoinIndex[pool][from])),
                    int128(uint128(_rewardPoolCoinIndex[pool][to])),
                    input
                )
            returns (uint256 amount) {
                return amount;
            } catch {
                return 0;
            }
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    ///
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function exposureDiff(
        uint256 targetExposure
    ) external view override returns (int256[8] memory, uint256[] memory) {
        (uint256[2] memory crvCvxInDepositCCy, , ) = crvCvxToDepositCcy(
            [PRECISION_18, PRECISION_18]
        );
        uint256[] memory numerators = new uint256[](POOL_NUM);
        uint256 denominator = 0;

        for (uint8 i = 0; i < POOL_NUM; i++) {
            address pool = _curvePools[i];
            numerators[i] =
                _poolYield(crvCvxInDepositCCy[0], crvCvxInDepositCCy[1], pool) *
                _poolRating[pool];

            denominator += numerators[i];
        }
        int256[8] memory poolExDiff;
        uint256[] memory poolAllocationsLogBps = new uint256[](POOL_NUM);

        for (uint8 i = 0; i < POOL_NUM; i++) {
            address pool = _curvePools[i];

            uint256 currentPoolExp = calcWithdrawOneCoin(
                pool,
                IERC20(_poolRewardContract[pool]).balanceOf(STRATEGY),
                _poolDepositCcyIndex[pool]
            );
            uint256 poolAllocation = (numerators[i] * PRECISION_30) /
                denominator;

            poolAllocationsLogBps[i] =
                (numerators[i] * BASIS_POINTS_DIVISOR) /
                denominator;

            uint256 targetPoolExposure = (targetExposure * poolAllocation) /
                PRECISION_30;

            poolExDiff[i] = int256(currentPoolExp) - int256(targetPoolExposure);
        }
        return (poolExDiff, poolAllocationsLogBps);
    }

    ///
    /// NOTE: exchange hop results are used as part of harvest when exchanging CRV/CVX to deposit tokens, xwthrough reward routes
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function crvCvxToDepositCcy(
        uint256[2] memory inputs
    )
        public
        view
        returns (uint256[2] memory, uint256[] memory, uint256[] memory)
    {
        uint8 poolNum = uint8(_crvRewardRoute.length);
        bool isEmergencyMode = IFijaStrategy(STRATEGY).emergencyMode();

        uint256[] memory crvIntermed = new uint256[](poolNum);

        // calculate CRV to deposit currency amount
        for (uint8 i = 0; i < poolNum; i++) {
            uint256 amount = getExchangeAmount(
                _crvRewardRoute[i].addr,
                _crvRewardRoute[i].from,
                _crvRewardRoute[i].to,
                inputs[0]
            );
            uint256 slippage = SLIPPAGE_SWAP;
            if (isEmergencyMode) {
                slippage = SLIPPAGE_EMERGENCY;
            }
            inputs[0] =
                (amount * (BASIS_POINTS_DIVISOR - slippage)) /
                BASIS_POINTS_DIVISOR;
            if (inputs[0] == 0) {
                break;
            }

            crvIntermed[i] = inputs[0];
        }
        poolNum = uint8(_cvxRewardRoute.length);

        uint256[] memory cvxIntermed = new uint256[](poolNum);
        // save intermed exchange values to use for swaps

        // calculate CVX to deposit currency amount
        for (uint8 i = 0; i < poolNum; i++) {
            uint256 amount = getExchangeAmount(
                _cvxRewardRoute[i].addr,
                _cvxRewardRoute[i].from,
                _cvxRewardRoute[i].to,
                inputs[1]
            );
            uint256 slippage = SLIPPAGE_SWAP;
            if (isEmergencyMode) {
                slippage = SLIPPAGE_EMERGENCY;
            }
            inputs[1] =
                (amount * (BASIS_POINTS_DIVISOR - slippage)) /
                BASIS_POINTS_DIVISOR;
            if (inputs[1] == 0) {
                break;
            }
            cvxIntermed[i] = inputs[1];
        }
        // amount in depositCCy
        return ([inputs[0], inputs[1]], crvIntermed, cvxIntermed);
    }

    ///
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function needEmergencyMode()
        external
        view
        override(FijaStrategy, ICurveConvexPeriphery)
        returns (bool)
    {
        uint256 depositDec = decimals();

        for (uint8 i = 0; i < POOL_NUM; i++) {
            address pool = _curvePools[i];

            uint256 lpTokenInDepositCCy = calcWithdrawOneCoin(
                pool,
                PRECISION_18,
                _poolDepositCcyIndex[pool]
            );

            // check de-peg
            if (DE_PEG_CHECK) {
                address[8] memory coins = _underlyingCoins(pool);
                for (uint8 j = 0; j < coins.length; j++) {
                    if (coins[j] == address(0)) {
                        break;
                    }
                    if (coins[j] != DEPOSIT_CCY) {
                        int128 coinIndex = _findCoinIndex(coins, coins[j]);
                        uint256 nonDepositDec = ERC20(coins[j]).decimals();

                        uint256 value = calcWithdrawOneCoin(
                            pool,
                            PRECISION_18,
                            coinIndex
                        );
                        value =
                            (((value * 10 ** depositDec) /
                                (10 ** nonDepositDec)) * 10000) /
                            lpTokenInDepositCCy;
                        // 4 decimals precision
                        if (
                            value < (10000 - DEPEG_DEVIATION) ||
                            value > (10000 + DEPEG_DEVIATION)
                        ) {
                            return true;
                        }
                    }
                }
            }
            // check low liquidity
            uint256 currentPoolExposure = (lpTokenInDepositCCy *
                IERC20(_poolRewardContract[pool]).balanceOf(STRATEGY)) /
                PRECISION_18;

            uint256 tvlPoolPerc = (((lpTokenInDepositCCy *
                IERC20(_poolLpToken[pool]).totalSupply()) / PRECISION_18) *
                LIQUIDITY_THR_BPS) / BASIS_POINTS_DIVISOR;

            if (currentPoolExposure > tvlPoolPerc) {
                return true;
            }
        }
        return false;
    }

    ///
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function totalAssets()
        external
        view
        override(IERC4626, ICurveConvexPeriphery)
        returns (uint256)
    {
        uint256 emergencyCcyValue = 0;

        if (IFijaStrategy(STRATEGY).emergencyMode()) {
            // calculate value in emergencyCCy
            emergencyCcyValue = getExchangeAmount(
                _emergencyPool,
                EMERGENCY_CCY,
                DEPOSIT_CCY,
                IERC20(EMERGENCY_CCY).balanceOf(STRATEGY)
            );
        }
        uint256 depositCcyValue;

        if (DEPOSIT_CCY == ETH) {
            depositCcyValue = STRATEGY.balance;
        } else {
            depositCcyValue = IERC20(DEPOSIT_CCY).balanceOf(STRATEGY);
        }
        // calculate value of lp tokens
        uint256 valueOfLpTokens = 0;
        for (uint8 i = 0; i < POOL_NUM; i++) {
            address pool = _curvePools[i];

            valueOfLpTokens += calcWithdrawOneCoin(
                pool,
                IERC20(_poolRewardContract[pool]).balanceOf(STRATEGY),
                _poolDepositCcyIndex[pool]
            );
        }
        return valueOfLpTokens + emergencyCcyValue + depositCcyValue;
    }

    ///
    /// NOTE: total assets, pools, Lp tokens amount / pool, assets deployed / pool
    /// unclaimed rewards, amount in deposit token on strategy, amount in emergency token on strategy
    /// @inheritdoc ICurveConvexPeriphery
    ///
    function status()
        external
        view
        virtual
        override(FijaStrategy, ICurveConvexPeriphery)
        returns (string memory)
    {
        string memory str1 = string(
            abi.encodePacked("totalAssets:", Strings.toString(totalAssets()))
        );

        string memory str2 = "";

        uint256 crvEarned = 0;
        for (uint8 i = 0; i < POOL_NUM; i++) {
            address pool = _curvePools[i];

            uint256 amountInLpTokens = IERC20(_poolRewardContract[pool])
                .balanceOf(STRATEGY);

            uint256 poolValue = calcWithdrawOneCoin(
                pool,
                amountInLpTokens,
                _poolDepositCcyIndex[pool]
            );
            str2 = string(
                abi.encodePacked(
                    str2,
                    "|Pool:",
                    Strings.toHexString(uint256(uint160(pool)), 20),
                    "|LpTokens:",
                    Strings.toString(amountInLpTokens),
                    "|Value:",
                    Strings.toString(poolValue)
                )
            );

            (, , , address rewardContract, , ) = Convex_IBooster.poolInfo(
                _poolConvexPoolId[pool]
            );
            crvEarned += IRewardStaking(rewardContract).earned(STRATEGY);
        }

        uint256 depositCCyValue;
        uint256 emergencyCCyValue = 0;

        if (!EME_POOL_DISABLED) {
            emergencyCCyValue = IERC20(EMERGENCY_CCY).balanceOf(STRATEGY);
        }
        if (DEPOSIT_CCY == ETH) {
            depositCCyValue = STRATEGY.balance;
        } else {
            depositCCyValue = IERC20(DEPOSIT_CCY).balanceOf(STRATEGY);
        }
        return
            string(
                abi.encodePacked(
                    str1,
                    "|UnclaimedRewards:",
                    Strings.toString(
                        crvEarned + Convex_ICvxMining.ConvertCrvToCvx(crvEarned)
                    ),
                    "|DepositCcyAmount:",
                    Strings.toString(depositCCyValue),
                    "|EmergencyCcyAmount:",
                    EME_POOL_DISABLED
                        ? "N/A"
                        : Strings.toString(emergencyCCyValue),
                    str2
                )
            );
    }

    ///
    /// @dev Helper method to calculatee pool yield
    /// @param crvInDepositCCy exchange rate CRV/deposit token
    /// @param cvxInDepositCcy exchange rate CVX/deposit token
    /// @param pool address of pool
    /// @return APR of the pool in bps (14 decimals precision)
    /// NOTE: APR is sum of CRV reward apr and CVX reward apr
    ///
    function _poolYield(
        uint256 crvInDepositCCy,
        uint256 cvxInDepositCcy,
        address pool
    ) private view returns (uint256) {
        uint256 lpTokenPriceInDepositCcy = calcWithdrawOneCoin(
            pool,
            PRECISION_18,
            _poolDepositCcyIndex[pool]
        );

        (, uint256[] memory rates) = Convex_IApr.rewardRates(
            _poolConvexPoolId[pool]
        );
        uint256 crvApr = Convex_IApr.apr(
            rates[0],
            crvInDepositCCy,
            lpTokenPriceInDepositCcy
        );
        uint256 cvxApr = Convex_IApr.apr(
            rates[1],
            cvxInDepositCcy,
            lpTokenPriceInDepositCcy
        );

        return crvApr + cvxApr;
    }
}


// File: contracts/strategies/CurveConvex/CurveConvexStrategy.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../../base/FijaStrategy.sol";
import "./CurveConvexStrategyProtocol.sol";
import "./errors.sol";
import "../../protocols/curve/interfaces/ICurve.sol";
import "./ICurveConvexPeriphery.sol";
import "./CurveConvexBase.sol";
import "./CurveConvexPeriphery.sol";

///
/// @title Curve Convex Strategy
/// @author Fija
/// @notice Main contract used for asset management
/// @dev Responsibe for adding or removing the liquidity from the pool,
/// executing swaps, harvesting and rebalancing assets
///
contract CurveConvexStrategy is CurveConvexBase {
    ICurveConvexPeriphery internal immutable PERIPHERY;

    constructor(
        address depositCurrency_,
        address governance_,
        string memory tokenName_,
        string memory tokenSymbol_,
        uint256 maxTicketSize_,
        uint256 maxVaultValue_,
        ConstructorData memory data_
    )
        CurveConvexBase(
            depositCurrency_,
            governance_,
            tokenName_,
            tokenSymbol_,
            maxTicketSize_,
            maxVaultValue_,
            data_
        )
    {
        PERIPHERY = ICurveConvexPeriphery(data_.linkAddr);
    }

    ///
    /// NOTE: uses periphery contract to query total assets it has under management
    /// @inheritdoc IERC4626
    ///
    function totalAssets() public view virtual override returns (uint256) {
        return PERIPHERY.totalAssets();
    }

    ///
    /// @dev calculates amount of tokens receiver will get based on asset deposit.
    /// @param assets amount of assets caller wants to deposit
    /// @param receiver address of the owner of deposit once deposit completes, this address will receive tokens.
    /// @return amount of tokens receiver will receive
    /// NOTE: Executes deposits to curve pools and stakes LP tokens to Convex pools
    /// Caller and receiver must be whitelisted
    /// Cannot deposit in emergency mode
    /// Emits IERC4626.Deposit
    ///
    function deposit(
        uint256 assets,
        address receiver
    )
        public
        payable
        virtual
        override
        emergencyModeRestriction
        returns (uint256)
    {
        uint256 tokens = super.deposit(assets, receiver);

        // find lowest negative difference between target and current exposure
        (int256[8] memory poolExpDiff, ) = PERIPHERY.exposureDiff(
            totalAssets()
        );
        address depositCcy = DEPOSIT_CCY;
        uint256 remainingToDeposit;

        if (depositCcy == ETH) {
            remainingToDeposit = address(this).balance;
        } else {
            remainingToDeposit = IERC20(depositCcy).balanceOf(address(this));
        }

        while (remainingToDeposit > 0) {
            uint8 minIndex = 0;
            int256 minDiff = 0;

            for (uint8 i = 0; i < POOL_NUM; i++) {
                if (poolExpDiff[i] < minDiff) {
                    minDiff = poolExpDiff[i];
                    minIndex = i;
                }
            }
            if (minDiff < 0) {
                uint256 assetsToDeposit = 0;
                if (int256(remainingToDeposit) + minDiff <= 0) {
                    // deposit all assets to pool
                    assetsToDeposit = remainingToDeposit;
                    remainingToDeposit = 0;
                } else {
                    // deposit difference
                    assetsToDeposit = uint256(minDiff * -1);
                    remainingToDeposit -= assetsToDeposit;

                    // reduce deposited exposure
                    poolExpDiff[minIndex] = 0;
                }
                address pool = _curvePools[minIndex];

                uint256 minAmount = PERIPHERY.calcTokenAmount(
                    pool,
                    assetsToDeposit,
                    true
                );
                minAmount =
                    (minAmount * (BASIS_POINTS_DIVISOR - SLIPPAGE_SWAP)) /
                    BASIS_POINTS_DIVISOR;

                address depositCtr = _poolDepositCtr[pool];
                if (depositCcy != ETH) {
                    SafeERC20.forceApprove(
                        IERC20(depositCcy),
                        depositCtr != address(0) ? depositCtr : pool,
                        assetsToDeposit
                    );
                }
                address lpToken = _poolLpToken[pool];

                // deposit to curve pools to get LP tokens
                _addLiquidity(pool, assetsToDeposit, minAmount);

                SafeERC20.forceApprove(
                    IERC20(lpToken),
                    address(Convex_IBooster),
                    IERC20(lpToken).balanceOf(address(this))
                );
                // stake all LPtokens to convex
                Convex_IBooster.depositAll(_poolConvexPoolId[pool], true);
            } else {
                // no positive discrepancy, so end logic
                remainingToDeposit = 0;
            }
        }
        return tokens;
    }

    ///
    /// @dev Burns tokens from owner and sends exact number of assets to receiver
    /// @param assets amount of assets caller wants to withdraw
    /// @param receiver address of the asset receiver
    /// @param owner address of the owner of tokens
    /// @return amount of tokens burnt based on exact assets requested
    /// NOTE: unstakes LP tokens from Convex pools and removes liquidity from Curve pools
    /// Caller, receiver and owner must be whitelisted
    /// Emits IERC4626.Withdraw
    ///
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external virtual override(IERC4626) returns (uint256) {
        _withdraw(assets);
        return super.withdraw(assets, receiver, owner);
    }

    ///
    /// @dev Burns exact number of tokens from owner and sends assets to receiver.
    /// @param tokens amount of tokens caller wants to redeem
    /// @param receiver address of the asset receiver
    /// @param owner address of the owner of tokens
    /// @return amount of assets receiver will receive based on exact burnt tokens
    /// NOTE: unstakes LP tokens from Convex pools and removes liquidity from Curve pools
    /// Caller, receiver and owner must be whitelisted
    /// Emits IERC4626.Withdraw
    ///
    function redeem(
        uint256 tokens,
        address receiver,
        address owner
    ) external virtual override returns (uint256) {
        uint256 assets = previewRedeem(tokens);
        _withdraw(assets);
        return super.redeem(tokens, receiver, owner);
    }

    ///
    /// NOTE: harvest is scheduled
    /// @inheritdoc IFijaStrategy
    ///
    function needHarvest() external view virtual override returns (bool) {
        if (block.timestamp >= _lastHarvestTime + HARVEST_TIME) {
            return true;
        }
        return false;
    }

    ///
    /// NOTE: Only governance access
    /// Restricted in emergency mode
    /// emits IFijaStrategy.Harvest
    /// @inheritdoc IFijaStrategy
    ///
    function harvest()
        public
        virtual
        override
        onlyGovernance
        emergencyModeRestriction
    {
        // get rewards from each pool
        for (uint8 i = 0; i < POOL_NUM; i++) {
            IRewardStaking(_poolRewardContract[_curvePools[i]]).getReward(
                address(this),
                false
            );
        }
        // convert CRV and CVX rewards to deposit currency
        uint256 crvAmount = IERC20(CRV).balanceOf(address(this));
        uint256 cvxAmount = IERC20(CVX).balanceOf(address(this));
        (
            uint256[2] memory output,
            uint256[] memory crvIntermed,
            uint256[] memory cvxIntermed
        ) = PERIPHERY.crvCvxToDepositCcy([crvAmount, cvxAmount]);

        if (output[0] != 0) {
            uint8 poolNum = uint8(_crvRewardRoute.length);
            // calculate CRV to deposit currency amount
            for (uint8 i = 0; i < poolNum; i++) {
                crvAmount = _exchange(
                    _crvRewardRoute[i].addr,
                    _crvRewardRoute[i].from,
                    _crvRewardRoute[i].to,
                    crvAmount,
                    crvIntermed[i]
                );
            }
        } else {
            crvAmount = 0;
        }
        if (output[1] != 0) {
            uint8 poolNum = uint8(_cvxRewardRoute.length);
            // calculate CVX to deposit currency amount
            for (uint8 i = 0; i < poolNum; i++) {
                cvxAmount = _exchange(
                    _cvxRewardRoute[i].addr,
                    _cvxRewardRoute[i].from,
                    _cvxRewardRoute[i].to,
                    cvxAmount,
                    cvxIntermed[i]
                );
            }
        } else {
            cvxAmount = 0;
        }

        _lastHarvestTime = block.timestamp;
        uint256 totalRewards = crvAmount + cvxAmount;

        uint256 share = 0;
        address depositCcy = DEPOSIT_CCY;

        if (totalRewards > 0) {
            share = (totalRewards * 2500) / BASIS_POINTS_DIVISOR;

            if (depositCcy == ETH) {
                (bool success, ) = payable(governance()).call{value: share}("");
                if (!success) {
                    revert TransferFailed();
                }
            } else {
                SafeERC20.safeTransfer(IERC20(depositCcy), governance(), share);
            }
        }
        emit Harvest(block.timestamp, totalRewards, share, depositCcy, "");
    }

    ///
    /// NOTE uses periphery contract to query needEmergencyMode()
    /// @inheritdoc IFijaStrategy
    ///
    function needEmergencyMode() public view virtual override returns (bool) {
        return PERIPHERY.needEmergencyMode();
    }

    ///
    /// NOTE: Only governance access
    /// emits IFijaStrategy.EmergencyMode
    /// @inheritdoc IFijaStrategy
    ///
    function setEmergencyMode(
        bool turnOn
    ) external virtual override onlyGovernance {
        emit EmergencyMode(block.timestamp, turnOn);

        address depositCcy = DEPOSIT_CCY;
        if (turnOn) {
            _isEmergencyMode = true;

            for (uint8 i = 0; i < POOL_NUM; i++) {
                address pool = _curvePools[i];
                address rewardContract = _poolRewardContract[pool];

                uint256 balanceLpToken = IERC20(rewardContract).balanceOf(
                    address(this)
                );
                IRewardStaking(rewardContract).withdrawAndUnwrap(
                    balanceLpToken,
                    false
                );
                // convert LP tokens to deposit currency
                int128 depositIndex = _poolDepositCcyIndex[pool];

                uint256 minOutCoin = PERIPHERY.calcWithdrawOneCoin(
                    pool,
                    balanceLpToken,
                    depositIndex
                );
                // liquidate token
                if (minOutCoin != 0) {
                    minOutCoin =
                        (minOutCoin *
                            (BASIS_POINTS_DIVISOR - SLIPPAGE_EMERGENCY)) /
                        BASIS_POINTS_DIVISOR;

                    address depositCtr = _poolDepositCtr[pool];
                    if (depositCtr != address(0)) {
                        SafeERC20.forceApprove(
                            IERC20(_poolLpToken[pool]),
                            depositCtr,
                            balanceLpToken
                        );
                    }
                    _removeLiquidityOneCoin(
                        pool,
                        balanceLpToken,
                        depositIndex,
                        minOutCoin
                    );
                }
            }
            // if emergency pool is disabled no swaps
            if (EME_POOL_DISABLED) {
                return;
            }
            // convert all deposit currency to emergency currency
            uint256 amountToExchange;
            if (depositCcy == ETH) {
                amountToExchange = address(this).balance;
            } else {
                amountToExchange = IERC20(depositCcy).balanceOf(address(this));
            }

            uint256 minOut = PERIPHERY.getExchangeAmount(
                _emergencyPool,
                depositCcy,
                EMERGENCY_CCY,
                amountToExchange
            );

            if (minOut != 0) {
                minOut =
                    (minOut * (BASIS_POINTS_DIVISOR - SLIPPAGE_EMERGENCY)) /
                    BASIS_POINTS_DIVISOR;

                _exchange(
                    _emergencyPool,
                    depositCcy,
                    EMERGENCY_CCY,
                    amountToExchange,
                    minOut
                );
            }
        } else {
            _isEmergencyMode = false;
            // if emergency pool is disabled no swaps just rebalance
            if (EME_POOL_DISABLED) {
                rebalance();
                return;
            }

            // convert emergency currency to deposit currency
            uint256 amountToExchange = IERC20(EMERGENCY_CCY).balanceOf(
                address(this)
            );

            uint256 minOut = PERIPHERY.getExchangeAmount(
                _emergencyPool,
                EMERGENCY_CCY,
                depositCcy,
                amountToExchange
            );
            if (minOut != 0) {
                minOut =
                    (minOut * (BASIS_POINTS_DIVISOR - SLIPPAGE_SWAP)) /
                    BASIS_POINTS_DIVISOR;

                _exchange(
                    _emergencyPool,
                    EMERGENCY_CCY,
                    depositCcy,
                    amountToExchange,
                    minOut
                );
            }
            rebalance();
        }
    }

    ///
    /// NOTE: rebalance is perfomed based on timespan and total asset thresholds
    /// @inheritdoc IFijaStrategy
    ///
    function needRebalance() external view virtual override returns (bool) {
        uint256 totalAsset = totalAssets();
        if (
            _lastRebalanceTime + REBALANCE_TIME_UPPER < block.timestamp &&
            REBALANCE_THR1 <= totalAsset &&
            REBALANCE_THR2 > totalAsset
        ) {
            return true;
        }
        if (
            _lastRebalanceTime + REBALANCE_TIME_LOWER < block.timestamp &&
            REBALANCE_THR2 <= totalAsset
        ) {
            return true;
        }
        return false;
    }

    ///
    /// NOTE: Only governance access
    /// Restricted in emergency mode
    /// emits IFijaStrategy.Rebalance
    /// @inheritdoc IFijaStrategy
    ///
    function rebalance()
        public
        virtual
        override
        onlyGovernance
        emergencyModeRestriction
    {
        _lastRebalanceTime = block.timestamp;
        (
            int256[8] memory poolExpDiff,
            uint256[] memory poolAllocationsBps
        ) = PERIPHERY.exposureDiff(totalAssets());

        // first settle the positives, reduction of exposure
        uint8 poolNum = POOL_NUM;
        for (uint8 i = 0; i < poolNum; i++) {
            address pool = _curvePools[i];
            if (poolExpDiff[i] > 0) {
                // increase lpTokens to withdraw in order to ensure to get atleasst poolExpDiff[i]
                uint256 lpTokensToWithdraw = PERIPHERY.calcTokenAmount(
                    pool,
                    (uint256(poolExpDiff[i]) *
                        (BASIS_POINTS_DIVISOR + SLIPPAGE_SWAP)) /
                        BASIS_POINTS_DIVISOR,
                    false
                );
                // get lp tokens from convex
                IRewardStaking(_poolRewardContract[pool]).withdrawAndUnwrap(
                    lpTokensToWithdraw,
                    false
                );
                // special approve for deposit zaps
                address depositCtr = _poolDepositCtr[pool];
                if (depositCtr != address(0)) {
                    SafeERC20.forceApprove(
                        IERC20(_poolLpToken[pool]),
                        depositCtr,
                        lpTokensToWithdraw
                    );
                }
                // liquidate lp tokens on curve
                _removeLiquidityOneCoin(
                    pool,
                    lpTokensToWithdraw,
                    _poolDepositCcyIndex[pool],
                    uint256(poolExpDiff[i]) //minOut
                );
            }
        }
        // second settle the negatives, increase of exposure
        string memory str = "";
        for (uint8 i = 0; i < poolNum; i++) {
            address pool = _curvePools[i];
            str = string(
                abi.encodePacked(
                    str,
                    "|Pool:",
                    Strings.toHexString(uint256(uint160(pool)), 20),
                    "|AllocationBps:",
                    Strings.toString(poolAllocationsBps[i])
                )
            );
            if (poolExpDiff[i] < 0) {
                uint256 assetsToDeposit = uint256(poolExpDiff[i] * -1);
                address depositCcy = DEPOSIT_CCY;
                if (depositCcy != ETH) {
                    address depositCtr = _poolDepositCtr[pool];
                    SafeERC20.forceApprove(
                        IERC20(depositCcy),
                        depositCtr != address(0) ? depositCtr : pool,
                        assetsToDeposit
                    );
                }
                uint256 minOut = PERIPHERY.calcTokenAmount(
                    pool,
                    assetsToDeposit,
                    true
                );
                minOut =
                    (minOut * (BASIS_POINTS_DIVISOR - SLIPPAGE_SWAP)) /
                    BASIS_POINTS_DIVISOR;

                address lpToken = _poolLpToken[pool];

                _addLiquidity(pool, assetsToDeposit, minOut);

                SafeERC20.forceApprove(
                    IERC20(lpToken),
                    address(Convex_IBooster),
                    IERC20(lpToken).balanceOf(address(this))
                );
                // stake LPtokens to convex
                Convex_IBooster.depositAll(_poolConvexPoolId[pool], true);
            }
        }
        emit Rebalance(block.timestamp, str);
    }

    ///
    /// NOTE: uses periphery contract to query status()
    /// @inheritdoc IFijaStrategy
    ///
    function status() external view virtual override returns (string memory) {
        return PERIPHERY.status();
    }

    ///
    /// @dev Helper for withdraw and redeem methods, contains main logic for
    /// balanced assets withdrawals from liquidity pools when
    /// @param assets amount of assets caller wants to withdraw
    ///
    function _withdraw(uint256 assets) private {
        uint256 currentBalance;
        address depositCcy = DEPOSIT_CCY;

        if (depositCcy == ETH) {
            currentBalance = address(this).balance;
        } else {
            currentBalance = IERC20(depositCcy).balanceOf(address(this));
        }

        // check if we have any
        if (assets > currentBalance) {
            uint256 remainingToWithdraw = assets - currentBalance;
            if (!_isEmergencyMode) {
                (int256[8] memory poolExpDiff, ) = PERIPHERY.exposureDiff(
                    totalAssets() - assets
                );

                while (remainingToWithdraw > 0) {
                    uint8 maxIndex = 0;
                    int256 maxDiff = 0;
                    // find biggest positive difference between target and current exposure
                    for (uint8 i = 0; i < POOL_NUM; i++) {
                        if (poolExpDiff[i] > maxDiff) {
                            maxDiff = poolExpDiff[i];
                            maxIndex = i;
                        }
                    }
                    if (maxDiff > 0) {
                        uint256 assetsToWithdraw = 0;
                        if (int256(remainingToWithdraw) - maxDiff <= 0) {
                            // withdraw all assets from the pool
                            assetsToWithdraw = remainingToWithdraw;
                            remainingToWithdraw = 0;
                        } else {
                            // withdraw difference
                            assetsToWithdraw = uint256(maxDiff);
                            remainingToWithdraw -= assetsToWithdraw;

                            // reduce deposited exposure
                            poolExpDiff[maxIndex] = 0;
                        }
                        address pool = _curvePools[maxIndex];

                        uint256 lpTokensToWithdraw = ICurveConvexPeriphery(
                            PERIPHERY
                        ).calcTokenAmount(pool, assetsToWithdraw, false);

                        // include slippage to get enough assets out
                        lpTokensToWithdraw =
                            (lpTokensToWithdraw *
                                (BASIS_POINTS_DIVISOR + SLIPPAGE_SWAP)) /
                            BASIS_POINTS_DIVISOR;

                        // check if we are burning more then we have
                        address rewardContract = _poolRewardContract[pool];
                        uint256 lpTokenBalance = IERC20(rewardContract)
                            .balanceOf(address(this));

                        if (lpTokensToWithdraw > lpTokenBalance) {
                            lpTokensToWithdraw = lpTokenBalance;
                            assetsToWithdraw =
                                (assetsToWithdraw *
                                    (BASIS_POINTS_DIVISOR - SLIPPAGE_SWAP)) /
                                BASIS_POINTS_DIVISOR;
                        }
                        // get lp tokens from convex
                        IRewardStaking(rewardContract).withdrawAndUnwrap(
                            lpTokensToWithdraw,
                            false
                        );
                        // special approval for deposit zaps
                        address depositCtr = _poolDepositCtr[pool];
                        if (depositCtr != address(0)) {
                            SafeERC20.forceApprove(
                                IERC20(_poolLpToken[pool]),
                                depositCtr,
                                lpTokensToWithdraw
                            );
                        }
                        // liquidate lp tokens on curve to get deposit currency out
                        _removeLiquidityOneCoin(
                            pool,
                            lpTokensToWithdraw,
                            _poolDepositCcyIndex[pool],
                            assetsToWithdraw //minOut
                        );
                    } else {
                        remainingToWithdraw = 0;
                    }
                }
            } else {
                // in emergency mode, convert emergency to deposit and withdraw
                address emergencyCcy = EMERGENCY_CCY;
                uint256 amount = PERIPHERY.getExchangeAmount(
                    _emergencyPool,
                    depositCcy,
                    emergencyCcy,
                    remainingToWithdraw
                );
                if (amount == 0) {
                    revert FijaInsufficientAmountToWithdraw();
                }

                uint256 emergencyCCyAmount = (amount *
                    (BASIS_POINTS_DIVISOR + SLIPPAGE_EMERGENCY)) /
                    BASIS_POINTS_DIVISOR;

                // check if we have enough of emergencyCcy
                uint256 emergencyCcyBalance = IERC20(emergencyCcy).balanceOf(
                    address(this)
                );
                if (emergencyCCyAmount > emergencyCcyBalance) {
                    emergencyCCyAmount = emergencyCcyBalance;
                    remainingToWithdraw =
                        (remainingToWithdraw *
                            (BASIS_POINTS_DIVISOR - SLIPPAGE_SWAP)) /
                        BASIS_POINTS_DIVISOR;
                }

                _exchange(
                    _emergencyPool,
                    emergencyCcy,
                    depositCcy,
                    emergencyCCyAmount,
                    remainingToWithdraw
                );
            }
        }
    }

    ///
    /// @dev Helper for providing liquidity to Curve pools
    /// Used to brige difference in pool interfaces
    /// @param pool address to which liquidity is provided
    /// @param depositAmount amount in deposit tokens to provide to liquidity pools
    /// @param minMintAmount minimum amount of LP token expected to receive
    /// NOTE: some pool require use of special deposit contracts for operations
    ///
    function _addLiquidity(
        address pool,
        uint256 depositAmount,
        uint256 minMintAmount
    ) private {
        uint8 id = _poolCategory[pool][0];
        int128 depositCcyIndex = _poolDepositCcyIndex[pool];

        uint256[4] memory amounts = _buildInputAmount(
            depositAmount,
            depositCcyIndex
        );
        address depositCcy = DEPOSIT_CCY;

        address origPool;
        address depositCtr = _poolDepositCtr[pool];
        if (depositCtr != address(0)) {
            origPool = pool;
            pool = depositCtr;
        }
        if (id == 0) {
            uint256 ethValue = 0;
            if (depositCcy == ETH) {
                ethValue = depositAmount;
            }
            uint256[3] memory inputs = [amounts[0], amounts[1], amounts[2]];

            ICurve(pool).add_liquidity{value: ethValue}(inputs, minMintAmount);
        } else if (id == 1) {
            uint256[3] memory inputs = [amounts[0], amounts[1], amounts[2]];

            uint256 ethValue = 0;
            if (depositCcy == ETH) {
                ethValue = depositAmount;
            }
            ICurve(pool).add_liquidity{value: ethValue}(
                inputs,
                minMintAmount,
                true
            );
        } else if (id == 2) {
            uint256[2] memory inputs = [amounts[0], amounts[1]];

            uint256 ethValue = 0;
            if (depositCcy == ETH) {
                ethValue = depositAmount;
            }
            ICurve(pool).add_liquidity{value: ethValue}(inputs, minMintAmount);
        } else if (id == 3) {
            ICurve(pool).add_liquidity(amounts, minMintAmount);
        } else if (id == 4) {
            uint256[2] memory inputs = [amounts[0], amounts[1]];

            uint256 ethValue = 0;
            if (depositCcy == ETH) {
                ethValue = depositAmount;
            }

            ICurve(pool).add_liquidity{value: ethValue}(
                inputs,
                minMintAmount,
                true
            );
        } else if (id == 5) {
            ICurve(pool).add_liquidity(origPool, amounts, minMintAmount);
        } else if (id == 6) {
            uint256[3] memory inputs = [amounts[0], amounts[1], amounts[2]];
            ICurve(pool).add_liquidity(origPool, inputs, minMintAmount);
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    ///
    /// @dev Helper for calculating amount of deposit tokens to receive when burning LP tokens
    /// Used to brige difference in pool interfaces
    /// @param pool address of Curve liquidity pool which holds LP tokens
    /// @param burnAmount amount of LP tokens to burn
    /// @param i index indicating token position in the pool, this indicates type of token received in return
    /// @param minReceived minimum amount of deposit tokens expected to receive
    /// NOTE: some pool require use of special deposit contracts for operations
    ///
    function _removeLiquidityOneCoin(
        address pool,
        uint256 burnAmount,
        int128 i,
        uint256 minReceived
    ) private {
        uint8 id = _poolCategory[pool][1];
        address depositCtr = _poolDepositCtr[pool];

        address origPool;
        if (depositCtr != address(0)) {
            origPool = pool;
            pool = depositCtr;
        }
        if (id == 0) {
            ICurve(pool).remove_liquidity_one_coin(burnAmount, i, minReceived);
        } else if (id == 1) {
            ICurve(pool).remove_liquidity_one_coin(
                burnAmount,
                i,
                minReceived,
                true
            );
        } else if (id == 2) {
            ICurve(pool).remove_liquidity_one_coin(
                burnAmount,
                uint256(int256(i)),
                minReceived,
                true
            );
        } else if (id == 3) {
            ICurve(pool).remove_liquidity_one_coin(
                burnAmount,
                uint256(int256(i)),
                minReceived
            );
        } else if (id == 4) {
            ICurve(pool).remove_liquidity_one_coin(
                origPool,
                burnAmount,
                i,
                minReceived
            );
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    ///
    /// @dev Helper for executing swap between two tokens
    /// Used to brige difference in pool interfaces
    /// @param pool address of Curve liquidity pool
    /// @param from token address exchanging "from"
    /// @param to token address exchanging "to"
    /// @param input amount of "from" tokens to exchange
    /// @param minOut minimum amount of "to" tokens expected to receive
    /// NOTE: some pool require use of special deposit contracts for operations
    ///
    function _exchange(
        address pool,
        address from,
        address to,
        uint256 input,
        uint256 minOut
    ) private returns (uint256) {
        address poolDeposit = _poolDepositCtr[pool];
        uint8 id = _poolExchangeCategory[pool][1];

        uint256 i = _rewardPoolCoinIndex[pool][from];
        uint256 j = _rewardPoolCoinIndex[pool][to];
        if (id == 0) {
            IExchangeRegistry ex = IExchangeRegistry(
                Curve_IAddressProvider.get_address(CURVE_EXCHANGE_ID)
            );

            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), address(ex), input);
            }
            return
                ex.exchange{value: ethValue}(
                    pool,
                    from,
                    to,
                    input,
                    minOut,
                    address(this)
                );
        } else if (id == 1) {
            address depo = pool;
            if (poolDeposit != address(0)) {
                depo = poolDeposit;
            }
            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), depo, input);
            }

            return
                ICurve(depo).exchange{value: ethValue}(
                    i,
                    j,
                    input,
                    minOut,
                    true
                );
        } else if (id == 2) {
            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), pool, input);
            }
            return
                ICurve(pool).exchange_underlying{value: ethValue}(
                    int128(uint128(i)),
                    int128(uint128(j)),
                    input,
                    minOut
                );
        } else if (id == 3) {
            // deposit zap
            address depo = pool;
            if (poolDeposit != address(0)) {
                depo = poolDeposit;
            }

            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), depo, input);
            }

            return
                ICurve(depo).exchange_underlying{value: ethValue}(
                    i,
                    j,
                    input,
                    minOut
                );
        } else if (id == 4) {
            // deposit zap
            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), poolDeposit, input);
            }
            return
                ICurve(poolDeposit).exchange{value: ethValue}(
                    pool,
                    i,
                    j,
                    input,
                    minOut
                );
        } else if (id == 5) {
            address depo = pool;
            if (poolDeposit != address(0)) {
                depo = poolDeposit;
            }
            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), depo, input);
            }
            return
                ICurve(depo).exchange{value: ethValue}(
                    int128(uint128(i)),
                    int128(uint128(j)),
                    input,
                    minOut
                );
        } else if (id == 6) {
            // deposit zap
            address depo = pool;
            if (poolDeposit != address(0)) {
                depo = poolDeposit;
            }

            uint256 ethValue = 0;
            if (from == ETH) {
                ethValue = input;
            } else {
                SafeERC20.forceApprove(IERC20(from), depo, input);
            }

            return ICurve(depo).exchange{value: ethValue}(i, j, input, minOut);
        } else {
            revert FijaInvalidPoolCategory();
        }
    }

    receive() external payable override {}
}


// File: contracts/strategies/CurveConvex/CurveConvexStrategyProtocol.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../../protocols/convex/interfaces/IBooster.sol";
import "../../protocols/convex/interfaces/IApr.sol";
import "../../protocols/convex/interfaces/ICvxMining.sol";
import "../../protocols/convex/interfaces/IRewardStaking.sol";
import "../../protocols/curve/interfaces/IAddressProvider.sol";
import "../../protocols/curve/interfaces/IExchangeRegistry.sol";
import "../../protocols/curve/interfaces/ICurveMetaRegistry.sol";
import "../../protocols/curve/interfaces/ICurve.sol";

///
/// @title Curve Convex Strategy Protocol
/// @author Fija
/// @notice Hold protocol references and constants used in the strategy
/// @dev Inherited by both peripery and main strategy contract
///
contract CurveConvexStrategyProtocol {
    uint256 internal constant CURVE_EXCHANGE_ID = 2;

    uint256 internal constant PRECISION_18 = 10 ** 18;

    uint256 internal constant PRECISION_30 = 10 ** 30;

    uint256 internal constant BASIS_POINTS_DIVISOR = 10000;

    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address internal constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;

    address internal constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;

    ///
    /// @dev Reference to Curve meta registry. Used for abstracting
    /// operations on pools with different interfaces
    ///
    ICurveMetaRegistry internal constant Curve_ICurveMetaRegistry =
        ICurveMetaRegistry(0xF98B45FA17DE75FB1aD0e7aFD971b0ca00e379fC);

    ///
    /// @dev Reference to Convex booster contract. Used when staking,
    /// unstaking Curve LP tokens from Convex pools
    ///
    IBooster internal constant Convex_IBooster =
        IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);

    ///
    /// @dev Reference to Convex library. Used to calculate CVX rewards
    /// based on CRV rewards
    ///
    ICvxMining internal constant Convex_ICvxMining =
        ICvxMining(0x3c75BFe6FbfDa3A94E7E7E8c2216AFc684dE5343);

    ///
    /// @dev Reference to Curve address provider which is used to get
    /// various Curve contracts consistently, specifically meta exchange
    ///
    IAddressProvider internal constant Curve_IAddressProvider =
        IAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);

    ///
    /// @dev Reference to Curve APR contract used to calculate CRV and CVX
    /// APR rates
    ///
    IApr internal constant Convex_IApr =
        IApr(0x5Fba69a794F395184b5760DAf1134028608e5Cd1);
}


// File: contracts/strategies/CurveConvex/errors.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

error FijaInvalidPoolCategory();
error FijaEthInputDisbalance();
error FijaEthInputNotFound();
error FijaUnknownPoolForCoins();
error FijaPoolRatingInvalid();
error FijaConvexPoolUnknown();
error FijaCoinIndexNotFound();


// File: contracts/strategies/CurveConvex/ICurveConvexPeriphery.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

interface ICurveConvexPeriphery {
    ///
    /// @dev calculates amount of LP token to receive from the pool based on deposit amount
    /// @param pool address providing LP tokens
    /// @param depositAmount amount of deposit tokens to provide to pool. Amount is always in deposit tokens.
    /// @param isDeposit flag to check is the operation for removing or adding the liquidity
    /// @return amount of LP tokens to receive
    ///
    function calcTokenAmount(
        address pool,
        uint256 depositAmount,
        bool isDeposit
    ) external view returns (uint256);

    ///
    /// @dev calculates amount of token on index i inside the pool to receive when burning LP tokens
    /// @param pool address LP token's pool
    /// @param burnAmount amount of LP tokens to burn
    /// @param i token index in the pool
    /// @return amount of token to receive
    ///
    function calcWithdrawOneCoin(
        address pool,
        uint256 burnAmount,
        int128 i
    ) external view returns (uint256);

    ///
    /// @dev calculates amount to receive when swapping "from" "to"
    /// @param pool address of swap pool
    /// @param from token address exchanging "from"
    /// @param to token address exchanging "to"
    /// @param input amount of "from" token to exchange
    /// @return amount of "to" token to receive after exchange
    ///
    function getExchangeAmount(
        address pool,
        address from,
        address to,
        uint256 input
    ) external view returns (uint256);

    ///
    /// @dev Calculates pool exposure in deposit tokens, used as a part of rebalancing process
    /// @param targetExposure target exposure in deposit tokens
    /// @return array of pool exposure difference between current and target exposure in deposit tokens
    /// @return pool allocation in bps
    ///
    function exposureDiff(
        uint256 targetExposure
    ) external view returns (int256[8] memory, uint256[] memory);

    ///
    /// @dev Calculates exchange from CRV and CVX amount to deposit tokens amount
    /// @param inputs array [CRV amount, CVX amount]
    /// @return array [CRV in deposit token amount, CVX in deposit token amount]
    /// @return array which stores results of each exchange hop from CRV to target deposit token
    /// @return array which stores results of each exchange hop from CVX to target deposit token
    ///
    function crvCvxToDepositCcy(
        uint256[2] memory inputs
    )
        external
        view
        returns (uint256[2] memory, uint256[] memory, uint256[] memory);

    ///
    /// @dev Used as supporting method to main strategy contract totalAssets()
    /// Includes all assets under strategy management, includes amount deployed in staked LP tokens,
    /// emergency mode assets and to be deployed assets
    /// @return total amount of assets in deposit tokens
    ///
    function totalAssets() external view returns (uint256);

    ///
    /// @dev Used as supporting method to main strategy contract needEmergencyMode().
    /// Checks if there is a need for emergency mode, verifies depeg and low-liquidity conditions
    /// @return flag indicating if there is need to go into emergency mode
    ///
    function needEmergencyMode() external view returns (bool);

    ///
    /// @dev Used as supporting method to main strategy contract status()
    /// checks strategy status
    /// @return string with strategy metadata
    ///
    function status() external view returns (string memory);
}

