{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address =\u003e uint256) internal _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) external view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) external virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount \u003c= accountBalance \u003c= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"QANX.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./ERC20.sol\";\n///////////////////////////////////////////////\n// QANX STARTS HERE, OPENZEPPELIN CODE ABOVE //\n///////////////////////////////////////////////\n\ncontract QANX is ERC20 {\n\n    /// @notice Represents a lock which might be applied on an address\n    /// @dev Lock logic is described in the _applyLock() method\n    struct Lock {\n        uint256 tokenAmount;    /// How many tokens are locked\n        uint256 unlockPerSec;   /// How many tokens are unlockable each sec from hl -\u003e sl\n        uint64 hardLockUntil;   /// Until when no locked tokens can be accessed\n        uint64 softLockUntil;   /// Until when locked tokens can be gradually released\n        uint64 lastUnlock;      /// Last gradual unlock time (softlock period)\n        uint64 allowedHops;     /// How many transfers left with same lock params\n    }\n\n    /// @notice Cheque signer address\n    /// @dev This is compared against a recovered secp256k1 signature\n    address private chequeSigner;\n\n    /// @notice This maps used cheques so they can not be encashed twice\n    /// @dev Ensures that every unique cheque paramset can be encashed once\n    mapping (bytes32 =\u003e bool) private chequesEncashed;\n\n    /// @notice This maps lock params to certain addresses which received locked tokens\n    /// @dev Lookup table for locks assigned to specific addresses\n    mapping (address =\u003e Lock) private _locks;    \n\n    /// @notice Emitted when a lock is applied on an account\n    /// @dev The first param is indexed which makes it easy to listen to locks applied to a specific account\n    event LockApplied(address indexed account, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops);\n\n    /// @notice Emitted when a lock is removed from an account\n    /// @dev The account param is indexed which makes it easy to listen to locks getting removed from a specific account\n    event LockRemoved(address indexed account);\n\n    /// @notice Emitted when a lock amount is decreased on an account\n    /// @dev The first param is indexed which makes it easy to listen to locked amount getting decreased on a specific account\n    event LockDecreased(address indexed account, uint256 amount);\n\n    /// @notice Emitted when a the permitted cheque signer address is changed\n    /// @dev This will be new address the ecrecover result is compared against\n    event ChequeSignerUpdated(address signer);\n\n    /// @notice Initialize an erc20 token based on the openzeppelin version\n    /// @dev Sets the initial cheque signer to the deployer address and mints total supply to the contract itself\n    constructor() ERC20(\"QANX Token\", \"QANX\") {\n\n        // Assign deployer as cheque signer initially\n        chequeSigner = msg.sender;\n\n        // Initially mint total supply to contract itself\n        _mint(address(this), 3_333_333_000 * 1e18);\n    }\n\n    /// @notice Refuse any kind of payment to the contract\n    /// @dev This is the implicit default behavior, it just exists for verbosity\n    receive() external payable {\n        revert();\n    }\n\n    /// @notice Refuse any kind of payment to the contract\n    /// @dev This is the implicit default behavior, it just exists for verbosity\n    fallback() external payable {\n        revert();\n    }\n\n    /// @notice Ability to update cheque signer\n    /// @dev Make sure to externally double check the new cheque signer address!\n    /// @param _newChequeSigner The address which new cheque signatures will be compared against from now\n    function setChequeSigner(address _newChequeSigner) external {\n        require(msg.sender == chequeSigner \u0026\u0026 _newChequeSigner != address(0), \"Invalid cheque signer\");\n        chequeSigner = _newChequeSigner;\n        emit ChequeSignerUpdated(chequeSigner);\n    }\n\n    /// @notice Method to encash a received cheque\n    /// @dev Ability to encash offline signed cheques using on-chain signature verification.\n    /// Please note that cheques are expected to be one cheque per address, so using CID as\n    /// a nonce is intentional and works as designed.\n    /// @param beneficiary The address which will receive the tokens\n    /// @param amount The amount of tokens the beneficiary will receive\n    /// @param hardLockUntil The UNIX timestamp until which the tokens are not transferable\n    /// @param softLockUntil The UNIX timestamp until which the tokens are gradually unlockable\n    /// @param allowedHops How many times the locked tokens can be transferred further\n    /// @param signature The secp256k1 signature of CID as per EIP-2098 (r + _vs)\n    function encashCheque(address beneficiary, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops, bytes32[2] calldata signature) external {\n\n        // Calculate cheque id\n        bytes32 cid = keccak256(abi.encode(block.chainid, address(this), beneficiary, amount, hardLockUntil, softLockUntil, allowedHops));\n\n        // Verify cheque signature\n        require(verifyChequeSignature(cid, signature), \"Cheque signature is invalid!\");\n\n        // Make sure this cheque was not encashed before\n        require(!chequesEncashed[cid], \"This cheque was encashed already!\");\n\n        // Mark cheque as encashed\n        chequesEncashed[cid] = true;\n        \n        // If any lock related params were defined as non-zero\n        if (hardLockUntil \u003e 0) {\n\n            // Encash through a locked transfer\n            _transferLocked(address(this), beneficiary, amount, hardLockUntil, softLockUntil, allowedHops);\n            return;\n        }\n\n        // Otherwise encash using a normal transfer\n        _transfer(address(this), beneficiary, amount);\n    }\n\n    /// @notice Transfer function with lock parameters\n    /// @dev Wraps the _transferLocked internal method\n    /// @param recipient The address whose locked balance will be credited\n    /// @param amount The amount which will be credited to the recipient address\n    /// @param hardLockUntil The UNIX timestamp until which the tokens are not transferable\n    /// @param softLockUntil The UNIX timestamp until which the tokens are gradually unlockable\n    /// @param allowedHops How many times the locked tokens can be transferred further\n    /// @return Success\n    function transferLocked(address recipient, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops) external returns (bool) {\n        _transferLocked(_msgSender(), recipient, amount, hardLockUntil, softLockUntil, allowedHops);\n        return true;\n    }\n\n    /// @notice Transferfrom function with lock parameters\n    /// @dev Wraps the _transferLocked internal method\n    /// @param sender The address whose balance will be debited\n    /// @param recipient The address whose locked balance will be credited\n    /// @param amount The amount which will be credited to the recipient address\n    /// @param hardLockUntil The UNIX timestamp until which the tokens are not transferable\n    /// @param softLockUntil The UNIX timestamp until which the tokens are gradually unlockable\n    /// @param allowedHops How many times the locked tokens can be transferred further\n    /// @return Success\n    function transferFromLocked(address sender, address recipient, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops) external returns (bool) {\n\n        // Query current allowance of spender\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n\n        // If the allowance is not unlimited\n        if (currentAllowance != type(uint256).max) {\n\n            // Ensure sufficient allowance and decrease it by current amount\n            require(currentAllowance \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            }\n        }\n\n        // Perform locked transfer\n        _transferLocked(sender, recipient, amount, hardLockUntil, softLockUntil, allowedHops);\n        return true;\n    }\n\n    /// @notice Unlocks all unlockable tokens of a particular account\n    /// @dev Calculates the unlockable amount based on the private _locks mapping\n    /// @param account The address whose tokens should be unlocked\n    /// @return Success\n    function unlock(address account) external returns (bool) {\n\n        // Lookup lock\n        Lock storage lock = _locks[account];\n\n        // Calculate unlockable balance\n        uint256 unlockable = unlockableBalanceOf(account);\n\n        // Only addresses owning locked tokens and bypassed hardlock time are unlockable\n        require(unlockable \u003e 0 \u0026\u0026 lock.tokenAmount \u003e 0, \"No unlockable tokens!\");\n\n        // Set last unlock time, deduct from locked balance \u0026 credit to regular balance\n        lock.lastUnlock = uint64(block.timestamp);\n        lock.tokenAmount = lock.tokenAmount - unlockable;\n        _balances[account] += unlockable;\n\n        // If no more locked tokens left, remove lock object from address\n        if(lock.tokenAmount == 0){\n            delete _locks[account];\n            emit LockRemoved(account);\n        }\n\n        // Unlock successful\n        emit LockDecreased(account, unlockable);\n        return true;\n    }\n\n    /// @notice Returns the locked token balance of a particular account\n    /// @dev Reads the private _locks mapping to return data\n    /// @param account The address whose locked balance should be read\n    /// @return The number of locked tokens owned by the account\n    function lockedBalanceOf(address account) external view returns (uint256) {\n        return _locks[account].tokenAmount;\n    }\n\n    /// @notice Returns the unlocked token balance of a particular account\n    /// @dev Reads the internal _balances mapping to return data\n    /// @param account The address whose unlocked balance should be read\n    /// @return The number of unlocked tokens owned by the account\n    function unlockedBalanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @notice Returns lock information of a given address\n    /// @dev Reads a whole entry of the private _locks mapping to return data\n    /// @param account The address whose lock object should be read\n    /// @return The lock object of the particular account\n    function lockOf(address account) external view returns (Lock memory) {\n        return _locks[account];\n    }\n\n    /// @notice Return the balance of unlocked and locked tokens combined\n    /// @dev This overrides the OZ version for combined output\n    /// @param account The address whose total balance is looked up\n    /// @return The combined (unlocked + locked) balance of the particular account\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account] + _locks[account].tokenAmount;\n    }\n\n    /// @notice Calculates the number of unlockable tokens of a particular account\n    /// @dev Dynamically calculates unlockable balance based on current block timestamp\n    /// @param account The address whose unlockable balance is calculated\n    /// @return The amount of tokens which can be unlocked at the current block timestamp\n    function unlockableBalanceOf(address account) public view returns (uint256) {\n\n        // Lookup lock\n        Lock memory lock = _locks[account];\n\n        // If the hardlock has not passed yet, there are no unlockable tokens\n        if(block.timestamp \u003c lock.hardLockUntil) {\n            return 0;\n        }\n\n        // If the softlock period passed, all currently tokens are unlockable\n        if(block.timestamp \u003e lock.softLockUntil) {\n            return lock.tokenAmount;\n        }\n\n        // Otherwise the proportional amount is unlockable\n        uint256 unlockable = (block.timestamp - lock.lastUnlock) * lock.unlockPerSec;\n        return lock.tokenAmount \u003c unlockable ? lock.tokenAmount : unlockable;\n    }\n\n    /// @dev Abstract method to execute locked transfers\n    /// @param sender The address whose balance will be debited\n    /// @param recipient The address whose locked balance will be credited\n    /// @param amount The amount which will be credited to the recipient address\n    /// @param hardLockUntil The UNIX timestamp until which the tokens are not transferable\n    /// @param softLockUntil The UNIX timestamp until which the tokens are gradually unlockable\n    /// @param allowedHops How many times the locked tokens can be transferred further\n    /// @return Success\n    function _transferLocked(address sender, address recipient, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops) internal returns (bool) {\n\n        // Perform zero address validation\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        // Lookup sender balance\n        uint256 sBalance = _balances[sender];\n\n        // Lookup lock of sender and recipient\n        Lock storage rLock = _locks[recipient];\n        Lock storage sLock = _locks[sender];\n\n        // Only a single set of lock parameters allowed per recipient\n        if (rLock.tokenAmount \u003e 0){\n            require(\n                hardLockUntil == rLock.hardLockUntil \u0026\u0026\n                softLockUntil == rLock.softLockUntil \u0026\u0026\n                allowedHops == rLock.allowedHops\n            , \"Only one lock params per address allowed!\");\n        }\n\n        // Sender must have enough tokens (unlocked + locked balance combined)\n        require(sBalance + sLock.tokenAmount \u003e= amount, \"Transfer amount exceeds balance\");\n\n        // If sender has enough unlocked balance, then lock params can be chosen\n        if(sBalance \u003e= amount){\n\n            // Deduct sender balance\n            unchecked {\n                _balances[sender] = sBalance - amount;\n            }\n\n            // Apply lock\n            return _applyLock(sender, recipient, amount, hardLockUntil, softLockUntil, allowedHops);\n        }\n\n        // Otherwise require that the chosen lock params are same / stricter (allowedhops) than the sender\u0027s\n        require(\n            hardLockUntil \u003e= sLock.hardLockUntil \u0026\u0026 \n            softLockUntil \u003e= sLock.softLockUntil \u0026\u0026 \n            allowedHops \u003c sLock.allowedHops\n            , \"Only same / stricter lock params allowed!\"\n        );\n\n        // If sender has enough locked balance\n        if(sLock.tokenAmount \u003e= amount){\n\n            // Decrease locked balance of sender\n            unchecked {\n                sLock.tokenAmount = sLock.tokenAmount - amount;\n            }\n\n            // Apply lock\n            return _applyLock(sender, recipient, amount, hardLockUntil, softLockUntil, allowedHops);\n        }\n\n        // If no conditions were met so far, deduct from the unlocked balance\n        unchecked {\n            _balances[sender] = sBalance - (amount - sLock.tokenAmount);\n        }\n\n        // Then spend locked balance of sender first\n        sLock.tokenAmount = 0;\n\n        // Apply lock\n        return _applyLock(sender, recipient, amount, hardLockUntil, softLockUntil, allowedHops);\n    }\n\n    /// @notice Applies lock to recipient with specified params and emits a transfer event\n    /// @param sender The address whose balance will be debited\n    /// @param recipient The address whose locked balance will be credited\n    /// @param amount The amount which will be credited to the recipient address\n    /// @param hardLockUntil The UNIX timestamp until which the tokens are not transferable\n    /// @param softLockUntil The UNIX timestamp until which the tokens are gradually unlockable\n    /// @param allowedHops How many times the locked tokens can be transferred further\n    /// @return Success\n    function _applyLock(address sender, address recipient, uint256 amount, uint64 hardLockUntil, uint64 softLockUntil, uint64 allowedHops) private returns (bool) {\n\n        // Make sure that softlock is not before hardlock\n        require(softLockUntil \u003e= hardLockUntil, \"SoftLock must be \u003e= HardLock!\");\n\n        // Make sure that hardlock is in the future\n        require(hardLockUntil \u003e= block.timestamp, \"HardLock must be in the future!\");\n\n        // Make sure that the amount is increased if a lock already exists\n        uint256 totalAmount;\n        uint256 lockSeconds;\n        uint256 unlockPerSec;\n        unchecked {\n            totalAmount = _locks[recipient].tokenAmount + amount;\n            lockSeconds = softLockUntil - hardLockUntil;\n            unlockPerSec = lockSeconds \u003e 0 ? totalAmount / lockSeconds : 0;\n        }\n\n        // Apply lock, emit transfer event\n        _locks[recipient] = Lock({\n            tokenAmount: totalAmount,\n            unlockPerSec: unlockPerSec,\n            hardLockUntil: hardLockUntil,\n            softLockUntil: softLockUntil,\n            lastUnlock: hardLockUntil,\n            allowedHops: allowedHops\n        });\n        emit LockApplied(recipient, totalAmount, hardLockUntil, softLockUntil, allowedHops);\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    /// @notice Method to verify cheque signature\n    /// @dev This verifies a compact secp256k1 signature as per EIP-2098\n    /// @param cid The Cheque ID which is calculated deterministically based on cheque params\n    /// @param signature The EIP-2098 signature which was created offline by the permitted chequeSigner\n    /// @return Whether the recovered signer address matches the permitted chequeSigner\n    function verifyChequeSignature(bytes32 cid, bytes32[2] memory signature) private view returns (bool) {\n\n        // Determine s and v from vs (signature[1])\n        bytes32 s = signature[1] \u0026 bytes32(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        uint8 v = uint8((uint256(signature[1]) \u003e\u003e 255) + 27);\n\n        // Ensure valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return false;\n        }\n\n        // Recover \u0026 verify signer identity related to amount\n        return ecrecover(cid, v, signature[0], s) == chequeSigner;\n    }\n}\n"}}