{"Address.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nlibrary Address {\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\t\t// for accounts without code, i.e. `keccak256(\u0027\u0027)`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly { codehash := extcodehash(account) }\n\t\treturn (codehash != accountHash \u0026\u0026 codehash != 0x0);\n\t}\n\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n \n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n\t}\n\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length \u003e 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n"},"Context.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - issue 2691\n\t\treturn msg.data;\n\t}\n}\n"},"Discreet.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {Address} from \"./Address.sol\";\nimport {Context} from \"./Context.sol\";\nimport {Ownable} from \"./Ownable.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract Discreet is Context, IERC20, Ownable {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\n\tmapping (address =\u003e uint256) private _balances;\n\tmapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n\tmapping (address =\u003e bool) private _functionWhitelist;\n\tmapping (address =\u003e bool) private _transferWhitelist;\n\n\taddress public devlock;\n\tuint256 public _devlockdate;\n\t\n\tuint256 private _total = 90 * 10**6 * 10**18; // 90 million\n\n\tstring private _name = \"Discreet\";\n\tstring private _symbol = \"EDIS\";\n\tuint8 private _decimals = 18;\n\n\tuint256 public preseedTokenSupply = 20 * 10**6 * 10**18;\n\tuint256 public seedTokenSupply = 20 * 10**6 * 10**18;\n\tuint256 public publicTokenSupply = 30 * 10**6 * 10**18;\n\tuint256 public teamTokenSupply = 5 * 10**6 * 10**18;\n\tuint256 public projectTokenSupply = 10 * 10**6 * 10**18;\n\tuint256 public lockedTokenSupply = 5 * 10**6 * 10**18;\n\n\tbool public _seedTokensReleased = false;\n\tbool public _publicTokensReleased = false;\n\tbool public _lockedTokensReleased = false;\n\tbool public _preseedTokensReleased = false;\n\n\taddress public _preseedContract;\t// pressed round contract; facilitate purchases\n\taddress public _seedContract;\n\taddress public _publicContract;\t\t// public round contract\n\n\tuint256 public _maxTxAmount = 10**6 * 10**18;\n\n\tmodifier onlyWhitelist() {\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\n\t\t_;\n\t}\n\n\tevent Airdrop(address indexed from, uint256 numReceived, uint256 numTokens);\n\n\tconstructor (address _DEVLOCK_, address _TEAM_) public {\n\t\trequire (teamTokenSupply.add(projectTokenSupply.add(lockedTokenSupply.add(preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply))))) == _total, \"Total tokens doesn\u0027t match!\");\n\t\t_balances[_DEVLOCK_] = lockedTokenSupply;\n\t\t_balances[_TEAM_] = teamTokenSupply.add(projectTokenSupply);\n\t\t_balances[address(this)] = preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply));\n\n\t\tdevlock = _DEVLOCK_;\n\t\t_transferWhitelist[_msgSender()] = true;\n\t\t_functionWhitelist[_msgSender()] = true;\n\n\t\temit Transfer(address(0), address(this), _balances[address(this)]);\n\t\temit Transfer(address(0), _DEVLOCK_, lockedTokenSupply);\n\t\temit Transfer(address(0), _TEAM_, teamTokenSupply.add(projectTokenSupply));\n\n\t\t_devlockdate = now + 267 days;\n\t}\n\n\tfunction seedTokensReleased() public view returns (bool) {\n\t\treturn _seedTokensReleased;\n\t}\n\n\tfunction publicTokensReleased() public view returns (bool) {\n\t\treturn _publicTokensReleased;\n\t}\n\n\tfunction lockedTokensReleased() public view returns (bool) {\n\t\treturn _lockedTokensReleased;\n\t}\n\n\tfunction preseedTokensReleased() public view returns (bool) {\n\t\treturn _preseedTokensReleased;\n\t}\n\n\tfunction getPreseedTokenSupply() public view returns (uint256) {\n\t\treturn preseedTokenSupply;\n\t}\n\n\tfunction getSeedTokenSupply() public view returns (uint256) {\n\t\treturn seedTokenSupply;\n\t}\n\n\tfunction getPublicTokenSupply() public view returns (uint256) {\n\t\treturn publicTokenSupply;\n\t}\n\n\tfunction name() public view returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n \n    function totalSupply() public view override returns (uint256) {\n        return _total;\n    }\n \n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n \n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n \n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n\tfunction _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n \n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\tfunction addTransferWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_transferWhitelist[addressToWhitelist] = true;\n\t}\n\n\tfunction removeTransferWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_transferWhitelist[addressToWhitelist] = false;\n\t}\n\n\tfunction isTransferWhitelisted(address addr) public view returns (bool) {\n\t\treturn _transferWhitelist[addr];\n\t}\n\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_functionWhitelist[addressToWhitelist] = true;\n\t}\n\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_functionWhitelist[addressToWhitelist] = false;\n\t}\n\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\n\t\treturn _functionWhitelist[addr];\n\t}\n \n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        if(from != owner() \u0026\u0026 to != owner() \u0026\u0026 from != address(this) \u0026\u0026 !_transferWhitelist[from])\n            require(amount \u003c= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n \n        if(from == devlock) \n            require(now \u003e= _devlockdate \u0026\u0026 _lockedTokensReleased, \"This wallet has not been unlocked.\");\n        \n\t      _balances[from] = _balances[from].sub(amount);\n\t      _balances[to] = _balances[to].add(amount);\n \n\t      emit Transfer(from, to, amount);\n    }\n \n    function launchPreseed(address preseedContract) public onlyOwner() {\n\t\trequire(_preseedTokensReleased == false, \"Preseed already launched\");\n\t\t_preseedContract = preseedContract;\n\t\t_preseedTokensReleased = true;\n\t\t_transferWhitelist[preseedContract] = true;\n\t\t_transfer(address(this), _preseedContract, preseedTokenSupply);\n\t}\n\n\tfunction launchSeed(address seedContract) public onlyOwner() {\n\t\trequire(_seedTokensReleased == false, \"Seed already launched\");\n\t\t_seedContract = seedContract;\n\t\t_seedTokensReleased = true;\n\t\t_transferWhitelist[seedContract] = true;\n\t\t_transfer(address(this), _seedContract, seedTokenSupply);\n\t}\n\n\tfunction launchPublic(address publicContract) public onlyOwner() {\n\t\trequire(_publicTokensReleased == false, \"Public already launched\");\n\t\t_publicContract = publicContract;\n\t\t_publicTokensReleased = true;\n\t\t_transferWhitelist[publicContract] = true;\n\t\t_transfer(address(this), _publicContract, publicTokenSupply);\n\t}\n\n\tfunction airdropTokens(address[] memory addresses, uint256 tokenLimit) public onlyWhitelist() {\n\t\trequire(_balances[_msgSender()] \u003e= tokenLimit, \"not enough allocated tokens for airdrop\");\n\t\tuint256 accumulator;\n\t\tfor (uint256 i = 0; i \u003c addresses.length; i++) {\n\t\t\taccumulator = accumulator.add(_balances[addresses[i]]);\n\t\t}\n\n\t\tuint256 tokensLeft = tokenLimit;\n\t\tfor (uint256 i = 0; i \u003c addresses.length; i++) {\n\t\t\tuint256 rcvamt = _balances[addresses[i]].mul(tokenLimit).div(accumulator);\n\t\t\tif (rcvamt \u003e tokensLeft) {\n\t\t\t\trcvamt = tokensLeft;\n\t\t\t}\n\t\t\t\n\t\t\tif (rcvamt == 0) continue;\n\n\t\t\ttransfer(addresses[i], rcvamt);\n\t\t\ttokensLeft = tokensLeft.sub(rcvamt);\n\t\t}\n\n\t\temit Airdrop(_msgSender(), addresses.length, tokenLimit.sub(tokensLeft));\n\t}\n\n\tfunction addToPublic(uint256 numTokens) public onlyWhitelist() {\n\t\trequire(_balances[_msgSender()] \u003e= numTokens, \"insufficient balance\");\n\t\trequire(_publicTokensReleased == false, \"public round has not began\");\n\n\t\ttransfer(address(this), numTokens);\n\t\tpublicTokenSupply = publicTokenSupply.add(numTokens);\n\t}\n\n\tfunction drainTokens() public onlyOwner() {\n\t\t// to prevent any possible issues with token locks\n\t\tif (_balances[address(this)] \u003e 0) {\n\t\t\ttransfer(address(this), _balances[address(this)]);\n\t\t}\n\t\t// just in case there are tokens in this contract\n\t\tif (address(this).balance \u003e 0) {\n\t\t\tpayable(owner()).transfer(address(this).balance);\n\t\t}\n\t}\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\ninterface IERC20 {\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nimport {Context} from \"./Context.sol\";\n\ncontract Ownable is Context {\n\taddress private _owner;\n\taddress private _previousOwner;\n\taddress private _lockTime;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tconstructor () internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nlibrary SafeMath {\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c \u003e= a, \"SafeMath: addition overflow\");\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003c= a, \"SafeMath: subtraction overflow\");\n\t\tuint256 c = a - b;\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n \n        return c;\n    }\n\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, \"SafeMath: division by zero\");\n\t\tuint256 c = a / b;\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n \n        return c;\n    }\n\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, \"SafeMath: modulo by zero\");\n\t\tuint256 c = a % b;\n\t\treturn c;\n\t}\n}"}}