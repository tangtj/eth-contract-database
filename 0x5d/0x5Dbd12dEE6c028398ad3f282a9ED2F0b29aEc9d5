{"ClaimerContract.sol":{"content":"// SPDX-License-Identifier: --WISE--\n\npragma solidity =0.8.18;\n\nimport \"./ClaimerHelper.sol\";\n\ncontract ClaimerContract is ClaimerHelper {\n\n    address public immutable collector;\n    uint256 public immutable createTime;\n    uint256 public immutable minimumTime;\n\n    struct KeeperInfo {\n        uint256 keeperRate;\n        uint256 keeperTill;\n        uint256 keeperInstant;\n        uint256 keeperPayouts;\n    }\n\n    mapping(address =\u003e KeeperInfo) public keeperList;\n\n    modifier onlyCollector() {\n        require(\n            msg.sender == collector,\n            \"ClaimerContract: INVALID_COLLECTOR\"\n        );\n        _;\n    }\n\n    constructor(\n        address _collector,\n        uint256 _timeFrame,\n        address _tokenAddress\n    )\n        ClaimerHelper(\n            _tokenAddress\n        )\n    {\n        if (_timeFrame == 0) {\n            revert(\"ClaimerContract: INVALID_TIMEFRAME\");\n        }\n\n        collector = _collector;\n        createTime = getNow();\n        minimumTime = _timeFrame;\n    }\n\n    function enrollAndScrape(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        external\n        onlyCollector\n    {\n        _enrollRecipient(\n            _recipient,\n            _tokensLocked,\n            _tokensOpened,\n            _timeFrame\n        );\n\n        _scrapeTokens(\n            _recipient\n        );\n    }\n\n    function _enrollRecipient(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        private\n    {\n        require(\n            keeperList[_recipient].keeperTill == 0,\n            \"ClaimerContract: RECIPIENT_ALREADY_ENROLLED\"\n        );\n\n        _allocateTokens(\n            _recipient,\n            _tokensLocked,\n            _tokensOpened,\n            _timeFrame\n        );\n    }\n\n    function _allocateTokens(\n        address _recipient,\n        uint256 _tokensLocked,\n        uint256 _tokensOpened,\n        uint256 _timeFrame\n    )\n        private\n    {\n        require(\n            _timeFrame \u003e= minimumTime,\n            \"ClaimerContract: INVALID_TIME_FRAME\"\n        );\n\n        totalRequired = totalRequired\n            + _tokensOpened\n            + _tokensLocked;\n\n        keeperList[_recipient].keeperTill = createTime\n            + _timeFrame;\n\n        keeperList[_recipient].keeperRate = _tokensLocked\n            / _timeFrame;\n\n        keeperList[_recipient].keeperInstant = _tokensLocked\n            % _timeFrame\n            + _tokensOpened;\n\n        _checkBalance(\n            totalRequired\n        );\n\n        emit recipientEnrolled(\n            _recipient,\n            _timeFrame,\n            _tokensLocked,\n            _tokensOpened\n        );\n    }\n\n    function scrapeMyTokens()\n        external\n    {\n        _scrapeTokens(\n            msg.sender\n        );\n    }\n\n    function _scrapeTokens(\n        address _recipient\n    )\n        private\n    {\n        uint256 scrapeAmount = availableBalance(\n            _recipient\n        );\n\n        keeperList[_recipient].keeperPayouts += scrapeAmount;\n\n        _safeScrape(\n            _recipient,\n            scrapeAmount\n        );\n\n        emit tokensScraped(\n            _recipient,\n            scrapeAmount,\n            getNow()\n        );\n    }\n\n    function availableBalance(\n        address _recipient\n    )\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256 timeNow = getNow();\n        uint256 timeMax = keeperList[_recipient].keeperTill;\n\n        if (timeMax == 0) return 0;\n\n        uint256 timePassed = timeNow \u003e timeMax\n            ? timeMax - createTime\n            : timeNow - createTime;\n\n        balance = keeperList[_recipient].keeperRate\n            * timePassed\n            + keeperList[_recipient].keeperInstant\n            - keeperList[_recipient].keeperPayouts;\n    }\n\n    function lockedBalance(\n        address _recipient\n    )\n        external\n        view\n        returns (uint256 balance)\n    {\n        uint256 timeNow = getNow();\n\n        uint256 timeRemaining =\n            keeperList[_recipient].keeperTill \u003e timeNow ?\n            keeperList[_recipient].keeperTill - timeNow : 0;\n\n        balance = keeperList[_recipient].keeperRate\n            * timeRemaining;\n    }\n}\n"},"ClaimerHelper.sol":{"content":"// SPDX-License-Identifier: --BCOM--\n\npragma solidity =0.8.18;\n\ncontract ClaimerHelper {\n\n    uint256 public totalRequired;\n    address public immutable wiserToken;\n\n    event recipientEnrolled(\n        address indexed recipient,\n        uint256 timeFrame,\n        uint256 tokensLocked,\n        uint256 tokensOpened\n    );\n\n    event tokensScraped(\n        address indexed scraper,\n        uint256 scrapedAmount,\n        uint256 timestamp\n    );\n\n    constructor(\n        address _wiserTokenAddress\n    ) {\n        if (_wiserTokenAddress == address(0x0)) {\n            revert(\"ClaimerHelper: INVALID_TOKEN\");\n        }\n\n        wiserToken = _wiserTokenAddress;\n    }\n\n    bytes4 private constant TRANSFER = bytes4(\n        keccak256(\n            bytes(\n                \"transfer(address,uint256)\"\n            )\n        )\n    );\n\n    bytes4 private constant BALANCEOF = bytes4(\n        keccak256(\n            bytes(\n                \"balanceOf(address)\"\n            )\n        )\n    );\n\n    function _safeScrape(\n        address _to,\n        uint256 _scrapeAmount\n    )\n        internal\n    {\n        totalRequired -= _scrapeAmount;\n\n        (bool success, bytes memory data) = wiserToken.call(\n            abi.encodeWithSelector(\n                TRANSFER,\n                _to,\n                _scrapeAmount\n            )\n        );\n\n        require(\n            success \u0026\u0026 (\n                abi.decode(\n                    data, (bool)\n                )\n            ),\n            \"ClaimerHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function _checkBalance(\n        uint256 _required\n    )\n        internal\n    {\n        (bool success, bytes memory data) = wiserToken.call(\n            abi.encodeWithSelector(\n                BALANCEOF,\n                address(this)\n            )\n        );\n\n        require(\n            success \u0026\u0026 abi.decode(\n                data, (uint256)\n            ) \u003e= _required,\n            \"ClaimerHelper: BALANCE_CHECK_FAILED\"\n        );\n    }\n\n    function getNow()\n        public\n        view\n        returns (uint256 time)\n    {\n        time = block.timestamp;\n    }\n}\n"}}