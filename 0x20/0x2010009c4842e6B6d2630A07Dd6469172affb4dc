
// File: src/AdoptAHyphen.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {ERC721, ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";
import {Owned} from "solmate/auth/Owned.sol";
import {IAdoptAHyphen} from "./interfaces/IAdoptAHyphen.sol";
import {IERC721} from "./interfaces/IERC721.sol";
import {AdoptAHyphenArt} from "./utils/AdoptAHyphenArt.sol";
import {AdoptAHyphenMetadata} from "./utils/AdoptAHyphenMetadata.sol";
import {Base64} from "./utils/Base64.sol";

/// @title adopt-a-hyphen
/// @notice Adopt a Hyphen: exchange a Hyphen NFT into this contract to mint a
/// Hyphen Guy.
contract AdoptAHyphen is IAdoptAHyphen, ERC721, ERC721TokenReceiver, Owned {
    // -------------------------------------------------------------------------
    // Constants
    // -------------------------------------------------------------------------

    /// @notice Description of the collection.
    string constant COLLECTION_DESCRIPTION =
        unicode"With each passing day, more and more people are switching from "
        unicode"“on-chain” to “onchain.” While this may seem like a harmless ch"
        unicode"oice, thousands of innocent hyphens are losing their place in t"
        unicode"he world. No longer needed to hold “on-chain” together, these h"
        unicode"yphens are in need of a loving place to call home. What if you "
        unicode"could make a difference in a hyphen’s life forever?\\n\\nIntrod"
        unicode"ucing the Adopt-a-Hyphen program, where you can adopt a hyphen "
        unicode"and give it a new home...right in your wallet! Each hyphen in t"
        unicode"his collection was adopted via an on-chain mint and is now safe"
        unicode" and sound in this collection. As is their nature, each hyphen "
        unicode"lives fully on-chain and is rendered in Solidity as cute, gener"
        unicode"ative ASCII art.";

    // -------------------------------------------------------------------------
    // Immutable storage
    // -------------------------------------------------------------------------

    /// @notice The Hyphen NFT contract that must be transferred into this
    /// contract in order to mint a token.
    IERC721 public immutable override hyphenNft;

    // -------------------------------------------------------------------------
    // Constructor + Mint
    // -------------------------------------------------------------------------

    /// @param _owner Initial owner of the contract.
    constructor(
        address _hyphenNft,
        address _owner
    ) ERC721("Adopt-a-Hyphen", "-") Owned(_owner) {
        hyphenNft = IERC721(_hyphenNft);
    }

    /// @inheritdoc IAdoptAHyphen
    function mint(uint256 _tokenId) external {
        // Transfer the Hyphen NFT into this contract.
        hyphenNft.transferFrom(msg.sender, address(this), _tokenId);

        // Mint token.
        _mint(msg.sender, _tokenId);
    }

    // -------------------------------------------------------------------------
    // ERC721Metadata
    // -------------------------------------------------------------------------

    /// @inheritdoc ERC721
    function tokenURI(
        uint256 _tokenId
    ) public view override returns (string memory) {
        // Revert if the token hasn't been minted.
        if (_ownerOf[_tokenId] == address(0)) revert TokenUnminted();

        // Seed to generate the art and metadata from.
        uint256 seed = uint256(keccak256(abi.encodePacked(_tokenId)));

        // Generate the metadata.
        string memory name = AdoptAHyphenMetadata.generateName(seed);
        string memory attributes = AdoptAHyphenMetadata.generateAttributes(
            seed
        );

        return
            string.concat(
                "data:application/json;base64,",
                Base64.encode(
                    abi.encodePacked(
                        '{"name":"',
                        name,
                        '","description":"',
                        COLLECTION_DESCRIPTION,
                        '","image_data":"data:image/svg+xml;base64,',
                        Base64.encode(
                            abi.encodePacked(AdoptAHyphenArt.render(seed))
                        ),
                        '","attributes":',
                        attributes,
                        "}"
                    )
                )
            );
    }

    // -------------------------------------------------------------------------
    // Contract metadata
    // -------------------------------------------------------------------------

    /// @inheritdoc IAdoptAHyphen
    function contractURI() external pure override returns (string memory) {
        return
            string.concat(
                "data:application/json;base64,",
                Base64.encode(
                    abi.encodePacked(
                        '{"name":"Adopt-a-Hyphen","description":"',
                        COLLECTION_DESCRIPTION,
                        '"}'
                    )
                )
            );
    }
}


// File: lib/solmate/src/tokens/ERC721.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract ERC721 {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 indexed id);

    event Approval(address indexed owner, address indexed spender, uint256 indexed id);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /*//////////////////////////////////////////////////////////////
                         METADATA STORAGE/LOGIC
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    function tokenURI(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                      ERC721 BALANCE/OWNER STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) internal _ownerOf;

    mapping(address => uint256) internal _balanceOf;

    function ownerOf(uint256 id) public view virtual returns (address owner) {
        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
    }

    function balanceOf(address owner) public view virtual returns (uint256) {
        require(owner != address(0), "ZERO_ADDRESS");

        return _balanceOf[owner];
    }

    /*//////////////////////////////////////////////////////////////
                         ERC721 APPROVAL STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => address) public getApproved;

    mapping(address => mapping(address => bool)) public isApprovedForAll;

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    /*//////////////////////////////////////////////////////////////
                              ERC721 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 id) public virtual {
        address owner = _ownerOf[id];

        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");

        getApproved[id] = spender;

        emit Approval(owner, spender, id);
    }

    function setApprovalForAll(address operator, bool approved) public virtual {
        isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        require(from == _ownerOf[id], "WRONG_FROM");

        require(to != address(0), "INVALID_RECIPIENT");

        require(
            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],
            "NOT_AUTHORIZED"
        );

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            _balanceOf[from]--;

            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        transferFrom(from, to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) public virtual {
        transferFrom(from, to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    /*//////////////////////////////////////////////////////////////
                              ERC165 LOGIC
    //////////////////////////////////////////////////////////////*/

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 id) internal virtual {
        require(to != address(0), "INVALID_RECIPIENT");

        require(_ownerOf[id] == address(0), "ALREADY_MINTED");

        // Counter overflow is incredibly unrealistic.
        unchecked {
            _balanceOf[to]++;
        }

        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }

    function _burn(uint256 id) internal virtual {
        address owner = _ownerOf[id];

        require(owner != address(0), "NOT_MINTED");

        // Ownership check above ensures no underflow.
        unchecked {
            _balanceOf[owner]--;
        }

        delete _ownerOf[id];

        delete getApproved[id];

        emit Transfer(owner, address(0), id);
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL SAFE MINT LOGIC
    //////////////////////////////////////////////////////////////*/

    function _safeMint(address to, uint256 id) internal virtual {
        _mint(to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function _safeMint(
        address to,
        uint256 id,
        bytes memory data
    ) internal virtual {
        _mint(to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }
}

/// @notice A generic interface for a contract which properly accepts ERC721 tokens.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract ERC721TokenReceiver {
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external virtual returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}


// File: lib/solmate/src/auth/Owned.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Simple single owner authorization mixin.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)
abstract contract Owned {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event OwnershipTransferred(address indexed user, address indexed newOwner);

    /*//////////////////////////////////////////////////////////////
                            OWNERSHIP STORAGE
    //////////////////////////////////////////////////////////////*/

    address public owner;

    modifier onlyOwner() virtual {
        require(msg.sender == owner, "UNAUTHORIZED");

        _;
    }

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _owner) {
        owner = _owner;

        emit OwnershipTransferred(address(0), _owner);
    }

    /*//////////////////////////////////////////////////////////////
                             OWNERSHIP LOGIC
    //////////////////////////////////////////////////////////////*/

    function transferOwnership(address newOwner) public virtual onlyOwner {
        owner = newOwner;

        emit OwnershipTransferred(msg.sender, newOwner);
    }
}


// File: src/interfaces/IAdoptAHyphen.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IERC721} from "./IERC721.sol";

/// @title The interface for {AdoptAHyphen}
interface IAdoptAHyphen {
    // -------------------------------------------------------------------------
    // Errors
    // -------------------------------------------------------------------------

    /// @notice Emitted when a token hasn't been minted.
    error TokenUnminted();

    // -------------------------------------------------------------------------
    // Immutable storage
    // -------------------------------------------------------------------------

    /// @return The Hyphen NFT contract.
    function hyphenNft() external view returns (IERC721);

    // -------------------------------------------------------------------------
    // Functions
    // -------------------------------------------------------------------------

    /// @notice Mints a token to the sender in exchange for the hyphen NFT (the
    /// NFT gets transferred into this contract, and it can never be transferred
    /// out).
    /// @dev `msg.sender` must have approvals set to `true` on the hyphen NFT
    /// with the operator as this contract's address.
    function mint(uint256 _tokenId) external;

    // -------------------------------------------------------------------------
    // Metadata
    // -------------------------------------------------------------------------

    /// @return The contract URI for this contract.
    function contractURI() external view returns (string memory);
}


// File: src/interfaces/IERC721.sol
// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.17;

interface IERC721 {
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external payable;

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external;

    function ownerOf(uint256 _tokenId) external view returns (address);
}


// File: src/utils/AdoptAHyphenArt.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {LibPRNG} from "solady/utils/LibPRNG.sol";
import {LibString} from "solady/utils/LibString.sol";

/// @title Adopt-a-Hyphen art
/// @notice A library for generating SVGs for {AdoptAHyphen}.
/// @dev For this library to be correct, all `_seed` values must be consistent
/// with every function in both {AdoptAHyphenArt} and {AdoptAHyphenMetadata}.
library AdoptAHyphenArt {
    using LibPRNG for LibPRNG.PRNG;
    using LibString for uint256;

    // -------------------------------------------------------------------------
    // Structs
    // -------------------------------------------------------------------------

    /// @notice The traits that make up a Hyphen Guy.
    /// @param head Head trait, a number in `[0, 3]`. Equal chances.
    /// @param eye Eye trait, a number in `[0, 16]`. Equal chances.
    /// @param hat Hat trait, a number in `[0, 14]`. 25% chance of being `0`,
    /// which indicates no hat trait. Equal chances amongst the other hats.
    /// @param arm Arm trait, a number in `[0, 4]`. Equal chances.
    /// @param body Body trait, a number in `[0, 2]`. Equal chances.
    /// @param chest Chest trait, a number in `[0, 4]`. 50% chance of being `0`,
    /// which indicates no chest trait. Equal chances amongst the other chests.
    /// @param leg Leg trait, a number in `[0, 3]`. Equal chances.
    /// @param background Background trait, a number in `[0, 8]`. Equal chances.
    /// @param chaosBg Whether the background is made up of multiple background
    /// characters, or just 1. 25% chance of being true.
    /// @param intensity Number of positions (out of 253 (`23 * 11`)) to fill
    /// with a background character, a number in `[50, 200]`. 25% chance of
    /// being `252`, which indicates no variable intensity (every empty position
    /// would be filled). Equal chances amongst the other intensities.
    struct HyphenGuy {
        uint8 head;
        uint8 eye;
        uint8 hat;
        uint8 arm;
        uint8 body;
        uint8 chest;
        uint8 leg;
        uint8 background;
        bool chaosBg;
        uint8 intensity;
        bool inverted;
        uint8 color;
    }

    // -------------------------------------------------------------------------
    // Constants
    // -------------------------------------------------------------------------

    /// @notice Starting string for the SVG.
    /// @dev The `line-height` attribute for `pre` elements is set to `51px`
    /// because we want to fit in 11 lines into a `600 - 32 * 2 + 12` = 548px
    /// tall container. At 32px, the Martian Mono Extra Bold font has a width of
    /// 22.4px and a height of 38.5px. Additionally, we want to fit 11 lines
    /// with 23 characters each into a 600px square container with 32px padding
    /// on each side. Martian Mono comes with an overhead of 12px above each
    /// character, and 0px on either side, so effectively, we want to fit in
    /// `22.4px/character * 11 characters` into a `600 - 32 * 2 + 12` = 548px
    /// tall container, and `38.5px/character * 23 characters` into a
    /// `600 - 32 * 2` = 536px wide container. Therefore, we calculate 51px for
    /// the `line-height` property:
    /// `38.5 + (548 - 38.5 * 11) / (11 - 1) = 50.95 ≈ 51`. We round to `51`
    /// because Safari doesn't support decimal values for `line-height`, so
    /// technically, the text is off by `0.05 * 23` = 1.15px. Similarly, we
    /// calculate 0.945 for the `letter-spacing` property:
    /// `(536 - 23 * 22.4) / 22 ≈ 0.945`. We set these properties on the `pre`
    /// element.
    string constant SVG_START =
        '<svg xmlns="http://www.w3.org/2000/svg" width="600" height="600" viewB'
        'ox="0 0 600 600"><style>@font-face{font-family:A;src:url(data:font/wof'
        "f2;utf-8;base64,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)}pre{font-family:A;font-s"
        "ize:32px;text-align:center;margin:0;letter-spacing:0.945px;line-height"
        ":51px}@supports (color:color(display-p3 1 1 1)){.z{color:oklch(79.59% "
        "0.042 250.64)!important}.y{color:oklch(60.59% 0.306 309.33)!important}"
        ".x{color:oklch(69.45% 0.219 157.46)!important}.w{color:oklch(75.22% 0."
        "277 327.48)!important}.v{color:oklch(77.86% 0.16 226.017)!important}.u"
        "{color:oklch(74.3% 0.213 50.613)!important}.t{color:oklch(61.52% 0.224"
        " 256.099)!important}.s{color:oklch(62.61% 0.282 29.234)!important}}</s"
        "tyle><path ";

    /// @notice Ending string for the SVG.
    string constant SVG_END = "</pre></foreignObject></svg>";

    /// @notice Characters corresponding to the `head` trait's left characters.
    bytes32 constant HEADS_LEFT = "|[({";

    /// @notice Characters corresponding to the `head` trait's right characters.
    bytes32 constant HEADS_RIGHT = "|])}";

    /// @notice Characters corresponding to the `eye` trait's characters.
    bytes32 constant EYES = "\"#$'*+-.0=OTX^oxz";

    /// @notice Characters corresponding to the `hat` trait's characters.
    /// @dev An index of 0 corresponds to no hat trait, so the character at
    /// index 0 can be anything, but we just made it a space here.
    /// @dev If the hat character is `&` (i.e. index of `5`), then it must be
    /// drawn in its entity form, i.e. `&amp;`.
    bytes32 constant HATS = " !#$%&'*+-.=@^~";

    /// @notice Characters corresponding to the `arm` trait's left characters.
    /// @dev If the arm character is `<` (i.e. index of `1`), then it must be
    /// drawn in its entity form, i.e. `&lt;`.
    bytes32 constant ARMS_LEFT = "/<~J2";

    /// @notice Characters corresponding to the `arm` trait's right characters.
    /// @dev If the arm character is `>` (i.e. index of `1`), then it must be
    /// drawn in its entity form, i.e. `&gt;`.
    bytes32 constant ARMS_RIGHT = "\\>~L7";

    /// @notice Characters corresponding to the `body` trait's left characters.
    bytes32 constant BODIES_LEFT = "[({";

    /// @notice Characters corresponding to the `body` trait's right characters.
    bytes32 constant BODIES_RIGHT = "])}";

    /// @notice Characters corresponding to the `chest` trait's characters.
    /// @dev An index of 0 corresponds to no chest trait, so the character at
    /// index 0 can be anything, but we just made it a space here.
    bytes32 constant CHESTS = "  :*=.";

    /// @notice Characters corresponding to the `leg` trait's left characters.
    bytes32 constant LEGS_LEFT = "|/|/";

    /// @notice Characters corresponding to the `leg` trait's right characters.
    bytes32 constant LEGS_RIGHT = "||\\\\";

    /// @notice Characters corresponding to the `background` trait's characters.
    /// @dev If the background character is `\` (i.e. index of `6`), then it
    /// must be escaped properly in JSONs, i.e. `\\\\`.
    bytes32 constant BACKGROUNDS = "#*+-/=\\|.";

    /// @notice Characters for the last few characters in the background that
    /// spell out ``CHAIN''.
    /// @dev The character at index 0 can be anything, but we just made it `N`
    /// here.
    bytes32 constant CHAIN_REVERSED = "NIAHC";

    /// @notice Bitpacked integer of 32-bit words containing 24-bit colors.
    /// @dev The first 8 bits in each word are unused, but we made each word
    /// 32-bit so we can calculate the bit index via `<< 5`, rather than `* 24`.
    uint256 constant COLORS =
        0xA9BFD700AD43ED0000BA7300FE63FF0000C9FF00FF8633000080FF00FE0000;

    /// @notice Utility string for converting targetting classes that provide
    /// p3 color support (see classes `s` through `z` in `SVG_START`'s `<style>`
    /// block).
    bytes32 constant COLOR_CLASSES = "stuvwxyz";

    // -------------------------------------------------------------------------
    // `render`
    // -------------------------------------------------------------------------

    /// @notice Renders a Hyphen Guy SVG.
    /// @param _seed Seed to select traits for the Hyphen Guy.
    /// @return SVG string representing the Hyphen Guy.
    function render(uint256 _seed) internal pure returns (string memory) {
        // Initialize PRNG.
        LibPRNG.PRNG memory prng = LibPRNG.PRNG(_seed);

        // The Hyphen Guy.
        HyphenGuy memory hyphenGuy;

        // Select traits from `prng`.
        hyphenGuy.head = uint8(prng.state & 3); // 4 heads (2 bits)
        prng.state >>= 2;
        hyphenGuy.eye = uint8(prng.state % 17); // 17 eyes (5 bits)
        prng.state >>= 5;
        hyphenGuy.hat = uint8( // 25% chance + 14 hats (2 + 4 = 6 bits)
            prng.state & 3 == 0 ? 0 : 1 + ((prng.state >> 2) % 14)
        );
        prng.state >>= 6;
        hyphenGuy.arm = uint8(prng.state % 5); // 5 arms (3 bits)
        prng.state >>= 3;
        hyphenGuy.body = uint8(prng.state % 3); // 3 bodies (2 bits)
        prng.state >>= 2;
        hyphenGuy.chest = uint8(
            prng.state & 1 == 0 ? 0 : 1 + ((prng.state >> 1) % 5)
        ); // 50% chance + 5 chests (1 + 3 = 4 bits)
        prng.state >>= 4;
        hyphenGuy.leg = uint8(prng.state & 3); // 4 legs (2 bits)
        prng.state >>= 2;
        hyphenGuy.background = uint8(prng.state % 9); // 9 backgrounds (4 bits)
        prng.state >>= 4;
        hyphenGuy.chaosBg = prng.state & 3 == 0; // 25% chance (2 bits)
        prng.state >>= 2;
        hyphenGuy.intensity = uint8(
            prng.state & 3 == 0 ? 50 + ((prng.state >> 2) % 151) : 252
        ); // 25% chance + 151 intensities (2 + 8 = 10 bits)
        prng.state >>= 10;
        hyphenGuy.inverted = prng.state & 7 == 0; // 12.5% chance (3 bits)
        prng.state >>= 3;
        hyphenGuy.color = uint8(prng.state & 7); // 8 colors (3 bits)

        // Get the next state in the PRNG.
        prng.state = prng.next();

        // `bitmap` has `0`s where the index corresponds to a Hyphen Guy
        // character, and `1` where not. We use this to determine whether to
        // render a Hyphen Guy character or a background character. i.e. it
        // looks like the following:
        //                        11111111111111111111111
        //                        11111111111111111111111
        //                        11111111111111111111111
        //                        11111111111111111111111
        //                        11111111100000111111111
        //                        11111111100100111111111
        //                        11111111100100111111111
        //                        11111111111111111111111
        //                        11111111111111111111111
        //                        11111111111111111111111
        //                        11111111111111111111111
        // By default, `bitmap` has `1`s set in the positions for hat and chest
        // characters. In the following `assembly` block, we determine whether a
        // hat or chest exists and `XOR` the relevant parts to transform the
        // bitmap.
        uint256 bitmap = 0x1FFFFFFFFFFFFFFFFFFFFFFFFF07FFFE4FFFFC9FFFFFFFFFFFFFFFFFFFFFFFFF;
        uint8 hat = hyphenGuy.hat;
        uint8 chest = hyphenGuy.chest;
        assembly {
            // Equivalent to
            // `bitmap ^= (((hat != 0) << 172) | ((chest != 0) << 126))`. We
            // flip the bit corresponding to the position of the chest if there
            // exists a chest trait because we don't want to draw both a
            // background character and the chest character.
            bitmap := xor(
                bitmap,
                or(shl(172, gt(hat, 0)), shl(126, gt(chest, 0)))
            )
        }

        // Here, we initialize another bitmap to determine whether to render a
        // space character or a background character when we're not observing a
        // `hyphenGuy` character position. Since we want to render as many
        // characters in the background as equals the intensity value, we can:
        //     1. Instantiate a 253-bit long bitmap.
        //     2. Set the first `intensity` bits to `1`, and `0` otherwise.
        //     3. Shuffle the bitmap.
        // Then, by reading the bits at each index, we can determine whether to
        // render a space character (i.e. empty) or a background character. We
        // begin by instantiating an array of 253 `uint256`s, each with a single
        // `1` bit set to make use of `LibPRNG.shuffle`.
        uint256[] memory bgBitmapBits = new uint256[](253);
        for (uint256 i; i <= hyphenGuy.intensity; ) {
            bgBitmapBits[i] = 1;
            unchecked {
                ++i;
            }
        }

        // Shuffle the array if intensity mode.
        if (hyphenGuy.intensity < 252) prng.shuffle(bgBitmapBits);

        uint256 bgBitmap;
        for (uint256 i; i < 253; ) {
            // `intensity >= 252` implies `intenseBg = true`
            bgBitmap <<= 1;
            bgBitmap |= bgBitmapBits[i];
            unchecked {
                ++i;
            }
        }
        prng.state = prng.next();

        uint256 row;
        uint256 col;
        // The string corresponding to the characters of the contents of the
        // background `<text>` element.
        string memory bgStr = "";
        // The string corresponding to the characters of the contents of the
        // Hyphen Guy `<text>` element. We generate the entire first row here.
        string memory charStr = string.concat(
            "  ", // Start with 2 spaces for positioning.
            // If the hat character is `&`, we need to draw it as
            // its entity form.
            hyphenGuy.hat != 5
                ? string(abi.encodePacked(HATS[hyphenGuy.hat]))
                : "&amp;",
            hyphenGuy.hat != 0 ? "" : " ",
            "  \n"
        );
        // Iterate through the positions in reverse order. Note that the last
        // character (i.e. the one that contains ``N'' from ``CHAIN'') is not
        // drawn, and it must be accounted for after the loop.
        for (uint256 i = 252; i != 0; ) {
            assembly {
                row := div(i, 11)
                col := mod(i, 23)
            }

            // Add word characters (i.e. ``ON'' and ``CHAIN'').
            if (i == 252) bgStr = string.concat(bgStr, "O");
            else if (i == 251) bgStr = string.concat(bgStr, "N");
            else if (i < 5) {
                bgStr = string.concat(
                    bgStr,
                    string(abi.encodePacked(CHAIN_REVERSED[i]))
                );
            } else if ((bitmap >> i) & 1 == 0) {
                // Is a Hyphen Guy character.
                // Since there's a Hyphen Guy character that'll be drawn, the
                // background character in the same position must be empty.
                bgStr = string.concat(bgStr, " ");

                // Generate the Hyphen Guy by drawing rows of characters. Note
                // that we've already passed the check for whether a chest
                // character exists and applied it to the bitmap accordingly, so
                // we can safely draw the chest character here--if no chest
                // piece exists, a background character will be drawn anyway
                // because it wouldn't pass the `(bitmap >> i) & 1 == 0` check.
                if (i == 151) {
                    charStr = string.concat(
                        charStr,
                        string(abi.encodePacked(HEADS_LEFT[hyphenGuy.head])),
                        string(abi.encodePacked(EYES[hyphenGuy.eye])),
                        "-",
                        string(abi.encodePacked(EYES[hyphenGuy.eye])),
                        string(abi.encodePacked(HEADS_RIGHT[hyphenGuy.head])),
                        "\n"
                    );
                } else if (i == 128) {
                    charStr = string.concat(
                        charStr,
                        // If the arm character is `<`, we need to draw it as
                        // its entity form.
                        hyphenGuy.arm != 1
                            ? string(abi.encodePacked(ARMS_LEFT[hyphenGuy.arm]))
                            : "&lt;",
                        string(abi.encodePacked(BODIES_LEFT[hyphenGuy.body]))
                    );
                    {
                        charStr = string.concat(
                            charStr,
                            string(abi.encodePacked(CHESTS[hyphenGuy.chest])),
                            string(
                                abi.encodePacked(BODIES_RIGHT[hyphenGuy.body])
                            ),
                            // If the arm character is `>`, we need to draw it
                            // as its entity form.
                            hyphenGuy.arm != 1
                                ? string(
                                    abi.encodePacked(ARMS_RIGHT[hyphenGuy.arm])
                                )
                                : "&gt;",
                            "\n"
                        );
                    }
                } else if (i == 105) {
                    charStr = string.concat(
                        charStr,
                        "_",
                        string(abi.encodePacked(LEGS_LEFT[hyphenGuy.leg])),
                        " ",
                        string(abi.encodePacked(LEGS_RIGHT[hyphenGuy.leg])),
                        "_"
                    );
                }
            } else if ((bgBitmap >> i) & 1 != 0) {
                // We make use of the `bgBitmap` generated earlier from the
                // intensity value here. If the check above passed, it means a
                // background character must be drawn here.
                bgStr = string.concat(
                    bgStr,
                    string(
                        abi.encodePacked(
                            BACKGROUNDS[
                                // Select a random background if `chaosBg` is
                                // true.
                                hyphenGuy.chaosBg
                                    ? prng.state % 9
                                    : hyphenGuy.background
                            ]
                        )
                    )
                );
                // We need to generate a new random number for the next
                // potentially-random character.
                prng.state = prng.next();
            } else {
                // Failed all checks. Empty background character.
                bgStr = string.concat(bgStr, " ");
            }

            // Draw a newline character if we've reached the end of a row.
            if (col == 0) bgStr = string.concat(bgStr, "\n");
            unchecked {
                --i;
            }
        }

        string memory colorHexString = string.concat(
            "#",
            ((COLORS >> (hyphenGuy.color << 5)) & 0xFFFFFF).toHexStringNoPrefix(
                3
            )
        );

        return
            string.concat(
                SVG_START,
                hyphenGuy.inverted
                    ? string.concat(
                        'class="',
                        string(
                            abi.encodePacked(COLOR_CLASSES[hyphenGuy.color])
                        ),
                        '" '
                    )
                    : "",
                'd="M0 0h600v600H0z" fill="',
                hyphenGuy.inverted ? colorHexString : "#FFF",
                // `x` is `32` because we want a left padding of 32px. `y` is
                // `20` because the Martian Mono font has an overhead of 12px,
                // and we want a top padding of 32px. Thus, by setting it to
                // `32 - 12` = 20px, we align the top of the letters with 32px
                // down from the top of the SVG. `width` is `536` because we
                // want left/right padding of 32px: `600 - 32*2 = 536`. Finally,
                // `height` is `561` because we have 11 lines, and each line is
                // 51 pixels tall: `11 * 51 = 561`.
                '"/><foreignObject x="32" y="20" width="536" height="561"><pre '
                'style="color:rgba(0,0,0,0.05)" xmlns="http://www.w3.org/1999/x'
                'html">',
                bgStr,
                // Recall that ``N'' was not accounted for in the loop because
                // we didn't look at index 0, so we draw it here. `x` is `32`
                // for the same reason outlined in the previous comment. `y` is
                // `173` because the character starts 3 lines below the first
                // (`3 * 51 = 153`), and we have the same 20px overhead as
                // before, so `153 + 20 = 173`. `width` is `536` for the same
                // reason. Finally, `height` is `204` because the character is 4
                // lines tall, and each line is 51 pixels tall: `4 * 51 = 204`.
                'N</pre></foreignObject><foreignObject x="32" y="173" width="53'
                '6" height="204"><pre',
                hyphenGuy.inverted
                    ? ""
                    : string.concat(
                        ' class="',
                        string(
                            abi.encodePacked(COLOR_CLASSES[hyphenGuy.color])
                        ),
                        '"'
                    ),
                ' style="color:',
                hyphenGuy.inverted ? "#FFF" : colorHexString,
                '" xmlns="http://www.w3.org/1999/xhtml">',
                charStr,
                SVG_END
            );
    }
}


// File: src/utils/AdoptAHyphenMetadata.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {LibString} from "solady/utils/LibString.sol";
import {AdoptAHyphenArt} from "./AdoptAHyphenArt.sol";

/// @title adopt-a-hyphen metadata
/// @notice A library for generating metadata for {AdoptAHyphen}.
/// @dev For this library to be correct, all `_seed` values must be consistent
/// with every function in both {AdoptAHyphenArt} and {AdoptAHyphenMetadata}.
library AdoptAHyphenMetadata {
    using LibString for string;
    using LibString for uint256;

    /// @notice Number of bits used to generate the art. We take note of this
    /// because we don't want to use the same bits to generate the metadata.
    uint256 constant BITS_USED = 47;

    /// @notice Joined list of adjectives to use when generating the name with
    /// `_` as the delimiter.
    /// @dev To read from this constant, use
    /// `LibString.split(string(ADJECTIVES), "_")`.
    bytes constant ADJECTIVES =
        "All-Important_Angel-Faced_Awe-Inspiring_Battle-Scarred_Big-Boned_Bird-"
        "Like_Black-and-White_Breath-Taking_Bright-Eyed_Broad-Shouldered_Bull-H"
        "eaded_Butter-Soft_Cat-Eyed_Cool-Headed_Cross-Eyed_Death-Defying_Devil-"
        "May-Care_Dew-Fresh_Dim-Witted_Down-to-Earth_Eagle-Nosed_Easy-Going_Eve"
        "r-Changing_Faint-Hearted_Feather-Brained_Fish-Eyed_Fly-by-Night_Free-T"
        "hinking_Fun-Loving_Half-Baked_Hawk-Eyed_Heart-Breaking_High-Spirited_H"
        "oney-Dipped_Honey-Tongued_Ice-Cold_Ill-Gotten_Iron-Grey_Iron-Willed_Ke"
        "en-Eyed_Kind-Hearted_Left-Handed_Lion-Hearted_Off-the-Grid_Open-Faced_"
        "Pale-Faced_Razor-Sharp_Red-Faced_Rosy-Cheeked_Ruby-Red_Self-Satisfied_"
        "Sharp-Nosed_Short-Sighted_Silky-Haired_Silver-Tongued_Sky-Blue_Slow-Fo"
        "oted_Smooth-as-Silk_Smooth-Talking_Snake-Like_Snow-Cold_Snow-White_Sof"
        "t-Voiced_Sour-Faced_Steel-Blue_Stiff-Necked_Straight-Laced_Strong-Mind"
        "ed_Sugar-Sweet_Thick-Headed_Tight-Fisted_Tongue-in-Cheek_Tough-Minded_"
        "Trigger-Happy_Velvet-Voiced_Water-Washed_White-Faced_Wide-Ranging_Wild"
        "-Haired_Wishy-Washy_Work-Weary_Yellow-Bellied_Camera-Shy_Cold-as-Ice_E"
        "mpty-Handed_Fair-Weather_Fire-Breathing_Jaw-Dropping_Mind-Boggling_No-"
        "Nonsense_Rough-and-ready_Slap-Happy_Smooth-Faced_Snail-Paced_Soul-Sear"
        "ching_Star-Studded_Tongue-Tied_Too-Good-to-be-True_Turtle-Necked_Diamo"
        "nd-Handed";

    /// @notice Joined list of first names to use when generating the name with
    /// `_` as the delimiter.
    /// @dev To read from this constant, use
    /// `LibString.split(string(FIRST_NAMES), "_")`.
    bytes constant FIRST_NAMES =
        "Alexis_Ali_Alicia_Andres_Asha_Barb_Betty_Bruce_Charles_Chris_Coco_Dan_"
        "David_Dennis_Elijah_Eugene_James_Jayden_Jenny_Jess_Joe_John_Jose_Karen"
        "_Linda_Lisa_Liz_Marco_Mark_Mary_Matt_Mert_Mike_Mirra_Nancy_Noor_Novak_"
        "Patty_Peggy_Ravi_Richard_Robert_Sandra_Sarah_Sue_Tayne_Tom_Tony_Will_Y"
        "ana";

    /// @notice Joined list of hue names to use when generating the name with
    /// `_` as the delimiter.
    /// @dev To read from this constant, use
    /// `LibString.split(string(HUES), "_")`.
    bytes constant HUES = "red_blue_orange_teal_pink_green_purple_gray";

    /// @notice Joined list of hobbies to use when generating the name with `_`
    /// as the delimiter.
    /// @dev To read from this constant, use
    /// `LibString.split(string(HOBBIES), "_")`.
    bytes constant HOBBIES =
        "blit-mapp_terra-form_shield-build_loot-bagg_OKPC-draw_mooncat-rescu_au"
        "to-glyph_animal-color_ava-starr_party-card_chain-runn_forgotten-run_bi"
        "bo-glint";

    /// @notice Generates a Hyphen Guy name.
    /// @param _seed Seed to select traits for the Hyphen Guy.
    /// @return Hyphen Guy's name.
    function generateName(uint256 _seed) internal pure returns (string memory) {
        string[] memory adjectives = string(ADJECTIVES).split("_");
        string[] memory firstNames = string(FIRST_NAMES).split("_");

        _seed >>= BITS_USED;

        return
            string.concat(
                firstNames[(_seed >> 7) % 50], // Adjectives used 7 bits
                " ",
                adjectives[_seed % 100]
            );
    }

    /// @notice Generates a Hyphen Guy's attributes.
    /// @param _seed Seed to select traits for the Hyphen Guy.
    /// @return Hyphen Guy's attributes.
    function generateAttributes(
        uint256 _seed
    ) internal pure returns (string memory) {
        string[] memory hues = string(HUES).split("_");
        string[] memory hobbies = string(HOBBIES).split("_");

        // We directly use the value of `_seed` because we don't need further
        // randomness.
        // The bits used to determine the color value are bits [24, 27]
        // (0-indexed). See {AdoptAHyphenArt.render} for more information.
        uint256 background = (_seed >> 24) % 9;

        // The bits used to determine whether the background is in ``intensity
        // mode'' or not are bits [30, 31] (0-indexed). See
        // {AdoptAHyphenArt.render} for more information.
        bool intensityMode = ((_seed >> 30) & 3) == 0;

        // The bits used to determine the color value are bits [43, 45]
        // (0-indexed). See {AdoptAHyphenArt.render} for more information.
        uint256 color = (_seed >> 43) & 7;

        // The art renderer uses the last `BITS_USED` bits to generate its
        // traits, and `generateName` uses 12 bits to generate the name, so we
        // shift those portions off.
        _seed >>= BITS_USED;
        _seed >>= 12;
        uint256 rizz = _seed % 101; // [0, 100] (7 bits)
        _seed >>= 7;
        uint256 hobby = _seed % 13; // 13 hobbies (4 bits)
        _seed >>= 4;

        return
            string.concat(
                '[{"trait_type":"hue","value":"',
                hues[color],
                '"},',
                '{"trait_type":"vibe","value":"',
                background == 6
                    ? "\\\\"
                    : string(
                        abi.encodePacked(
                            AdoptAHyphenArt.BACKGROUNDS[background]
                        )
                    ),
                '"},{"trait_type":"demeanor","value":"',
                intensityMode ? "ex" : "in",
                'troverted"},{"trait_type":"hobby","value":"',
                hobbies[hobby],
                'ing"},{"trait_type":"rizz","value":',
                rizz.toString(),
                "}]"
            );
    }
}


// File: src/utils/Base64.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Base64
/// @author Brecht Devos - <brecht@loopring.org>
/// @notice Provides a function for encoding some bytes in base64
library Base64 {
    string internal constant TABLE =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"
        "9+/";

    function encode(bytes memory data) internal pure returns (string memory) {
        if (data.length == 0) return "";
        string memory table = TABLE;
        uint256 encodedLength = ((data.length + 2) / 3) << 2;
        string memory result = new string(encodedLength + 0x20);

        assembly {
            mstore(result, encodedLength)
            let tablePtr := add(table, 1)
            let dataPtr := data
            let endPtr := add(dataPtr, mload(data))
            let resultPtr := add(result, 0x20)

            for {

            } lt(dataPtr, endPtr) {

            } {
                dataPtr := add(dataPtr, 3)
                let input := mload(dataPtr)
                mstore(
                    resultPtr,
                    shl(0xF8, mload(add(tablePtr, and(shr(0x12, input), 0x3F))))
                )
                resultPtr := add(resultPtr, 1)
                mstore(
                    resultPtr,
                    shl(0xF8, mload(add(tablePtr, and(shr(0xC, input), 0x3F))))
                )
                resultPtr := add(resultPtr, 1)
                mstore(
                    resultPtr,
                    shl(0xF8, mload(add(tablePtr, and(shr(6, input), 0x3F))))
                )
                resultPtr := add(resultPtr, 1)
                mstore(
                    resultPtr,
                    shl(0xF8, mload(add(tablePtr, and(input, 0x3F))))
                )
                resultPtr := add(resultPtr, 1)
            }
            switch mod(mload(data), 3)
            case 1 {
                mstore(sub(resultPtr, 2), shl(0xF0, 0x3D3D))
            }
            case 2 {
                mstore(sub(resultPtr, 1), shl(0xF8, 0x3D))
            }
        }

        return result;
    }
}


// File: lib/solady/src/utils/LibPRNG.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Library for generating psuedorandom numbers.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)
library LibPRNG {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STRUCTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev A psuedorandom number state in memory.
    struct PRNG {
        uint256 state;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         OPERATIONS                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Seeds the `prng` with `state`.
    function seed(PRNG memory prng, uint256 state) internal pure {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(prng, state)
        }
    }

    /// @dev Returns the next psuedorandom uint256.
    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.
    function next(PRNG memory prng) internal pure returns (uint256 result) {
        // We simply use `keccak256` for a great balance between
        // runtime gas costs, bytecode size, and statistical properties.
        //
        // A high-quality LCG with a 32-byte state
        // is only about 30% more gas efficient during runtime,
        // but requires a 32-byte multiplier, which can cause bytecode bloat
        // when this function is inlined.
        //
        // Using this method is about 2x more efficient than
        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.
        /// @solidity memory-safe-assembly
        assembly {
            result := keccak256(prng, 0x20)
            mstore(prng, result)
        }
    }

    /// @dev Returns a psuedorandom uint256, uniformly distributed
    /// between 0 (inclusive) and `upper` (exclusive).
    /// If your modulus is big, this method is recommended
    /// for uniform sampling to avoid modulo bias.
    /// For uniform sampling across all uint256 values,
    /// or for small enough moduli such that the bias is neligible,
    /// use {next} instead.
    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {
        /// @solidity memory-safe-assembly
        assembly {
            for {} 1 {} {
                result := keccak256(prng, 0x20)
                mstore(prng, result)
                if iszero(lt(result, mod(sub(0, upper), upper))) { break }
            }
            result := mod(result, upper)
        }
    }

    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.
    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {
        /// @solidity memory-safe-assembly
        assembly {
            let n := mload(a)
            let w := not(0)
            let mask := shr(128, w)
            if n {
                for { a := add(a, 0x20) } 1 {} {
                    // We can just directly use `keccak256`, cuz
                    // the other approaches don't save much.
                    let r := keccak256(prng, 0x20)
                    mstore(prng, r)

                    // Note that there will be a very tiny modulo bias
                    // if the length of the array is not a power of 2.
                    // For all practical purposes, it is negligible
                    // and will not be a fairness or security concern.
                    {
                        let j := add(a, shl(5, mod(shr(128, r), n)))
                        n := add(n, w) // `sub(n, 1)`.
                        if iszero(n) { break }

                        let i := add(a, shl(5, n))
                        let t := mload(i)
                        mstore(i, mload(j))
                        mstore(j, t)
                    }

                    {
                        let j := add(a, shl(5, mod(and(r, mask), n)))
                        n := add(n, w) // `sub(n, 1)`.
                        if iszero(n) { break }

                        let i := add(a, shl(5, n))
                        let t := mload(i)
                        mstore(i, mload(j))
                        mstore(j, t)
                    }
                }
            }
        }
    }

    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.
    function shuffle(PRNG memory prng, bytes memory a) internal pure {
        /// @solidity memory-safe-assembly
        assembly {
            let n := mload(a)
            let w := not(0)
            let mask := shr(128, w)
            if n {
                let b := add(a, 0x01)
                for { a := add(a, 0x20) } 1 {} {
                    // We can just directly use `keccak256`, cuz
                    // the other approaches don't save much.
                    let r := keccak256(prng, 0x20)
                    mstore(prng, r)

                    // Note that there will be a very tiny modulo bias
                    // if the length of the array is not a power of 2.
                    // For all practical purposes, it is negligible
                    // and will not be a fairness or security concern.
                    {
                        let o := mod(shr(128, r), n)
                        n := add(n, w) // `sub(n, 1)`.
                        if iszero(n) { break }

                        let t := mload(add(b, n))
                        mstore8(add(a, n), mload(add(b, o)))
                        mstore8(add(a, o), t)
                    }

                    {
                        let o := mod(and(r, mask), n)
                        n := add(n, w) // `sub(n, 1)`.
                        if iszero(n) { break }

                        let t := mload(add(b, n))
                        mstore8(add(a, n), mload(add(b, o)))
                        mstore8(add(a, o), t)
                    }
                }
            }
        }
    }
}


// File: lib/solady/src/utils/LibString.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Library for converting numbers into strings and other string operations.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)
/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
library LibString {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CUSTOM ERRORS                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The `length` of the output is too small to contain all the hex digits.
    error HexLengthInsufficient();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CONSTANTS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The constant returned when the `search` is not found in the string.
    uint256 internal constant NOT_FOUND = type(uint256).max;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     DECIMAL OPERATIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the base 10 decimal representation of `value`.
    function toString(uint256 value) internal pure returns (string memory str) {
        /// @solidity memory-safe-assembly
        assembly {
            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
            // We will need 1 word for the trailing zeros padding, 1 word for the length,
            // and 3 words for a maximum of 78 digits.
            str := add(mload(0x40), 0x80)
            // Update the free memory pointer to allocate.
            mstore(0x40, add(str, 0x20))
            // Zeroize the slot after the string.
            mstore(str, 0)

            // Cache the end of the memory to calculate the length later.
            let end := str

            let w := not(0) // Tsk.
            // We write the string from rightmost digit to leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            for { let temp := value } 1 {} {
                str := add(str, w) // `sub(str, 1)`.
                // Write the character to the pointer.
                // The ASCII index of the '0' character is 48.
                mstore8(str, add(48, mod(temp, 10)))
                // Keep dividing `temp` until zero.
                temp := div(temp, 10)
                if iszero(temp) { break }
            }

            let length := sub(end, str)
            // Move the pointer 32 bytes leftwards to make room for the length.
            str := sub(str, 0x20)
            // Store the length.
            mstore(str, length)
        }
    }

    /// @dev Returns the base 10 decimal representation of `value`.
    function toString(int256 value) internal pure returns (string memory str) {
        if (value >= 0) {
            return toString(uint256(value));
        }
        unchecked {
            str = toString(uint256(-value));
        }
        /// @solidity memory-safe-assembly
        assembly {
            // We still have some spare memory space on the left,
            // as we have allocated 3 words (96 bytes) for up to 78 digits.
            let length := mload(str) // Load the string length.
            mstore(str, 0x2d) // Store the '-' character.
            str := sub(str, 1) // Move back the string pointer by a byte.
            mstore(str, add(length, 1)) // Update the string length.
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   HEXADECIMAL OPERATIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the hexadecimal representation of `value`,
    /// left-padded to an input length of `length` bytes.
    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,
    /// giving a total length of `length * 2 + 2` bytes.
    /// Reverts if `length` is too small for the output to contain all the digits.
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {
        str = toHexStringNoPrefix(value, length);
        /// @solidity memory-safe-assembly
        assembly {
            let strLength := add(mload(str), 2) // Compute the length.
            mstore(str, 0x3078) // Write the "0x" prefix.
            str := sub(str, 2) // Move the pointer.
            mstore(str, strLength) // Write the length.
        }
    }

    /// @dev Returns the hexadecimal representation of `value`,
    /// left-padded to an input length of `length` bytes.
    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,
    /// giving a total length of `length * 2` bytes.
    /// Reverts if `length` is too small for the output to contain all the digits.
    function toHexStringNoPrefix(uint256 value, uint256 length)
        internal
        pure
        returns (string memory str)
    {
        /// @solidity memory-safe-assembly
        assembly {
            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes
            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.
            // We add 0x20 to the total and round down to a multiple of 0x20.
            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.
            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))
            // Allocate the memory.
            mstore(0x40, add(str, 0x20))
            // Zeroize the slot after the string.
            mstore(str, 0)

            // Cache the end to calculate the length later.
            let end := str
            // Store "0123456789abcdef" in scratch space.
            mstore(0x0f, 0x30313233343536373839616263646566)

            let start := sub(str, add(length, length))
            let w := not(1) // Tsk.
            let temp := value
            // We write the string from rightmost digit to leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            for {} 1 {} {
                str := add(str, w) // `sub(str, 2)`.
                mstore8(add(str, 1), mload(and(temp, 15)))
                mstore8(str, mload(and(shr(4, temp), 15)))
                temp := shr(8, temp)
                if iszero(xor(str, start)) { break }
            }

            if temp {
                // Store the function selector of `HexLengthInsufficient()`.
                mstore(0x00, 0x2194895a)
                // Revert with (offset, size).
                revert(0x1c, 0x04)
            }

            // Compute the string's length.
            let strLength := sub(end, str)
            // Move the pointer and write the length.
            str := sub(str, 0x20)
            mstore(str, strLength)
        }
    }

    /// @dev Returns the hexadecimal representation of `value`.
    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.
    /// As address are 20 bytes long, the output will left-padded to have
    /// a length of `20 * 2 + 2` bytes.
    function toHexString(uint256 value) internal pure returns (string memory str) {
        str = toHexStringNoPrefix(value);
        /// @solidity memory-safe-assembly
        assembly {
            let strLength := add(mload(str), 2) // Compute the length.
            mstore(str, 0x3078) // Write the "0x" prefix.
            str := sub(str, 2) // Move the pointer.
            mstore(str, strLength) // Write the length.
        }
    }

    /// @dev Returns the hexadecimal representation of `value`.
    /// The output is encoded using 2 hexadecimal digits per byte.
    /// As address are 20 bytes long, the output will left-padded to have
    /// a length of `20 * 2` bytes.
    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {
        /// @solidity memory-safe-assembly
        assembly {
            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.
            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.
            str := add(mload(0x40), 0x80)
            // Allocate the memory.
            mstore(0x40, add(str, 0x20))
            // Zeroize the slot after the string.
            mstore(str, 0)

            // Cache the end to calculate the length later.
            let end := str
            // Store "0123456789abcdef" in scratch space.
            mstore(0x0f, 0x30313233343536373839616263646566)

            let w := not(1) // Tsk.
            // We write the string from rightmost digit to leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            for { let temp := value } 1 {} {
                str := add(str, w) // `sub(str, 2)`.
                mstore8(add(str, 1), mload(and(temp, 15)))
                mstore8(str, mload(and(shr(4, temp), 15)))
                temp := shr(8, temp)
                if iszero(temp) { break }
            }

            // Compute the string's length.
            let strLength := sub(end, str)
            // Move the pointer and write the length.
            str := sub(str, 0x20)
            mstore(str, strLength)
        }
    }

    /// @dev Returns the hexadecimal representation of `value`.
    /// The output is prefixed with "0x", encoded using 2 hexadecimal digits per byte,
    /// and the alphabets are capitalized conditionally according to
    /// https://eips.ethereum.org/EIPS/eip-55
    function toHexStringChecksummed(address value) internal pure returns (string memory str) {
        str = toHexString(value);
        /// @solidity memory-safe-assembly
        assembly {
            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`
            let o := add(str, 0x22)
            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `
            let t := shl(240, 136) // `0b10001000 << 240`
            for { let i := 0 } 1 {} {
                mstore(add(i, i), mul(t, byte(i, hashed)))
                i := add(i, 1)
                if eq(i, 20) { break }
            }
            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))
            o := add(o, 0x20)
            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))
        }
    }

    /// @dev Returns the hexadecimal representation of `value`.
    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.
    function toHexString(address value) internal pure returns (string memory str) {
        str = toHexStringNoPrefix(value);
        /// @solidity memory-safe-assembly
        assembly {
            let strLength := add(mload(str), 2) // Compute the length.
            mstore(str, 0x3078) // Write the "0x" prefix.
            str := sub(str, 2) // Move the pointer.
            mstore(str, strLength) // Write the length.
        }
    }

    /// @dev Returns the hexadecimal representation of `value`.
    /// The output is encoded using 2 hexadecimal digits per byte.
    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {
        /// @solidity memory-safe-assembly
        assembly {
            str := mload(0x40)

            // Allocate the memory.
            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,
            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.
            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.
            mstore(0x40, add(str, 0x80))

            // Store "0123456789abcdef" in scratch space.
            mstore(0x0f, 0x30313233343536373839616263646566)

            str := add(str, 2)
            mstore(str, 40)

            let o := add(str, 0x20)
            mstore(add(o, 40), 0)

            value := shl(96, value)

            // We write the string from rightmost digit to leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            for { let i := 0 } 1 {} {
                let p := add(o, add(i, i))
                let temp := byte(i, value)
                mstore8(add(p, 1), mload(and(temp, 15)))
                mstore8(p, mload(shr(4, temp)))
                i := add(i, 1)
                if eq(i, 20) { break }
            }
        }
    }

    /// @dev Returns the hex encoded string from the raw bytes.
    /// The output is encoded using 2 hexadecimal digits per byte.
    function toHexString(bytes memory raw) internal pure returns (string memory str) {
        str = toHexStringNoPrefix(raw);
        /// @solidity memory-safe-assembly
        assembly {
            let strLength := add(mload(str), 2) // Compute the length.
            mstore(str, 0x3078) // Write the "0x" prefix.
            str := sub(str, 2) // Move the pointer.
            mstore(str, strLength) // Write the length.
        }
    }

    /// @dev Returns the hex encoded string from the raw bytes.
    /// The output is encoded using 2 hexadecimal digits per byte.
    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {
        /// @solidity memory-safe-assembly
        assembly {
            let length := mload(raw)
            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.
            mstore(str, add(length, length)) // Store the length of the output.

            // Store "0123456789abcdef" in scratch space.
            mstore(0x0f, 0x30313233343536373839616263646566)

            let o := add(str, 0x20)
            let end := add(raw, length)

            for {} iszero(eq(raw, end)) {} {
                raw := add(raw, 1)
                mstore8(add(o, 1), mload(and(mload(raw), 15)))
                mstore8(o, mload(and(shr(4, mload(raw)), 15)))
                o := add(o, 2)
            }
            mstore(o, 0) // Zeroize the slot after the string.
            mstore(0x40, add(o, 0x20)) // Allocate the memory.
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   RUNE STRING OPERATIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the number of UTF characters in the string.
    function runeCount(string memory s) internal pure returns (uint256 result) {
        /// @solidity memory-safe-assembly
        assembly {
            if mload(s) {
                mstore(0x00, div(not(0), 255))
                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)
                let o := add(s, 0x20)
                let end := add(o, mload(s))
                for { result := 1 } 1 { result := add(result, 1) } {
                    o := add(o, byte(0, mload(shr(250, mload(o)))))
                    if iszero(lt(o, end)) { break }
                }
            }
        }
    }

    /// @dev Returns if this string is a 7-bit ASCII string.
    /// (i.e. all characters codes are in [0..127])
    function is7BitASCII(string memory s) internal pure returns (bool result) {
        /// @solidity memory-safe-assembly
        assembly {
            let mask := shl(7, div(not(0), 255))
            result := 1
            let n := mload(s)
            if n {
                let o := add(s, 0x20)
                let end := add(o, n)
                let last := mload(end)
                mstore(end, 0)
                for {} 1 {} {
                    if and(mask, mload(o)) {
                        result := 0
                        break
                    }
                    o := add(o, 0x20)
                    if iszero(lt(o, end)) { break }
                }
                mstore(end, last)
            }
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   BYTE STRING OPERATIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // For performance and bytecode compactness, all indices of the following operations
    // are byte (ASCII) offsets, not UTF character offsets.

    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.
    function replace(string memory subject, string memory search, string memory replacement)
        internal
        pure
        returns (string memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let subjectLength := mload(subject)
            let searchLength := mload(search)
            let replacementLength := mload(replacement)

            subject := add(subject, 0x20)
            search := add(search, 0x20)
            replacement := add(replacement, 0x20)
            result := add(mload(0x40), 0x20)

            let subjectEnd := add(subject, subjectLength)
            if iszero(gt(searchLength, subjectLength)) {
                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)
                let h := 0
                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
                let s := mload(search)
                for {} 1 {} {
                    let t := mload(subject)
                    // Whether the first `searchLength % 32` bytes of
                    // `subject` and `search` matches.
                    if iszero(shr(m, xor(t, s))) {
                        if h {
                            if iszero(eq(keccak256(subject, searchLength), h)) {
                                mstore(result, t)
                                result := add(result, 1)
                                subject := add(subject, 1)
                                if iszero(lt(subject, subjectSearchEnd)) { break }
                                continue
                            }
                        }
                        // Copy the `replacement` one word at a time.
                        for { let o := 0 } 1 {} {
                            mstore(add(result, o), mload(add(replacement, o)))
                            o := add(o, 0x20)
                            if iszero(lt(o, replacementLength)) { break }
                        }
                        result := add(result, replacementLength)
                        subject := add(subject, searchLength)
                        if searchLength {
                            if iszero(lt(subject, subjectSearchEnd)) { break }
                            continue
                        }
                    }
                    mstore(result, t)
                    result := add(result, 1)
                    subject := add(subject, 1)
                    if iszero(lt(subject, subjectSearchEnd)) { break }
                }
            }

            let resultRemainder := result
            result := add(mload(0x40), 0x20)
            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))
            // Copy the rest of the string one word at a time.
            for {} lt(subject, subjectEnd) {} {
                mstore(resultRemainder, mload(subject))
                resultRemainder := add(resultRemainder, 0x20)
                subject := add(subject, 0x20)
            }
            result := sub(result, 0x20)
            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.
            mstore(last, 0)
            mstore(0x40, add(last, 0x20)) // Allocate the memory.
            mstore(result, k) // Store the length.
        }
    }

    /// @dev Returns the byte index of the first location of `search` in `subject`,
    /// searching from left to right, starting from `from`.
    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.
    function indexOf(string memory subject, string memory search, uint256 from)
        internal
        pure
        returns (uint256 result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            for { let subjectLength := mload(subject) } 1 {} {
                if iszero(mload(search)) {
                    if iszero(gt(from, subjectLength)) {
                        result := from
                        break
                    }
                    result := subjectLength
                    break
                }
                let searchLength := mload(search)
                let subjectStart := add(subject, 0x20)

                result := not(0) // Initialize to `NOT_FOUND`.

                subject := add(subjectStart, from)
                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)

                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
                let s := mload(add(search, 0x20))

                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }

                if iszero(lt(searchLength, 0x20)) {
                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
                        if iszero(shr(m, xor(mload(subject), s))) {
                            if eq(keccak256(subject, searchLength), h) {
                                result := sub(subject, subjectStart)
                                break
                            }
                        }
                        subject := add(subject, 1)
                        if iszero(lt(subject, end)) { break }
                    }
                    break
                }
                for {} 1 {} {
                    if iszero(shr(m, xor(mload(subject), s))) {
                        result := sub(subject, subjectStart)
                        break
                    }
                    subject := add(subject, 1)
                    if iszero(lt(subject, end)) { break }
                }
                break
            }
        }
    }

    /// @dev Returns the byte index of the first location of `search` in `subject`,
    /// searching from left to right.
    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.
    function indexOf(string memory subject, string memory search)
        internal
        pure
        returns (uint256 result)
    {
        result = indexOf(subject, search, 0);
    }

    /// @dev Returns the byte index of the first location of `search` in `subject`,
    /// searching from right to left, starting from `from`.
    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.
    function lastIndexOf(string memory subject, string memory search, uint256 from)
        internal
        pure
        returns (uint256 result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            for {} 1 {} {
                result := not(0) // Initialize to `NOT_FOUND`.
                let searchLength := mload(search)
                if gt(searchLength, mload(subject)) { break }
                let w := result

                let fromMax := sub(mload(subject), searchLength)
                if iszero(gt(fromMax, from)) { from := fromMax }

                let end := add(add(subject, 0x20), w)
                subject := add(add(subject, 0x20), from)
                if iszero(gt(subject, end)) { break }
                // As this function is not too often used,
                // we shall simply use keccak256 for smaller bytecode size.
                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {
                    if eq(keccak256(subject, searchLength), h) {
                        result := sub(subject, add(end, 1))
                        break
                    }
                    subject := add(subject, w) // `sub(subject, 1)`.
                    if iszero(gt(subject, end)) { break }
                }
                break
            }
        }
    }

    /// @dev Returns the byte index of the first location of `search` in `subject`,
    /// searching from right to left.
    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.
    function lastIndexOf(string memory subject, string memory search)
        internal
        pure
        returns (uint256 result)
    {
        result = lastIndexOf(subject, search, uint256(int256(-1)));
    }

    /// @dev Returns whether `subject` starts with `search`.
    function startsWith(string memory subject, string memory search)
        internal
        pure
        returns (bool result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let searchLength := mload(search)
            // Just using keccak256 directly is actually cheaper.
            // forgefmt: disable-next-item
            result := and(
                iszero(gt(searchLength, mload(subject))),
                eq(
                    keccak256(add(subject, 0x20), searchLength),
                    keccak256(add(search, 0x20), searchLength)
                )
            )
        }
    }

    /// @dev Returns whether `subject` ends with `search`.
    function endsWith(string memory subject, string memory search)
        internal
        pure
        returns (bool result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let searchLength := mload(search)
            let subjectLength := mload(subject)
            // Whether `search` is not longer than `subject`.
            let withinRange := iszero(gt(searchLength, subjectLength))
            // Just using keccak256 directly is actually cheaper.
            // forgefmt: disable-next-item
            result := and(
                withinRange,
                eq(
                    keccak256(
                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.
                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),
                        searchLength
                    ),
                    keccak256(add(search, 0x20), searchLength)
                )
            )
        }
    }

    /// @dev Returns `subject` repeated `times`.
    function repeat(string memory subject, uint256 times)
        internal
        pure
        returns (string memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let subjectLength := mload(subject)
            if iszero(or(iszero(times), iszero(subjectLength))) {
                subject := add(subject, 0x20)
                result := mload(0x40)
                let output := add(result, 0x20)
                for {} 1 {} {
                    // Copy the `subject` one word at a time.
                    for { let o := 0 } 1 {} {
                        mstore(add(output, o), mload(add(subject, o)))
                        o := add(o, 0x20)
                        if iszero(lt(o, subjectLength)) { break }
                    }
                    output := add(output, subjectLength)
                    times := sub(times, 1)
                    if iszero(times) { break }
                }
                mstore(output, 0) // Zeroize the slot after the string.
                let resultLength := sub(output, add(result, 0x20))
                mstore(result, resultLength) // Store the length.
                // Allocate the memory.
                mstore(0x40, add(result, add(resultLength, 0x20)))
            }
        }
    }

    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).
    /// `start` and `end` are byte offsets.
    function slice(string memory subject, uint256 start, uint256 end)
        internal
        pure
        returns (string memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let subjectLength := mload(subject)
            if iszero(gt(subjectLength, end)) { end := subjectLength }
            if iszero(gt(subjectLength, start)) { start := subjectLength }
            if lt(start, end) {
                result := mload(0x40)
                let resultLength := sub(end, start)
                mstore(result, resultLength)
                subject := add(subject, start)
                let w := not(0x1f)
                // Copy the `subject` one word at a time, backwards.
                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {
                    mstore(add(result, o), mload(add(subject, o)))
                    o := add(o, w) // `sub(o, 0x20)`.
                    if iszero(o) { break }
                }
                // Zeroize the slot after the string.
                mstore(add(add(result, 0x20), resultLength), 0)
                // Allocate memory for the length and the bytes,
                // rounded up to a multiple of 32.
                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))
            }
        }
    }

    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.
    /// `start` is a byte offset.
    function slice(string memory subject, uint256 start)
        internal
        pure
        returns (string memory result)
    {
        result = slice(subject, start, uint256(int256(-1)));
    }

    /// @dev Returns all the indices of `search` in `subject`.
    /// The indices are byte offsets.
    function indicesOf(string memory subject, string memory search)
        internal
        pure
        returns (uint256[] memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let subjectLength := mload(subject)
            let searchLength := mload(search)

            if iszero(gt(searchLength, subjectLength)) {
                subject := add(subject, 0x20)
                search := add(search, 0x20)
                result := add(mload(0x40), 0x20)

                let subjectStart := subject
                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)
                let h := 0
                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }
                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))
                let s := mload(search)
                for {} 1 {} {
                    let t := mload(subject)
                    // Whether the first `searchLength % 32` bytes of
                    // `subject` and `search` matches.
                    if iszero(shr(m, xor(t, s))) {
                        if h {
                            if iszero(eq(keccak256(subject, searchLength), h)) {
                                subject := add(subject, 1)
                                if iszero(lt(subject, subjectSearchEnd)) { break }
                                continue
                            }
                        }
                        // Append to `result`.
                        mstore(result, sub(subject, subjectStart))
                        result := add(result, 0x20)
                        // Advance `subject` by `searchLength`.
                        subject := add(subject, searchLength)
                        if searchLength {
                            if iszero(lt(subject, subjectSearchEnd)) { break }
                            continue
                        }
                    }
                    subject := add(subject, 1)
                    if iszero(lt(subject, subjectSearchEnd)) { break }
                }
                let resultEnd := result
                // Assign `result` to the free memory pointer.
                result := mload(0x40)
                // Store the length of `result`.
                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))
                // Allocate memory for result.
                // We allocate one more word, so this array can be recycled for {split}.
                mstore(0x40, add(resultEnd, 0x20))
            }
        }
    }

    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.
    function split(string memory subject, string memory delimiter)
        internal
        pure
        returns (string[] memory result)
    {
        uint256[] memory indices = indicesOf(subject, delimiter);
        /// @solidity memory-safe-assembly
        assembly {
            let w := not(0x1f)
            let indexPtr := add(indices, 0x20)
            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))
            mstore(add(indicesEnd, w), mload(subject))
            mstore(indices, add(mload(indices), 1))
            let prevIndex := 0
            for {} 1 {} {
                let index := mload(indexPtr)
                mstore(indexPtr, 0x60)
                if iszero(eq(index, prevIndex)) {
                    let element := mload(0x40)
                    let elementLength := sub(index, prevIndex)
                    mstore(element, elementLength)
                    // Copy the `subject` one word at a time, backwards.
                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {
                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))
                        o := add(o, w) // `sub(o, 0x20)`.
                        if iszero(o) { break }
                    }
                    // Zeroize the slot after the string.
                    mstore(add(add(element, 0x20), elementLength), 0)
                    // Allocate memory for the length and the bytes,
                    // rounded up to a multiple of 32.
                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))
                    // Store the `element` into the array.
                    mstore(indexPtr, element)
                }
                prevIndex := add(index, mload(delimiter))
                indexPtr := add(indexPtr, 0x20)
                if iszero(lt(indexPtr, indicesEnd)) { break }
            }
            result := indices
            if iszero(mload(delimiter)) {
                result := add(indices, 0x20)
                mstore(result, sub(mload(indices), 2))
            }
        }
    }

    /// @dev Returns a concatenated string of `a` and `b`.
    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.
    function concat(string memory a, string memory b)
        internal
        pure
        returns (string memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let w := not(0x1f)
            result := mload(0x40)
            let aLength := mload(a)
            // Copy `a` one word at a time, backwards.
            for { let o := and(add(mload(a), 0x20), w) } 1 {} {
                mstore(add(result, o), mload(add(a, o)))
                o := add(o, w) // `sub(o, 0x20)`.
                if iszero(o) { break }
            }
            let bLength := mload(b)
            let output := add(result, mload(a))
            // Copy `b` one word at a time, backwards.
            for { let o := and(add(bLength, 0x20), w) } 1 {} {
                mstore(add(output, o), mload(add(b, o)))
                o := add(o, w) // `sub(o, 0x20)`.
                if iszero(o) { break }
            }
            let totalLength := add(aLength, bLength)
            let last := add(add(result, 0x20), totalLength)
            // Zeroize the slot after the string.
            mstore(last, 0)
            // Stores the length.
            mstore(result, totalLength)
            // Allocate memory for the length and the bytes,
            // rounded up to a multiple of 32.
            mstore(0x40, and(add(last, 0x1f), w))
        }
    }

    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.
    /// WARNING! This function is only compatible with 7-bit ASCII strings.
    function toCase(string memory subject, bool toUpper)
        internal
        pure
        returns (string memory result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let length := mload(subject)
            if length {
                result := add(mload(0x40), 0x20)
                subject := add(subject, 1)
                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)
                let w := not(0)
                for { let o := length } 1 {} {
                    o := add(o, w)
                    let b := and(0xff, mload(add(subject, o)))
                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))
                    if iszero(o) { break }
                }
                result := mload(0x40)
                mstore(result, length) // Store the length.
                let last := add(add(result, 0x20), length)
                mstore(last, 0) // Zeroize the slot after the string.
                mstore(0x40, add(last, 0x20)) // Allocate the memory.
            }
        }
    }

    /// @dev Returns a lowercased copy of the string.
    /// WARNING! This function is only compatible with 7-bit ASCII strings.
    function lower(string memory subject) internal pure returns (string memory result) {
        result = toCase(subject, false);
    }

    /// @dev Returns an UPPERCASED copy of the string.
    /// WARNING! This function is only compatible with 7-bit ASCII strings.
    function upper(string memory subject) internal pure returns (string memory result) {
        result = toCase(subject, true);
    }

    /// @dev Escapes the string to be used within HTML tags.
    function escapeHTML(string memory s) internal pure returns (string memory result) {
        /// @solidity memory-safe-assembly
        assembly {
            for {
                let end := add(s, mload(s))
                result := add(mload(0x40), 0x20)
                // Store the bytes of the packed offsets and strides into the scratch space.
                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.
                mstore(0x1f, 0x900094)
                mstore(0x08, 0xc0000000a6ab)
                // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.
                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))
            } iszero(eq(s, end)) {} {
                s := add(s, 1)
                let c := and(mload(s), 0xff)
                // Not in `["\"","'","&","<",">"]`.
                if iszero(and(shl(c, 1), 0x500000c400000000)) {
                    mstore8(result, c)
                    result := add(result, 1)
                    continue
                }
                let t := shr(248, mload(c))
                mstore(result, mload(and(t, 0x1f)))
                result := add(result, shr(5, t))
            }
            let last := result
            mstore(last, 0) // Zeroize the slot after the string.
            result := mload(0x40)
            mstore(result, sub(last, add(result, 0x20))) // Store the length.
            mstore(0x40, add(last, 0x20)) // Allocate the memory.
        }
    }

    /// @dev Escapes the string to be used within double-quotes in a JSON.
    function escapeJSON(string memory s) internal pure returns (string memory result) {
        /// @solidity memory-safe-assembly
        assembly {
            for {
                let end := add(s, mload(s))
                result := add(mload(0x40), 0x20)
                // Store "\\u0000" in scratch space.
                // Store "0123456789abcdef" in scratch space.
                // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.
                // into the scratch space.
                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)
                // Bitmask for detecting `["\"","\\"]`.
                let e := or(shl(0x22, 1), shl(0x5c, 1))
            } iszero(eq(s, end)) {} {
                s := add(s, 1)
                let c := and(mload(s), 0xff)
                if iszero(lt(c, 0x20)) {
                    if iszero(and(shl(c, 1), e)) {
                        // Not in `["\"","\\"]`.
                        mstore8(result, c)
                        result := add(result, 1)
                        continue
                    }
                    mstore8(result, 0x5c) // "\\".
                    mstore8(add(result, 1), c)
                    result := add(result, 2)
                    continue
                }
                if iszero(and(shl(c, 1), 0x3700)) {
                    // Not in `["\b","\t","\n","\f","\d"]`.
                    mstore8(0x1d, mload(shr(4, c))) // Hex value.
                    mstore8(0x1e, mload(and(c, 15))) // Hex value.
                    mstore(result, mload(0x19)) // "\\u00XX".
                    result := add(result, 6)
                    continue
                }
                mstore8(result, 0x5c) // "\\".
                mstore8(add(result, 1), mload(add(c, 8)))
                result := add(result, 2)
            }
            let last := result
            mstore(last, 0) // Zeroize the slot after the string.
            result := mload(0x40)
            mstore(result, sub(last, add(result, 0x20))) // Store the length.
            mstore(0x40, add(last, 0x20)) // Allocate the memory.
        }
    }

    /// @dev Returns whether `a` equals `b`.
    function eq(string memory a, string memory b) internal pure returns (bool result) {
        assembly {
            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))
        }
    }

    /// @dev Packs a single string with its length into a single word.
    /// Returns `bytes32(0)` if the length is zero or greater than 31.
    function packOne(string memory a) internal pure returns (bytes32 result) {
        /// @solidity memory-safe-assembly
        assembly {
            // We don't need to zero right pad the string,
            // since this is our own custom non-standard packing scheme.
            result :=
                mul(
                    // Load the length and the bytes.
                    mload(add(a, 0x1f)),
                    // `length != 0 && length < 32`. Abuses underflow.
                    // Assumes that the length is valid and within the block gas limit.
                    lt(sub(mload(a), 1), 0x1f)
                )
        }
    }

    /// @dev Unpacks a string packed using {packOne}.
    /// Returns the empty string if `packed` is `bytes32(0)`.
    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.
    function unpackOne(bytes32 packed) internal pure returns (string memory result) {
        /// @solidity memory-safe-assembly
        assembly {
            // Grab the free memory pointer.
            result := mload(0x40)
            // Allocate 2 words (1 for the length, 1 for the bytes).
            mstore(0x40, add(result, 0x40))
            // Zeroize the length slot.
            mstore(result, 0)
            // Store the length and bytes.
            mstore(add(result, 0x1f), packed)
            // Right pad with zeroes.
            mstore(add(add(result, 0x20), mload(result)), 0)
        }
    }

    /// @dev Packs two strings with their lengths into a single word.
    /// Returns `bytes32(0)` if combined length is zero or greater than 30.
    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {
        /// @solidity memory-safe-assembly
        assembly {
            let aLength := mload(a)
            // We don't need to zero right pad the strings,
            // since this is our own custom non-standard packing scheme.
            result :=
                mul(
                    // Load the length and the bytes of `a` and `b`.
                    or(
                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),
                        mload(sub(add(b, 0x1e), aLength))
                    ),
                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.
                    // Assumes that the lengths are valid and within the block gas limit.
                    lt(sub(add(aLength, mload(b)), 1), 0x1e)
                )
        }
    }

    /// @dev Unpacks strings packed using {packTwo}.
    /// Returns the empty strings if `packed` is `bytes32(0)`.
    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.
    function unpackTwo(bytes32 packed)
        internal
        pure
        returns (string memory resultA, string memory resultB)
    {
        /// @solidity memory-safe-assembly
        assembly {
            // Grab the free memory pointer.
            resultA := mload(0x40)
            resultB := add(resultA, 0x40)
            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.
            mstore(0x40, add(resultB, 0x40))
            // Zeroize the length slots.
            mstore(resultA, 0)
            mstore(resultB, 0)
            // Store the lengths and bytes.
            mstore(add(resultA, 0x1f), packed)
            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))
            // Right pad with zeroes.
            mstore(add(add(resultA, 0x20), mload(resultA)), 0)
            mstore(add(add(resultB, 0x20), mload(resultB)), 0)
        }
    }

    /// @dev Directly returns `a` without copying.
    function directReturn(string memory a) internal pure {
        assembly {
            // Assumes that the string does not start from the scratch space.
            let retStart := sub(a, 0x20)
            let retSize := add(mload(a), 0x40)
            // Right pad with zeroes. Just in case the string is produced
            // by a method that doesn't zero right pad.
            mstore(add(retStart, retSize), 0)
            // Store the return offset.
            mstore(retStart, 0x20)
            // End the transaction, returning the string.
            return(retStart, retSize)
        }
    }
}

