
// File: src/KeyExchange.sol
// SPDX-License-Identifier: SegMint Code License 1.1
pragma solidity 0.8.19;

import { OwnableRoles } from "solady/src/auth/OwnableRoles.sol";
import { ECDSA } from "solady/src/utils/ECDSA.sol";
import { IERC1155 } from "@openzeppelin/token/ERC1155/IERC1155.sol";
import { IERC20 } from "@openzeppelin/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/token/ERC20/utils/SafeERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/security/ReentrancyGuard.sol";
import { AccessRoles } from "./access/AccessRoles.sol";
import { TypeHasher } from "./handlers/TypeHasher.sol";
import { NonceManager } from "./managers/NonceManager.sol";
import { IKeyExchange } from "./interfaces/IKeyExchange.sol";
import { IAccessRegistry } from "./interfaces/IAccessRegistry.sol";
import { IMAVault } from "./interfaces/IMAVault.sol";
import { IKeys } from "./interfaces/IKeys.sol";
import { VaultType, KeyConfig } from "./types/DataTypes.sol";

/**
 * @title KeyExchange
 * @notice Facilitates trading of Keys.
 */

contract KeyExchange is IKeyExchange, OwnableRoles, NonceManager, TypeHasher, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using ECDSA for bytes32;

    /// @dev Total basis points used for fee calculation.
    uint256 private constant _BASIS_POINTS = 10_000;

    /// @dev Total gas to forward on royalty payments.
    uint256 private constant _ROYALTY_GAS_STIPEND = 2_300;

    /// @dev Wrapped native token contract.
    IERC20 public immutable WETH;
    IKeys public immutable keys;
    IAccessRegistry public immutable accessRegistry;

    /// Default protocol fee to 05.00%
    uint256 public protocolFee = 500;
    address public feeReceiver;

    /// Flag indicating if multi-asset vault keys are tradable.
    bool public multiKeysTradable;

    /// Flag indicating if restricted users can trade via the exchange.
    bool public allowRestrictedUsers;

    mapping(bytes32 orderHash => Status status) public orderStatus;
    mapping(bytes32 bidHash => Status status) public bidStatus;
    mapping(uint256 keyId => KeyTerms keyTerms) private _keyTerms;

    constructor(address admin_, address feeReceiver_, address weth_, IKeys keys_, IAccessRegistry accessRegistry_) {
        if (admin_ == address(0)) revert ZeroAddressInvalid();
        if (feeReceiver_ == address(0)) revert ZeroAddressInvalid();
        if (weth_ == address(0)) revert ZeroAddressInvalid();
        if (address(keys_) == address(0)) revert ZeroAddressInvalid();
        if (address(accessRegistry_) == address(0)) revert ZeroAddressInvalid();

        _initializeOwner(msg.sender);
        _grantRoles({ user: admin_, roles: AccessRoles.ADMIN_ROLE });

        WETH = IERC20(weth_);
        feeReceiver = feeReceiver_;

        keys = keys_;
        accessRegistry = accessRegistry_;
    }

    modifier checkCaller() {
        _checkAccess(msg.sender);
        _;
    }

    /**
     * @inheritdoc IKeyExchange
     * @dev `msg.sender` in this context is a user wishing to fill an order, a buyer.
     */
    function executeOrders(OrderParams[] calldata orders) external payable checkCaller nonReentrant {
        /// Checks: Ensure a non-zero amount of orders have been specified.
        if (orders.length == 0) revert ZeroLengthArray();

        /// Push initial `msg.value` to the stack.
        uint256 msgValue = msg.value;

        /// Tracks the total fees to be paid for all orders.
        uint256 totalFees = 0;

        for (uint256 i = 0; i < orders.length;) {
            /// Cache respective order parameters.
            Order calldata order = orders[i].order;
            bytes calldata signature = orders[i].signature;

            /// Checks: Ensure the order maker has valid access to the Key Exchange.
            _checkAccess(order.maker);

            /// Checks: Ensure that the key terms have been defined for the associated key ID.
            MarketType keyMarket = _keyTerms[order.keyId].market;
            if (keyMarket == MarketType.UNDEFINED || keyMarket == MarketType.INACTIVE) revert InvalidKeyMarket();

            /// Get the EIP712 digest of the provided order.
            bytes32 orderHash = _hashOrder(order);

            /// Checks: Determine if the order has a valid status.
            if (orderStatus[orderHash] != Status.OPEN) revert InvalidOrderStatus();

            /// Checks: Confirm that the signature attached matches the order maker.
            if (orderHash.recover(signature) != order.maker) revert SignerNotMaker();

            /// Checks: Determine if a taker has been specified and if the caller is the taker.
            if (order.taker != address(0) && msg.sender != order.taker) revert CallerNotTaker();

            /// Checks: Ensure bid start time has elapsed.
            if (block.timestamp < order.startTime) revert InactiveOrderOrBid();

            /// Checks: Ensure bid end time hasn't passed.
            if (block.timestamp > order.endTime) revert ExpiredOrderOrBid();

            /// Acknowledge that the order will be filled upon success.
            orderStatus[orderHash] = Status.FILLED;

            /// Transfer keys to caller.
            IERC1155(address(keys)).safeTransferFrom(order.maker, msg.sender, order.keyId, order.amount, "");

            /// Caclulate total payable royalties.
            uint256 payableRoyalties = order.royalties.length == 0 ? 0 : _calculateRoyaltyPayment(order.royalties);

            /// Calculate the protocol fee and subtract from the order price.
            uint256 calculatedFee = order.price * order.protocolFee / _BASIS_POINTS;
            uint256 makerEarnings = order.price - calculatedFee - payableRoyalties;

            /// Update the total amount of native token to pay the protocol.
            totalFees += calculatedFee;

            /// Pay the maker earnings, forward a sufficient amount of gas.
            (bool success,) = order.maker.call{ value: makerEarnings }("");
            if (!success) revert NativeTransferFailed();

            /// Pay the royalties if any are due.
            if (payableRoyalties != 0) {
                _payRoyaltiesWithNativeToken(order.royalties);
            }

            /// Checks: Ensure a sufficient amount of native token has been provided.
            if (order.price > msgValue) revert InvalidNativeTokenAmount();
            msgValue -= order.price;

            /// Emit event after the order has been completely filled.
            emit OrderFilled({ taker: msg.sender, orderHash: orderHash });

            unchecked { i++; }
        }

        /// Pay the total fee amount to the fee receiver.
        if (totalFees > 0) {
            (bool success,) = feeReceiver.call{ value: totalFees }("");
            if (!success) revert NativeTransferFailed();
        }

        /// If some amount of native token remains, refund to the caller.
        if (msgValue > 0) {
            (bool refunded,) = msg.sender.call{ value: msgValue }("");
            if (!refunded) revert NativeTransferFailed();
        }
    }

    /**
     * @inheritdoc IKeyExchange
     * @dev `msg.sender` in this context is a user wishing to accept a bid, a seller.
     */
    function executeBids(BidParams[] calldata bidParams) external checkCaller nonReentrant {
        /// Checks: Ensure a non zero amount of bids have been provided.
        if (bidParams.length == 0) revert ZeroLengthArray();

        for (uint256 i = 0; i < bidParams.length;) {
            /// Cache respective bid parameters.
            Bid calldata bid = bidParams[i].bid;
            bytes calldata signature = bidParams[i].signature;

            /// Checks: Ensure the bid maker has valid access to the Key Exchange.
            _checkAccess(bid.maker);

            /// Checks: Ensure that key terms have been defined for the key identifier.
            MarketType keyMarket = _keyTerms[bid.keyId].market;
            if (keyMarket == MarketType.UNDEFINED || keyMarket == MarketType.INACTIVE) revert InvalidKeyMarket();

            /// Get the EIP712 digest of the provided bid.
            bytes32 bidHash = _hashBid(bid);

            /// Checks: Determine if the bid has already been filled.
            if (bidStatus[bidHash] != Status.OPEN) revert InvalidBidStatus();

            /// Checks: Confirm that the signature attached matches the order signer.
            if (bidHash.recover(signature) != bid.maker) revert SignerNotMaker();

            /// Checks: Ensure bid start time has elapsed.
            if (block.timestamp < bid.startTime) revert InactiveOrderOrBid();

            /// Checks: Ensure bid end time hasn't passed.
            if (block.timestamp > bid.endTime) revert ExpiredOrderOrBid();

            /// Acknowledge the bid will be filled.
            bidStatus[bidHash] = Status.FILLED;

            /// Transfer assets to the bid maker.
            IERC1155(address(keys)).safeTransferFrom(msg.sender, bid.maker, bid.keyId, bid.amount, "");

            /// Caclulate total payable royalties.
            uint256 payableRoyalties = bid.royalties.length == 0 ? 0 : _calculateRoyaltyPayment(bid.royalties);

            /// Calculate protocol fee.
            uint256 calculatedFee = bid.price * bid.protocolFee / _BASIS_POINTS;
            uint256 takerEarnings = bid.price - calculatedFee - payableRoyalties;

            /// Pay protocol fee.
            WETH.safeTransferFrom(bid.maker, feeReceiver, calculatedFee);

            /// Pay the royalties if any are due.
            if (payableRoyalties != 0) {
                for (uint256 j = 0; j < bid.royalties.length; j++) {
                    IKeyExchange.Royalties calldata royaltyInfo = bid.royalties[j];
                    if (royaltyInfo.receiver == address(0)) revert ZeroAddressInvalid();
                    WETH.safeTransferFrom(bid.maker, royaltyInfo.receiver, royaltyInfo.fee);
                }
            }

            /// Pay bid maker.
            WETH.safeTransferFrom(bid.maker, msg.sender, takerEarnings);

            /// Emit event to acknowledge the bid has been filled.
            emit BidFilled({ taker: msg.sender, bidHash: bidHash });

            unchecked { i++; }
        }
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function cancelOrders(Order[] calldata orders) external {
        /// Checks: Ensure a non-zero amount of orders have been specified.
        if (orders.length == 0) revert ZeroLengthArray();

        /// Iterate through each order.
        for (uint256 i = 0; i < orders.length;) {
            /// Cache order parameter.
            Order calldata order = orders[i];

            /// Checks: Ensure the caller is the maker of the order.
            if (order.maker != msg.sender) revert CallerNotMaker();

            /// Get the EIP712 digest of the provided order.
            bytes32 orderHash = _hashOrder(order);

            /// Checks: Ensure the order isn't already cancelled or filled.
            if (orderStatus[orderHash] != Status.OPEN) revert InvalidOrderStatus();

            /// Cancel the order by updating its status to cancelled.
            orderStatus[orderHash] = Status.CANCELLED;

            /// Emit event for order cancellation.
            emit OrderCancelled(orderHash);

            unchecked { i++; }
        }
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function cancelBids(Bid[] calldata bids) external {
        /// Checks: Ensure a non-zero amount of bids have been provided.
        if (bids.length == 0) revert ZeroLengthArray();

        /// Iterate through each bid.
        for (uint256 i = 0; i < bids.length;) {
            /// Cache bid parameter.
            Bid calldata bid = bids[i];

            /// Checks: Ensure the caller is the maker of the bid.
            if (bid.maker != msg.sender) revert CallerNotMaker();

            /// Get the EIP712 digest of the provided bid.
            bytes32 bidHash = _hashBid(bid);

            /// Checks: Ensure the bid isn't cancelled of filled.
            if (bidStatus[bidHash] != Status.OPEN) revert InvalidBidStatus();

            /// Cancel the bid by updating its status.
            bidStatus[bidHash] = Status.CANCELLED;

            /// Emit event for bid cancellation.
            emit BidCancelled(bidHash);

            unchecked { i++; }
        }
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function executeBuyBack(uint256 keyId, address[] calldata holders) external payable nonReentrant {
        /// Cache key configuration in memory.
        KeyConfig memory keyConfig = keys.getKeyConfig(keyId);

        /// Checks: Ensure the caller is the original creator of the keys.
        if (msg.sender != keyConfig.creator) revert CallerNotKeyCreator();

        /// Checks: Ensure a valid number of holders or amounts have been provided.
        if (holders.length == 0) revert ZeroLengthArray();

        /// Copy key terms in to memory.
        KeyTerms memory terms = _keyTerms[keyId];

        /// Checks: Ensure buy out terms have been set.
        if (terms.market != MarketType.BUYOUT) revert KeyNotBuyOutMarket();

        /// Reclaim all the keys from the provided holders.
        _reclaimKeys({ keyId: keyId, keyPrice: terms.buyBack, holders: holders });

        /// Checks: Ensure all keys were successfully transferred to the holder.
        if (IERC1155(address(keys)).balanceOf(msg.sender, keyId) != keyConfig.supply) revert BuyBackFailed();

        /// Set key terms to inactive to prevent further trading.
        _keyTerms[keyId] = KeyTerms({ market: MarketType.INACTIVE, buyBack: 0, reserve: 0 });

        emit BuyOutExecuted({ caller: msg.sender, keyId: keyId });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function buyAtReserve(uint256 keyId, address[] calldata holders) external payable checkCaller nonReentrant {
        /// Checks: Ensure a valid number of holders have been provided.
        if (holders.length == 0) revert ZeroLengthArray();

        /// Copy key terms in to memory.
        KeyTerms memory terms = _keyTerms[keyId];

        /// Checks: Ensure buy out terms have been set.
        if (terms.market != MarketType.BUYOUT) revert KeyNotBuyOutMarket();

        /// Reclaim all the keys from the provided holders.
        _reclaimKeys({ keyId: keyId, keyPrice: terms.reserve, holders: holders });

        /// Checks: Ensure all keys were successfully transferred to the holder.
        uint256 maxSupply = keys.getKeyConfig(keyId).supply;
        if (IERC1155(address(keys)).balanceOf(msg.sender, keyId) != maxSupply) revert BuyBackFailed();

        /// Set key terms to inactive to prevent further trading.
        _keyTerms[keyId] = KeyTerms({ market: MarketType.INACTIVE, buyBack: 0, reserve: 0 });

        emit ReserveBuyOut({ caller: msg.sender, keyId: keyId });
    }

    /**
     * @inheritdoc IKeyExchange
     * @dev This function MUST be called by the original key creator before any trading
     * can be facilitated with the associated key ID.
     */
    function setKeyTerms(uint256 keyId, KeyTerms calldata finalTerms) external checkCaller {
        /// Checks: Ensure that multi-asset vault keys can be traded.
        KeyConfig memory keyConfig = keys.getKeyConfig(keyId);
        if (!multiKeysTradable && keyConfig.vaultType == VaultType.MULTI) revert MultiAssetKeysRestricted();

        /// Checks: Ensure the caller is the original creator of the keys.
        if (msg.sender != keyConfig.creator) revert CallerNotKeyCreator();

        /// Checks: Ensure that a valid market type has been provided.
        if (finalTerms.market == MarketType.UNDEFINED || finalTerms.market == MarketType.INACTIVE) {
            revert InvalidMarketType();
        }

        /// Checks: Ensure key terms have not already been set.
        if (_keyTerms[keyId].market != MarketType.UNDEFINED) revert KeyTermsDefined();

        if (finalTerms.market == MarketType.FREE) {
            /// Checks: Ensure that buy back and final terms pricing is zero for FREE market.
            if (finalTerms.buyBack != 0 || finalTerms.reserve != 0) revert InvalidFreeMarketTerms();
        } else {
            /// Checks: Ensure that buy back and final terms pricing is non-zero for BUYOUT market.
            if (finalTerms.buyBack == 0 || finalTerms.reserve == 0) revert InvalidBuyOutTerms();

            /// Checks: Ensure the buy back price is greater than the reserve price.
            if (finalTerms.buyBack > finalTerms.reserve) revert BuyBackExceedsReserve();
        }

        /// Set the buy out terms in storage.
        _keyTerms[keyId] = finalTerms;

        emit KeyTermsSet({ keyId: keyId, keyTerms: finalTerms });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function toggleMultiKeyTrading() external onlyRoles(AccessRoles.ADMIN_ROLE) {
        multiKeysTradable = !multiKeysTradable;
        emit MultiKeyTradingUpdated({ newStatus: multiKeysTradable });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function toggleAllowRestrictedUsers() external onlyRoles(AccessRoles.ADMIN_ROLE) {
        allowRestrictedUsers = !allowRestrictedUsers;
        emit RestrictedUserAccessUpdated({ newStatus: allowRestrictedUsers });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function setProtocolFee(uint256 newProtocolFee) external onlyRoles(AccessRoles.ADMIN_ROLE) {
        if (newProtocolFee > _BASIS_POINTS) revert FeeExceedsBps();
        uint256 oldProtocolFee = protocolFee;
        protocolFee = newProtocolFee;
        emit ProtocolFeeUpdated({ oldFee: oldProtocolFee, newFee: newProtocolFee });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function setFeeReceiver(address newFeeReceiver) external onlyRoles(AccessRoles.ADMIN_ROLE) {
        if (newFeeReceiver == address(0)) revert ZeroAddressInvalid();
        address oldFeeReceiver = feeReceiver;
        feeReceiver = newFeeReceiver;
        emit FeeReceiverUpdated({ oldFeeReceiver: oldFeeReceiver, newFeeReceiver: newFeeReceiver });
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function keyTerms(uint256 keyId) external view returns (KeyTerms memory) {
        return _keyTerms[keyId];
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function incrementNonce() external {
        _incrementNonce();
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function getNonce(address account) external view returns (uint256) {
        return _getNonce(account);
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function hashOrder(Order calldata order) external view returns (bytes32) {
        return _hashOrder(order);
    }

    /**
     * @inheritdoc IKeyExchange
     */
    function hashBid(Bid calldata bid) external view returns (bytes32) {
        return _hashBid(bid);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      VERSION CONTROL                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    function nameAndVersion() external pure returns (string memory, string memory) {
        return _domainNameAndVersion();
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EIP712                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Overriden as required in Solady EIP712 documentation.
     */
    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {
        name = "Key Exchange";
        version = "1.0";
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       INTERNAL LOGIC                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to determine if the caller has valid access to use the Key Exchange. It shouldn't matter if the
     * caller has the `BLOCKED` access type as all key transfers will revert if so.
     */
    function _checkAccess(address account) internal view {
        IAccessRegistry.AccessType accessType = accessRegistry.accessType(account);
        if (accessType == IAccessRegistry.AccessType.RESTRICTED && !allowRestrictedUsers) revert Restricted();
    }

    /**
     * Function used to reclaim keys from the provided holders and distribute the calculated amount of earnings.
     */
    function _reclaimKeys(uint256 keyId, uint256 keyPrice, address[] calldata holders) internal {
        /// Push original `msg.value` on to the stack.
        uint256 msgValue = msg.value;

        for (uint256 i = 0; i < holders.length;) {
            address holder = holders[i];
            uint256 keyBalance = IERC1155(address(keys)).balanceOf(holder, keyId);
            if (keyBalance == 0) revert NoKeysHeld();

            /// Calculate the earnings to be distributed.
            uint256 earnings = keyPrice * keyBalance;
            if (earnings > msgValue) revert InvalidNativeTokenAmount();
            msgValue -= earnings;

            /// Check if the keys held by the holder are lended and distribute earnings accordingly.
            IKeys.LendingTerms memory lendingTerms = keys.activeLends(holder, keyId);

            if (lendingTerms.amount == 0) {
                (bool success,) = holder.call{ value: earnings }("");
                if (!success) revert NativeTransferFailed();
            } else {
                /// Clear the associated lend to allow for key transfers after earnings distribution. Doing so
                /// avoids the transaction reverting with `CannotTransferLendedKeys`.
                keys.clearLendingTerms({ lendee: holder, keyId: keyId });

                /// If all keys held by the holder are lended, distribute the earnings to the original lender.
                if (lendingTerms.amount == keyBalance) {
                    (bool success,) = lendingTerms.lender.call{ value: earnings }("");
                    if (!success) revert NativeTransferFailed();

                    /// Otherwise, distribute earnings to both the lender and holder.
                } else {
                    uint256 holderEarnings = keyPrice * (keyBalance - lendingTerms.amount);

                    (bool success,) = holder.call{ value: holderEarnings }("");
                    if (!success) revert NativeTransferFailed();

                    (success,) = lendingTerms.lender.call{ value: earnings - holderEarnings }("");
                    if (!success) revert NativeTransferFailed();
                }
            }

            /// Transfer keys to the caller.
            IERC1155(address(keys)).safeTransferFrom(holder, msg.sender, keyId, keyBalance, "");

            unchecked { i++; }
        }

        /// Refund any remaining native token to the caller.
        if (msgValue > 0) {
            (bool success,) = msg.sender.call{ value: msgValue }("");
            if (!success) revert NativeTransferFailed();
        }
    }

    /**
     * Function used to calculate the royalty payments to each of the respective parties.
     */
    function _calculateRoyaltyPayment(IKeyExchange.Royalties[] calldata royalties) internal pure returns (uint256) {
        uint256 royaltySum = 0;
        for (uint256 i = 0; i < royalties.length;) {
            royaltySum += royalties[i].fee;
            unchecked { i++; }
        }
        return royaltySum;
    }

    /**
     * Function used to pay royalties to the respective parties.
     */
    function _payRoyaltiesWithNativeToken(IKeyExchange.Royalties[] calldata royalties) internal {
        for (uint256 i = 0; i < royalties.length;) {
            IKeyExchange.Royalties calldata royaltyInfo = royalties[i];
            if (royaltyInfo.receiver == address(0)) revert ZeroAddressInvalid();

            /// Wraps the royalty fee to WETH if the native call fails.
            (bool success,) = royaltyInfo.receiver.call{ gas: _ROYALTY_GAS_STIPEND, value: royaltyInfo.fee }("");
            if (!success) {
                IWETH(address(WETH)).deposit{ value: royaltyInfo.fee }();
                WETH.safeTransfer({ to: royaltyInfo.receiver, value: royaltyInfo.fee });
            }

            unchecked { i++; }
        }
    }
}

interface IWETH {
    function deposit() external payable;
}

// File: lib/solady/src/auth/OwnableRoles.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from "./Ownable.sol";

/// @notice Simple single owner and multiroles authorization mixin.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)
/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)
/// for compatibility, the nomenclature for the 2-step ownership handover and roles
/// may be unique to this codebase.
abstract contract OwnableRoles is Ownable {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The `user`'s roles is updated to `roles`.
    /// Each bit of `roles` represents whether the role is set.
    event RolesUpdated(address indexed user, uint256 indexed roles);

    /// @dev `keccak256(bytes("RolesUpdated(address,uint256)"))`.
    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =
        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The role slot of `user` is given by:
    /// ```
    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))
    ///     let roleSlot := keccak256(0x00, 0x20)
    /// ```
    /// This automatically ignores the upper bits of the `user` in case
    /// they are not clean, as well as keep the `keccak256` under 32-bytes.
    ///
    /// Note: This is equal to `_OWNER_SLOT_NOT` in for gas efficiency.
    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     INTERNAL FUNCTIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Grants the roles directly without authorization guard.
    /// Each bit of `roles` represents the role to turn on.
    function _grantRoles(address user, uint256 roles) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, user)
            let roleSlot := keccak256(0x0c, 0x20)
            // Load the current value and `or` it with `roles`.
            roles := or(sload(roleSlot), roles)
            // Store the new value.
            sstore(roleSlot, roles)
            // Emit the {RolesUpdated} event.
            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)
        }
    }

    /// @dev Removes the roles directly without authorization guard.
    /// Each bit of `roles` represents the role to turn off.
    function _removeRoles(address user, uint256 roles) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, user)
            let roleSlot := keccak256(0x0c, 0x20)
            // Load the current value.
            let currentRoles := sload(roleSlot)
            // Use `and` to compute the intersection of `currentRoles` and `roles`,
            // `xor` it with `currentRoles` to flip the bits in the intersection.
            roles := xor(currentRoles, and(currentRoles, roles))
            // Then, store the new value.
            sstore(roleSlot, roles)
            // Emit the {RolesUpdated} event.
            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)
        }
    }

    /// @dev Throws if the sender does not have any of the `roles`.
    function _checkRoles(uint256 roles) internal view virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, caller())
            // Load the stored value, and if the `and` intersection
            // of the value and `roles` is zero, revert.
            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {
                mstore(0x00, 0x82b42900) // `Unauthorized()`.
                revert(0x1c, 0x04)
            }
        }
    }

    /// @dev Throws if the sender is not the owner,
    /// and does not have any of the `roles`.
    /// Checks for ownership first, then lazily checks for roles.
    function _checkOwnerOrRoles(uint256 roles) internal view virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // If the caller is not the stored owner.
            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.
            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {
                // Compute the role slot.
                mstore(0x0c, _ROLE_SLOT_SEED)
                mstore(0x00, caller())
                // Load the stored value, and if the `and` intersection
                // of the value and `roles` is zero, revert.
                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {
                    mstore(0x00, 0x82b42900) // `Unauthorized()`.
                    revert(0x1c, 0x04)
                }
            }
        }
    }

    /// @dev Throws if the sender does not have any of the `roles`,
    /// and is not the owner.
    /// Checks for roles first, then lazily checks for ownership.
    function _checkRolesOrOwner(uint256 roles) internal view virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, caller())
            // Load the stored value, and if the `and` intersection
            // of the value and `roles` is zero, revert.
            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {
                // If the caller is not the stored owner.
                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.
                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {
                    mstore(0x00, 0x82b42900) // `Unauthorized()`.
                    revert(0x1c, 0x04)
                }
            }
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  PUBLIC UPDATE FUNCTIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Allows the owner to grant `user` `roles`.
    /// If the `user` already has a role, then it will be an no-op for the role.
    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {
        _grantRoles(user, roles);
    }

    /// @dev Allows the owner to remove `user` `roles`.
    /// If the `user` does not have a role, then it will be an no-op for the role.
    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {
        _removeRoles(user, roles);
    }

    /// @dev Allow the caller to remove their own roles.
    /// If the caller does not have a role, then it will be an no-op for the role.
    function renounceRoles(uint256 roles) public payable virtual {
        _removeRoles(msg.sender, roles);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   PUBLIC READ FUNCTIONS                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns whether `user` has any of `roles`.
    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, user)
            // Load the stored value, and set the result to whether the
            // `and` intersection of the value and `roles` is not zero.
            result := iszero(iszero(and(sload(keccak256(0x0c, 0x20)), roles)))
        }
    }

    /// @dev Returns whether `user` has all of `roles`.
    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, user)
            // Whether the stored value is contains all the set bits in `roles`.
            result := eq(and(sload(keccak256(0x0c, 0x20)), roles), roles)
        }
    }

    /// @dev Returns the roles of `user`.
    function rolesOf(address user) public view virtual returns (uint256 roles) {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the role slot.
            mstore(0x0c, _ROLE_SLOT_SEED)
            mstore(0x00, user)
            // Load the stored value.
            roles := sload(keccak256(0x0c, 0x20))
        }
    }

    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.
    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.
    /// Not recommended to be called on-chain.
    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {
        /// @solidity memory-safe-assembly
        assembly {
            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {
                // We don't need to mask the values of `ordinals`, as Solidity
                // cleans dirty upper bits when storing variables into memory.
                roles := or(shl(mload(add(ordinals, i)), 1), roles)
            }
        }
    }

    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.
    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.
    /// Not recommended to be called on-chain.
    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {
        /// @solidity memory-safe-assembly
        assembly {
            // Grab the pointer to the free memory.
            ordinals := mload(0x40)
            let ptr := add(ordinals, 0x20)
            let o := 0
            // The absence of lookup tables, De Bruijn, etc., here is intentional for
            // smaller bytecode, as this function is not meant to be called on-chain.
            for { let t := roles } 1 {} {
                mstore(ptr, o)
                // `shr` 5 is equivalent to multiplying by 0x20.
                // Push back into the ordinals array if the bit is set.
                ptr := add(ptr, shl(5, and(t, 1)))
                o := add(o, 1)
                t := shr(o, roles)
                if iszero(t) { break }
            }
            // Store the length of `ordinals`.
            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))
            // Allocate the memory.
            mstore(0x40, ptr)
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         MODIFIERS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Marks a function as only callable by an account with `roles`.
    modifier onlyRoles(uint256 roles) virtual {
        _checkRoles(roles);
        _;
    }

    /// @dev Marks a function as only callable by the owner or by an account
    /// with `roles`. Checks for ownership first, then lazily checks for roles.
    modifier onlyOwnerOrRoles(uint256 roles) virtual {
        _checkOwnerOrRoles(roles);
        _;
    }

    /// @dev Marks a function as only callable by an account with `roles`
    /// or the owner. Checks for roles first, then lazily checks for ownership.
    modifier onlyRolesOrOwner(uint256 roles) virtual {
        _checkRolesOrOwner(roles);
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       ROLE CONSTANTS                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // IYKYK

    uint256 internal constant _ROLE_0 = 1 << 0;
    uint256 internal constant _ROLE_1 = 1 << 1;
    uint256 internal constant _ROLE_2 = 1 << 2;
    uint256 internal constant _ROLE_3 = 1 << 3;
    uint256 internal constant _ROLE_4 = 1 << 4;
    uint256 internal constant _ROLE_5 = 1 << 5;
    uint256 internal constant _ROLE_6 = 1 << 6;
    uint256 internal constant _ROLE_7 = 1 << 7;
    uint256 internal constant _ROLE_8 = 1 << 8;
    uint256 internal constant _ROLE_9 = 1 << 9;
    uint256 internal constant _ROLE_10 = 1 << 10;
    uint256 internal constant _ROLE_11 = 1 << 11;
    uint256 internal constant _ROLE_12 = 1 << 12;
    uint256 internal constant _ROLE_13 = 1 << 13;
    uint256 internal constant _ROLE_14 = 1 << 14;
    uint256 internal constant _ROLE_15 = 1 << 15;
    uint256 internal constant _ROLE_16 = 1 << 16;
    uint256 internal constant _ROLE_17 = 1 << 17;
    uint256 internal constant _ROLE_18 = 1 << 18;
    uint256 internal constant _ROLE_19 = 1 << 19;
    uint256 internal constant _ROLE_20 = 1 << 20;
    uint256 internal constant _ROLE_21 = 1 << 21;
    uint256 internal constant _ROLE_22 = 1 << 22;
    uint256 internal constant _ROLE_23 = 1 << 23;
    uint256 internal constant _ROLE_24 = 1 << 24;
    uint256 internal constant _ROLE_25 = 1 << 25;
    uint256 internal constant _ROLE_26 = 1 << 26;
    uint256 internal constant _ROLE_27 = 1 << 27;
    uint256 internal constant _ROLE_28 = 1 << 28;
    uint256 internal constant _ROLE_29 = 1 << 29;
    uint256 internal constant _ROLE_30 = 1 << 30;
    uint256 internal constant _ROLE_31 = 1 << 31;
    uint256 internal constant _ROLE_32 = 1 << 32;
    uint256 internal constant _ROLE_33 = 1 << 33;
    uint256 internal constant _ROLE_34 = 1 << 34;
    uint256 internal constant _ROLE_35 = 1 << 35;
    uint256 internal constant _ROLE_36 = 1 << 36;
    uint256 internal constant _ROLE_37 = 1 << 37;
    uint256 internal constant _ROLE_38 = 1 << 38;
    uint256 internal constant _ROLE_39 = 1 << 39;
    uint256 internal constant _ROLE_40 = 1 << 40;
    uint256 internal constant _ROLE_41 = 1 << 41;
    uint256 internal constant _ROLE_42 = 1 << 42;
    uint256 internal constant _ROLE_43 = 1 << 43;
    uint256 internal constant _ROLE_44 = 1 << 44;
    uint256 internal constant _ROLE_45 = 1 << 45;
    uint256 internal constant _ROLE_46 = 1 << 46;
    uint256 internal constant _ROLE_47 = 1 << 47;
    uint256 internal constant _ROLE_48 = 1 << 48;
    uint256 internal constant _ROLE_49 = 1 << 49;
    uint256 internal constant _ROLE_50 = 1 << 50;
    uint256 internal constant _ROLE_51 = 1 << 51;
    uint256 internal constant _ROLE_52 = 1 << 52;
    uint256 internal constant _ROLE_53 = 1 << 53;
    uint256 internal constant _ROLE_54 = 1 << 54;
    uint256 internal constant _ROLE_55 = 1 << 55;
    uint256 internal constant _ROLE_56 = 1 << 56;
    uint256 internal constant _ROLE_57 = 1 << 57;
    uint256 internal constant _ROLE_58 = 1 << 58;
    uint256 internal constant _ROLE_59 = 1 << 59;
    uint256 internal constant _ROLE_60 = 1 << 60;
    uint256 internal constant _ROLE_61 = 1 << 61;
    uint256 internal constant _ROLE_62 = 1 << 62;
    uint256 internal constant _ROLE_63 = 1 << 63;
    uint256 internal constant _ROLE_64 = 1 << 64;
    uint256 internal constant _ROLE_65 = 1 << 65;
    uint256 internal constant _ROLE_66 = 1 << 66;
    uint256 internal constant _ROLE_67 = 1 << 67;
    uint256 internal constant _ROLE_68 = 1 << 68;
    uint256 internal constant _ROLE_69 = 1 << 69;
    uint256 internal constant _ROLE_70 = 1 << 70;
    uint256 internal constant _ROLE_71 = 1 << 71;
    uint256 internal constant _ROLE_72 = 1 << 72;
    uint256 internal constant _ROLE_73 = 1 << 73;
    uint256 internal constant _ROLE_74 = 1 << 74;
    uint256 internal constant _ROLE_75 = 1 << 75;
    uint256 internal constant _ROLE_76 = 1 << 76;
    uint256 internal constant _ROLE_77 = 1 << 77;
    uint256 internal constant _ROLE_78 = 1 << 78;
    uint256 internal constant _ROLE_79 = 1 << 79;
    uint256 internal constant _ROLE_80 = 1 << 80;
    uint256 internal constant _ROLE_81 = 1 << 81;
    uint256 internal constant _ROLE_82 = 1 << 82;
    uint256 internal constant _ROLE_83 = 1 << 83;
    uint256 internal constant _ROLE_84 = 1 << 84;
    uint256 internal constant _ROLE_85 = 1 << 85;
    uint256 internal constant _ROLE_86 = 1 << 86;
    uint256 internal constant _ROLE_87 = 1 << 87;
    uint256 internal constant _ROLE_88 = 1 << 88;
    uint256 internal constant _ROLE_89 = 1 << 89;
    uint256 internal constant _ROLE_90 = 1 << 90;
    uint256 internal constant _ROLE_91 = 1 << 91;
    uint256 internal constant _ROLE_92 = 1 << 92;
    uint256 internal constant _ROLE_93 = 1 << 93;
    uint256 internal constant _ROLE_94 = 1 << 94;
    uint256 internal constant _ROLE_95 = 1 << 95;
    uint256 internal constant _ROLE_96 = 1 << 96;
    uint256 internal constant _ROLE_97 = 1 << 97;
    uint256 internal constant _ROLE_98 = 1 << 98;
    uint256 internal constant _ROLE_99 = 1 << 99;
    uint256 internal constant _ROLE_100 = 1 << 100;
    uint256 internal constant _ROLE_101 = 1 << 101;
    uint256 internal constant _ROLE_102 = 1 << 102;
    uint256 internal constant _ROLE_103 = 1 << 103;
    uint256 internal constant _ROLE_104 = 1 << 104;
    uint256 internal constant _ROLE_105 = 1 << 105;
    uint256 internal constant _ROLE_106 = 1 << 106;
    uint256 internal constant _ROLE_107 = 1 << 107;
    uint256 internal constant _ROLE_108 = 1 << 108;
    uint256 internal constant _ROLE_109 = 1 << 109;
    uint256 internal constant _ROLE_110 = 1 << 110;
    uint256 internal constant _ROLE_111 = 1 << 111;
    uint256 internal constant _ROLE_112 = 1 << 112;
    uint256 internal constant _ROLE_113 = 1 << 113;
    uint256 internal constant _ROLE_114 = 1 << 114;
    uint256 internal constant _ROLE_115 = 1 << 115;
    uint256 internal constant _ROLE_116 = 1 << 116;
    uint256 internal constant _ROLE_117 = 1 << 117;
    uint256 internal constant _ROLE_118 = 1 << 118;
    uint256 internal constant _ROLE_119 = 1 << 119;
    uint256 internal constant _ROLE_120 = 1 << 120;
    uint256 internal constant _ROLE_121 = 1 << 121;
    uint256 internal constant _ROLE_122 = 1 << 122;
    uint256 internal constant _ROLE_123 = 1 << 123;
    uint256 internal constant _ROLE_124 = 1 << 124;
    uint256 internal constant _ROLE_125 = 1 << 125;
    uint256 internal constant _ROLE_126 = 1 << 126;
    uint256 internal constant _ROLE_127 = 1 << 127;
    uint256 internal constant _ROLE_128 = 1 << 128;
    uint256 internal constant _ROLE_129 = 1 << 129;
    uint256 internal constant _ROLE_130 = 1 << 130;
    uint256 internal constant _ROLE_131 = 1 << 131;
    uint256 internal constant _ROLE_132 = 1 << 132;
    uint256 internal constant _ROLE_133 = 1 << 133;
    uint256 internal constant _ROLE_134 = 1 << 134;
    uint256 internal constant _ROLE_135 = 1 << 135;
    uint256 internal constant _ROLE_136 = 1 << 136;
    uint256 internal constant _ROLE_137 = 1 << 137;
    uint256 internal constant _ROLE_138 = 1 << 138;
    uint256 internal constant _ROLE_139 = 1 << 139;
    uint256 internal constant _ROLE_140 = 1 << 140;
    uint256 internal constant _ROLE_141 = 1 << 141;
    uint256 internal constant _ROLE_142 = 1 << 142;
    uint256 internal constant _ROLE_143 = 1 << 143;
    uint256 internal constant _ROLE_144 = 1 << 144;
    uint256 internal constant _ROLE_145 = 1 << 145;
    uint256 internal constant _ROLE_146 = 1 << 146;
    uint256 internal constant _ROLE_147 = 1 << 147;
    uint256 internal constant _ROLE_148 = 1 << 148;
    uint256 internal constant _ROLE_149 = 1 << 149;
    uint256 internal constant _ROLE_150 = 1 << 150;
    uint256 internal constant _ROLE_151 = 1 << 151;
    uint256 internal constant _ROLE_152 = 1 << 152;
    uint256 internal constant _ROLE_153 = 1 << 153;
    uint256 internal constant _ROLE_154 = 1 << 154;
    uint256 internal constant _ROLE_155 = 1 << 155;
    uint256 internal constant _ROLE_156 = 1 << 156;
    uint256 internal constant _ROLE_157 = 1 << 157;
    uint256 internal constant _ROLE_158 = 1 << 158;
    uint256 internal constant _ROLE_159 = 1 << 159;
    uint256 internal constant _ROLE_160 = 1 << 160;
    uint256 internal constant _ROLE_161 = 1 << 161;
    uint256 internal constant _ROLE_162 = 1 << 162;
    uint256 internal constant _ROLE_163 = 1 << 163;
    uint256 internal constant _ROLE_164 = 1 << 164;
    uint256 internal constant _ROLE_165 = 1 << 165;
    uint256 internal constant _ROLE_166 = 1 << 166;
    uint256 internal constant _ROLE_167 = 1 << 167;
    uint256 internal constant _ROLE_168 = 1 << 168;
    uint256 internal constant _ROLE_169 = 1 << 169;
    uint256 internal constant _ROLE_170 = 1 << 170;
    uint256 internal constant _ROLE_171 = 1 << 171;
    uint256 internal constant _ROLE_172 = 1 << 172;
    uint256 internal constant _ROLE_173 = 1 << 173;
    uint256 internal constant _ROLE_174 = 1 << 174;
    uint256 internal constant _ROLE_175 = 1 << 175;
    uint256 internal constant _ROLE_176 = 1 << 176;
    uint256 internal constant _ROLE_177 = 1 << 177;
    uint256 internal constant _ROLE_178 = 1 << 178;
    uint256 internal constant _ROLE_179 = 1 << 179;
    uint256 internal constant _ROLE_180 = 1 << 180;
    uint256 internal constant _ROLE_181 = 1 << 181;
    uint256 internal constant _ROLE_182 = 1 << 182;
    uint256 internal constant _ROLE_183 = 1 << 183;
    uint256 internal constant _ROLE_184 = 1 << 184;
    uint256 internal constant _ROLE_185 = 1 << 185;
    uint256 internal constant _ROLE_186 = 1 << 186;
    uint256 internal constant _ROLE_187 = 1 << 187;
    uint256 internal constant _ROLE_188 = 1 << 188;
    uint256 internal constant _ROLE_189 = 1 << 189;
    uint256 internal constant _ROLE_190 = 1 << 190;
    uint256 internal constant _ROLE_191 = 1 << 191;
    uint256 internal constant _ROLE_192 = 1 << 192;
    uint256 internal constant _ROLE_193 = 1 << 193;
    uint256 internal constant _ROLE_194 = 1 << 194;
    uint256 internal constant _ROLE_195 = 1 << 195;
    uint256 internal constant _ROLE_196 = 1 << 196;
    uint256 internal constant _ROLE_197 = 1 << 197;
    uint256 internal constant _ROLE_198 = 1 << 198;
    uint256 internal constant _ROLE_199 = 1 << 199;
    uint256 internal constant _ROLE_200 = 1 << 200;
    uint256 internal constant _ROLE_201 = 1 << 201;
    uint256 internal constant _ROLE_202 = 1 << 202;
    uint256 internal constant _ROLE_203 = 1 << 203;
    uint256 internal constant _ROLE_204 = 1 << 204;
    uint256 internal constant _ROLE_205 = 1 << 205;
    uint256 internal constant _ROLE_206 = 1 << 206;
    uint256 internal constant _ROLE_207 = 1 << 207;
    uint256 internal constant _ROLE_208 = 1 << 208;
    uint256 internal constant _ROLE_209 = 1 << 209;
    uint256 internal constant _ROLE_210 = 1 << 210;
    uint256 internal constant _ROLE_211 = 1 << 211;
    uint256 internal constant _ROLE_212 = 1 << 212;
    uint256 internal constant _ROLE_213 = 1 << 213;
    uint256 internal constant _ROLE_214 = 1 << 214;
    uint256 internal constant _ROLE_215 = 1 << 215;
    uint256 internal constant _ROLE_216 = 1 << 216;
    uint256 internal constant _ROLE_217 = 1 << 217;
    uint256 internal constant _ROLE_218 = 1 << 218;
    uint256 internal constant _ROLE_219 = 1 << 219;
    uint256 internal constant _ROLE_220 = 1 << 220;
    uint256 internal constant _ROLE_221 = 1 << 221;
    uint256 internal constant _ROLE_222 = 1 << 222;
    uint256 internal constant _ROLE_223 = 1 << 223;
    uint256 internal constant _ROLE_224 = 1 << 224;
    uint256 internal constant _ROLE_225 = 1 << 225;
    uint256 internal constant _ROLE_226 = 1 << 226;
    uint256 internal constant _ROLE_227 = 1 << 227;
    uint256 internal constant _ROLE_228 = 1 << 228;
    uint256 internal constant _ROLE_229 = 1 << 229;
    uint256 internal constant _ROLE_230 = 1 << 230;
    uint256 internal constant _ROLE_231 = 1 << 231;
    uint256 internal constant _ROLE_232 = 1 << 232;
    uint256 internal constant _ROLE_233 = 1 << 233;
    uint256 internal constant _ROLE_234 = 1 << 234;
    uint256 internal constant _ROLE_235 = 1 << 235;
    uint256 internal constant _ROLE_236 = 1 << 236;
    uint256 internal constant _ROLE_237 = 1 << 237;
    uint256 internal constant _ROLE_238 = 1 << 238;
    uint256 internal constant _ROLE_239 = 1 << 239;
    uint256 internal constant _ROLE_240 = 1 << 240;
    uint256 internal constant _ROLE_241 = 1 << 241;
    uint256 internal constant _ROLE_242 = 1 << 242;
    uint256 internal constant _ROLE_243 = 1 << 243;
    uint256 internal constant _ROLE_244 = 1 << 244;
    uint256 internal constant _ROLE_245 = 1 << 245;
    uint256 internal constant _ROLE_246 = 1 << 246;
    uint256 internal constant _ROLE_247 = 1 << 247;
    uint256 internal constant _ROLE_248 = 1 << 248;
    uint256 internal constant _ROLE_249 = 1 << 249;
    uint256 internal constant _ROLE_250 = 1 << 250;
    uint256 internal constant _ROLE_251 = 1 << 251;
    uint256 internal constant _ROLE_252 = 1 << 252;
    uint256 internal constant _ROLE_253 = 1 << 253;
    uint256 internal constant _ROLE_254 = 1 << 254;
    uint256 internal constant _ROLE_255 = 1 << 255;
}


// File: lib/solady/src/utils/ECDSA.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Gas optimized ECDSA wrapper.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)
/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)
library ECDSA {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CUSTOM ERRORS                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The signature is invalid.
    error InvalidSignature();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CONSTANTS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The number which `s` must be less than in order for
    /// the signature to be non-malleable.
    bytes32 private constant _MALLEABILITY_THRESHOLD_PLUS_ONE =
        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    RECOVERY OPERATIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // Note: as of Solady version 0.0.68, these functions will
    // revert upon recovery failure for more safety by default.

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the `signature`.
    ///
    /// This function does NOT accept EIP-2098 short form signatures.
    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098
    /// short form signatures instead.
    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.
            mstore(0x40, mload(add(signature, 0x20))) // `r`.
            mstore(0x60, mload(add(signature, 0x40))) // `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    and(
                        // If the signature is exactly 65 bytes in length.
                        eq(mload(signature), 65),
                        // If `s` in lower half order, such that the signature is not malleable.
                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)
                    ), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x00, // Start of output.
                    0x20 // Size of output.
                )
            )
            result := mload(0x00)
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            if iszero(returndatasize()) {
                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.
                revert(0x1c, 0x04)
            }
            mstore(0x60, 0) // Restore the zero slot.
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the `signature`.
    ///
    /// This function does NOT accept EIP-2098 short form signatures.
    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098
    /// short form signatures instead.
    function recoverCalldata(bytes32 hash, bytes calldata signature)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.
            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    and(
                        // If the signature is exactly 65 bytes in length.
                        eq(signature.length, 65),
                        // If `s` in lower half order, such that the signature is not malleable.
                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)
                    ), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x00, // Start of output.
                    0x20 // Size of output.
                )
            )
            result := mload(0x00)
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            if iszero(returndatasize()) {
                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.
                revert(0x1c, 0x04)
            }
            mstore(0x60, 0) // Restore the zero slot.
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the EIP-2098 short form signature defined by `r` and `vs`.
    ///
    /// This function only accepts EIP-2098 short form signatures.
    /// See: https://eips.ethereum.org/EIPS/eip-2098
    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, add(shr(255, vs), 27)) // `v`.
            mstore(0x40, r)
            mstore(0x60, shr(1, shl(1, vs))) // `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    // If `s` in lower half order, such that the signature is not malleable.
                    lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x00, // Start of output.
                    0x20 // Size of output.
                )
            )
            result := mload(0x00)
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            if iszero(returndatasize()) {
                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.
                revert(0x1c, 0x04)
            }
            mstore(0x60, 0) // Restore the zero slot.
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the signature defined by `v`, `r`, `s`.
    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, and(v, 0xff))
            mstore(0x40, r)
            mstore(0x60, s)
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    // If `s` in lower half order, such that the signature is not malleable.
                    lt(s, _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x00, // Start of output.
                    0x20 // Size of output.
                )
            )
            result := mload(0x00)
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            if iszero(returndatasize()) {
                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.
                revert(0x1c, 0x04)
            }
            mstore(0x60, 0) // Restore the zero slot.
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   TRY-RECOVER OPERATIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // WARNING!
    // These functions will NOT revert upon recovery failure.
    // Instead, they will return the zero address upon recovery failure.
    // It is critical that the returned address is NEVER compared against
    // a zero address (e.g. an uninitialized address variable).

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the `signature`.
    ///
    /// This function does NOT accept EIP-2098 short form signatures.
    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098
    /// short form signatures instead.
    function tryRecover(bytes32 hash, bytes memory signature)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.
            mstore(0x40, mload(add(signature, 0x20))) // `r`.
            mstore(0x60, mload(add(signature, 0x40))) // `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    and(
                        // If the signature is exactly 65 bytes in length.
                        eq(mload(signature), 65),
                        // If `s` in lower half order, such that the signature is not malleable.
                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)
                    ), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x40, // Start of output.
                    0x20 // Size of output.
                )
            )
            mstore(0x60, 0) // Restore the zero slot.
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            result := mload(xor(0x60, returndatasize()))
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the `signature`.
    ///
    /// This function does NOT accept EIP-2098 short form signatures.
    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098
    /// short form signatures instead.
    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.
            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    and(
                        // If the signature is exactly 65 bytes in length.
                        eq(signature.length, 65),
                        // If `s` in lower half order, such that the signature is not malleable.
                        lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE)
                    ), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x40, // Start of output.
                    0x20 // Size of output.
                )
            )
            mstore(0x60, 0) // Restore the zero slot.
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            result := mload(xor(0x60, returndatasize()))
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the EIP-2098 short form signature defined by `r` and `vs`.
    ///
    /// This function only accepts EIP-2098 short form signatures.
    /// See: https://eips.ethereum.org/EIPS/eip-2098
    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, add(shr(255, vs), 27)) // `v`.
            mstore(0x40, r)
            mstore(0x60, shr(1, shl(1, vs))) // `s`.
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    // If `s` in lower half order, such that the signature is not malleable.
                    lt(mload(0x60), _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x40, // Start of output.
                    0x20 // Size of output.
                )
            )
            mstore(0x60, 0) // Restore the zero slot.
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            result := mload(xor(0x60, returndatasize()))
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /// @dev Recovers the signer's address from a message digest `hash`,
    /// and the signature defined by `v`, `r`, `s`.
    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)
        internal
        view
        returns (address result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Cache the free memory pointer.
            mstore(0x00, hash)
            mstore(0x20, and(v, 0xff))
            mstore(0x40, r)
            mstore(0x60, s)
            pop(
                staticcall(
                    gas(), // Amount of gas left for the transaction.
                    // If `s` in lower half order, such that the signature is not malleable.
                    lt(s, _MALLEABILITY_THRESHOLD_PLUS_ONE), // Address of `ecrecover`.
                    0x00, // Start of input.
                    0x80, // Size of input.
                    0x40, // Start of output.
                    0x20 // Size of output.
                )
            )
            mstore(0x60, 0) // Restore the zero slot.
            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
            result := mload(xor(0x60, returndatasize()))
            mstore(0x40, m) // Restore the free memory pointer.
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     HASHING OPERATIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns an Ethereum Signed Message, created from a `hash`.
    /// This produces a hash corresponding to the one signed with the
    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)
    /// JSON-RPC method as part of EIP-191.
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x20, hash) // Store into scratch space for keccak256.
            mstore(0x00, "\x00\x00\x00\x00\x19Ethereum Signed Message:\n32") // 28 bytes.
            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.
        }
    }

    /// @dev Returns an Ethereum Signed Message, created from `s`.
    /// This produces a hash corresponding to the one signed with the
    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)
    /// JSON-RPC method as part of EIP-191.
    /// Note: Supports lengths of `s` up to 999999 bytes.
    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {
        /// @solidity memory-safe-assembly
        assembly {
            let sLength := mload(s)
            let o := 0x20
            mstore(o, "\x19Ethereum Signed Message:\n") // 26 bytes, zero-right-padded.
            mstore(0x00, 0x00)
            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.
            for { let temp := sLength } 1 {} {
                o := sub(o, 1)
                mstore8(o, add(48, mod(temp, 10)))
                temp := div(temp, 10)
                if iszero(temp) { break }
            }
            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.
            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.
            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))
            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.
            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))
            mstore(s, sLength) // Restore the length.
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   EMPTY CALLDATA HELPERS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns an empty calldata bytes.
    function emptySignature() internal pure returns (bytes calldata signature) {
        /// @solidity memory-safe-assembly
        assembly {
            signature.length := 0
        }
    }
}


// File: lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] calldata accounts,
        uint256[] calldata ids
    ) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    /**
     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    /**
     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }

    /**
     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }

    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
     * Revert on invalid signature.
     */
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}


// File: lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * `nonReentrant` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}


// File: src/access/AccessRoles.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/**
 * @title AccessRoles
 * @notice This library contains all the valid roles within the protocol. Roles have been defined to mimic
 * {Solady.OwnableRoles} roles.
 */
library AccessRoles {
    uint256 public constant ADMIN_ROLE = 1 << 0;
    uint256 public constant FACTORY_ROLE = 1 << 1; 
}

// File: src/handlers/TypeHasher.sol
// SPDX-License-Identifier: SegMint Code License 1.1
pragma solidity 0.8.19;

import { EIP712 } from "@solady/src/utils/EIP712.sol";
import { IKeyExchange } from "../interfaces/IKeyExchange.sol";

/**
 * @title TypeHasher
 * @notice Used to derive the EIP712 hash associated with Order/Bid types for {KeyExchange}.
 */
abstract contract TypeHasher is EIP712 {
    /// Royalties(address receiver,uint256 fee)
    bytes32 private constant _ROYALTIES_TYPEHASH = 0x2f5057decee872280b232f42dc21db20fd2f34148dcb1f26e39248197261978e;

    /// Order(uint256 price,address maker,address taker,uint256 keyId,uint256 amount,uint256 nonce,uint256 startTime,uint256 endTime,uint256 protocolFee,Royalties[] royalties)Royalties(address receiver,uint256 fee)
    bytes32 private constant _ORDER_TYPEHASH = 0x181555209a4040dc9b2401944efa8ca3b593b5fc3981fa4b4c4996bcea6c727f;

    /// Bid(address maker,uint256 price,uint256 keyId,uint256 amount,uint256 nonce,uint256 startTime,uint256 endTime,uint256 protocolFee,Royalties[] royalties)Royalties(address receiver,uint256 fee)
    bytes32 private constant _BID_TYPEHASH = 0x06c6c02a5759b468552d3e3ce52a9399e1ab78fb9194e4e0fed6b8f57aa1afee;

    /**
     * Function used to return the EIP712 hash of a order.
     */
    function _hashOrder(IKeyExchange.Order calldata order) internal view returns (bytes32) {
        /// forgefmt: disable-next-item
        return _hashTypedData(keccak256(abi.encode(
            _ORDER_TYPEHASH,
            order.price,
            order.maker,
            order.taker,
            order.keyId,
            order.amount,
            order.nonce,
            order.startTime,
            order.endTime,
            order.protocolFee,
            _hashRoyalties(order.royalties)
        )));
    }

    /**
     * Function used to return the EIP712 hash of a bid.
     */
    function _hashBid(IKeyExchange.Bid calldata bid) internal view returns (bytes32) {
        /// forgefmt: disable-next-item
        return _hashTypedData(keccak256(abi.encode(
            _BID_TYPEHASH,
            bid.maker,
            bid.price,
            bid.keyId,
            bid.amount,
            bid.nonce,
            bid.startTime,
            bid.endTime,
            bid.protocolFee,
            _hashRoyalties(bid.royalties)
        )));
    }

    /**
     * Function used to return the EIP712 hash of a royalty payment.
     */
    function _hashRoyalties(IKeyExchange.Royalties[] calldata royalties) internal pure returns (bytes32) {
        bytes32[] memory encodedRoyalties = new bytes32[](royalties.length);
        for (uint256 i = 0; i < royalties.length; i++) {
            IKeyExchange.Royalties memory royalty = royalties[i];
            encodedRoyalties[i] = keccak256(abi.encode(
                _ROYALTIES_TYPEHASH,
                royalty.receiver,
                royalty.fee
            ));
        }
        return keccak256(abi.encodePacked(encodedRoyalties));
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EIP712                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * As required in Solady EIP712 documentation.
     */
    function _domainNameAndVersion()
        internal
        pure
        virtual
        override
        returns (string memory name, string memory version)
    { }
}


// File: src/managers/NonceManager.sol
// SPDX-License-Identifier: SegMint Code License 1.1
pragma solidity 0.8.19;

/**
 * @title NonceManager
 * @notice Managers account nonces for the Key Exchange. Incrementing a user nonce invalidates
 * all orders and bids associated with the account. Inspired from SeaPorts `ReferenceCounterManager`.
 * ref: https://github.com/ProjectOpenSea/seaport/blob/main/reference/lib/ReferenceCounterManager.sol#L25
 */
abstract contract NonceManager {
    /**
     * Event for nonce increments.
     */
    event NonceUpdated(address indexed account, uint256 newNonce);

    /**
     * Mapping of an account to a nonce.
     */
    mapping(address account => uint256 nonce) internal _nonces;

    /**
     * Function used to increment the nonce associated with an account by a
     * quasi-random number. The reasoning for doing this in such a way is to
     * prevent orders from being activated if a future and predictable nonce is signed.
     */
    function _incrementNonce() internal {
        // Use second half of the previous block hash as a quasi-random number.
        uint256 quasiRandomNumber = uint256(blockhash(block.number - 1)) >> 128;

        // Retrieve the original counter value.
        uint256 originalNonce = _nonces[msg.sender];

        // Increment current counter for the supplied offerer.
        uint256 newNonce = quasiRandomNumber + originalNonce;

        // Update the counter with the new value.
        _nonces[msg.sender] = newNonce;

        // Emit nonce updated event.
        emit NonceUpdated({ account: msg.sender, newNonce: newNonce });
    }

    /**
     * Function used to view the current nonce associated with the account.
     * @param account Address to check the current nonce value of.
     */
    function _getNonce(address account) internal view returns (uint256) {
        return _nonces[account];
    }
}


// File: src/interfaces/IKeyExchange.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/**
 * @title IKeyExchange
 */
interface IKeyExchange {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Thrown when attempting to set the terms for a key that the caller did not create.
     */
    error CallerNotKeyCreator();

    /**
     * Thrown when attempting to set terms for a key that already has terms defined.
     */
    error KeyTermsDefined();

    /**
     * Thrown when attempting to trade a key that has no terms defined.
     */
    error InvalidKeyMarket();

    /**
     * Thrown when trying to set the terms for a buyout market key with a zero buyback or reserve price.
     */
    error InvalidBuyOutTerms();

    /**
     * Thrown when trying to set the terms for a free market key with a non zero buyback and reserve price.
     */
    error InvalidFreeMarketTerms();

    /**
     * Thrown when the buy back price exceeds the reserve price.
     */
    error BuyBackExceedsReserve();

    /**
     * Thrown when an invalid amount of native token has been provided.
     */
    error InvalidNativeTokenAmount();

    /**
     * Thrown when two arrays share different sizes.
     */
    error ArrayLengthMismatch();

    /**
     * Thrown when trying to set buy out terms with an invalid market type.
     */
    error InvalidMarketType();

    /**
     * Thrown when the recovered signer does not match the maker.
     */
    error SignerNotMaker();

    /**
     * Thrown when an order or bid is attempting to be filled after the end time has passed.
     */
    error ExpiredOrderOrBid();

    /**
     * Thrown when an order or bid is attempting to be filled prior to the start time.
     */
    error InactiveOrderOrBid();

    /**
     * Thrown when an order taker has been specified, but the caller is not the taker.
     */
    error CallerNotTaker();

    /**
     * Thrown when the caller is not the creator of an order.
     */
    error CallerNotMaker();

    /**
     * Thrown when trying to cancel an order that is not in the open status.
     */
    error InvalidOrderStatus();

    /**
     * Thrown when trying to cancel a bid that is not in the open status.
     */
    error InvalidBidStatus();

    /**
     * Thrown when trying to execute a buy back with a free market type key.
     */
    error KeyNotBuyOutMarket();

    /**
     * Thrown when a transfer of native token amount fails.
     */
    error NativeTransferFailed();

    /**
     * Thrown when the new protocol fee exceeds the maximum number of basis points.
     */
    error FeeExceedsBps();

    /**
     * Thrown when attempting to transact multi-asset vault keys while they are restricted.
     */
    error MultiAssetKeysRestricted();

    /**
     * Thrown when a parameter array has a zero length.
     */
    error ZeroLengthArray();

    /**
     * Thrown when a buy back doesn't result in the caller owning the total supply of keys.
     */
    error BuyBackFailed();

    /**
     * Thrown when a restricted user attempts to use the Key Exchange whilst restricted users are block.
     */
    error Restricted();

    /**
     * Thrown when a holder has no keys.
     */
    error NoKeysHeld();

    /**
     * Thrown when the zero address is provided.
     */
    error ZeroAddressInvalid();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Emitted when an order is filled.
     * @param taker Account that filled the order.
     * @param orderHash EIP712 hash of the order.
     */
    event OrderFilled(address indexed taker, bytes32 orderHash);

    /**
     * Emitted when a bid is filled.
     * @param taker Account that accepted the bid.
     * @param bidHash EIP712 hash of the bid.
     */
    event BidFilled(address indexed taker, bytes32 bidHash);

    /**
     * Emitted when an order is cancelled.
     * @param orderHash EIP712 hash of the order.
     */
    event OrderCancelled(bytes32 orderHash);

    /**
     * Emitted when a bid is cancelled.
     * @param bidHash EIP712 hash of the bid.
     */
    event BidCancelled(bytes32 bidHash);

    /**
     * Emitted when a key buyout at the buy back price is executed.
     * @param caller Account that executed the buy out.
     * @param keyId Unique key idenitfier.
     */
    event BuyOutExecuted(address indexed caller, uint256 indexed keyId);

    /**
     * Emitted when a key buyout at the reserve price is executed.
     * @param caller Account that executed the reserve purchase.
     * @param keyId Unique key identifier.
     */
    event ReserveBuyOut(address indexed caller, uint256 indexed keyId);

    /**
     * Emitted when the protocol fee is updated.
     * @param oldFee Old protocol fee.
     * @param newFee New protocol fee.
     */
    event ProtocolFeeUpdated(uint256 oldFee, uint256 newFee);

    /**
     * Emitted when key terms are set.
     * @param keyId Unique key identifier.
     * @param keyTerms Final key terms.
     */
    event KeyTermsSet(uint256 indexed keyId, KeyTerms keyTerms);

    /**
     * Emitted when multi-key trading status is updated.
     * @param newStatus Flag indicating if multi-key trading is enabled.
     */
    event MultiKeyTradingUpdated(bool newStatus);

    /**
     * Emitted when restricted users access is updated.
     * @param newStatus Flag indiciating is restricted users can access the Key Exchange.
     */
    event RestrictedUserAccessUpdated(bool newStatus);

    /**
     * Emitted when the fee receiver is updated.
     * @param oldFeeReceiver Old protocol fee receiver.
     * @param newFeeReceiver New protocol fee receiver.
     */
    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ENUMS                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Enum encapsulating the market type associated with a listing.
     * @custom:param FREE: The lister cannot perform a buy out at a later point in time.
     * @custom:param BUYOUT: The lister has the ability to buy the key back at some point in the future.
     * @custom:param INACTIVE: This market type specifies that a key ID has been bought out.
     */
    enum MarketType {
        UNDEFINED,
        FREE,
        BUYOUT,
        INACTIVE
    }

    /**
     * Enum encapsulating the possible statuses that can be associated with an order or bid.
     * @custom:param OPEN: The order or bid can be filled.
     * @custom:param FILLED: The order or bid has been filled.
     * @custom:param CANCELLED: The order or bid has been cancelled.
     */
    enum Status {
        OPEN,
        FILLED,
        CANCELLED
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STRUCTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Struct encapsulating all information related to an order.
     * @param market Type of market this listing is associated with, either free or buy-out.
     */
    struct KeyTerms {
        MarketType market;
        uint256 buyBack;
        uint256 reserve;
    }

    /**
     * Struct encapsulating all royalty payment information.
     */
    struct Royalties {
        address receiver;
        uint256 fee;
    }

    /**
     * Struct encapsulating all data related to an order.
     * @param price Total price of the order.
     * @param maker Address of the account that created the order.
     * @param taker Address of the account that the order is destined for, `address(0)` means an open order.
     * @param keyId Key identifier associated with this order.
     * @param amount Number of keys available to purchase.
     * @param nonce Nonce of the maker at the time this order was created.
     * @param startTime Timestamp that this order was created.
     * @param endTime Timestamp that this order will become invalid.
     * @param protocolFee Protocol fee at the time the order was created.
     */
    struct Order {
        uint256 price;
        address maker;
        address taker;
        uint256 keyId;
        uint256 amount;
        uint256 nonce;
        uint256 startTime;
        uint256 endTime;
        uint256 protocolFee;
        Royalties[] royalties;
    }

    /**
     * Struct encapsulating all data related to a bid.
     * @param maker Address of the account that created the bid.
     * @param price Total bid amount.
     * @param keyId Key identifier associated with this bid.
     * @param amount Number of keys the bidder wishes to purchase.
     * @param nonce Nonce of the bidder at the time this order was created.
     * @param startTime Timestamp that this bid was created.
     * @param endTime Timestamp that this bid will become invalid.
     * @param protocolFee Protocol fee at the time the order was created.
     */
    struct Bid {
        address maker;
        uint256 price;
        uint256 keyId;
        uint256 amount;
        uint256 nonce;
        uint256 startTime;
        uint256 endTime;
        uint256 protocolFee;
        Royalties[] royalties;
    }

    /**
     * Struct encapsulating the order and the signature associated with it.
     * @param order Complete `Order` struct.
     * @param signature Signed EIP712 order digest.
     */
    struct OrderParams {
        Order order;
        bytes signature;
    }

    /**
     * Struct encapsulating the bid and the signature associated with it.
     * @param bid Complete `bid` struct.
     * @param signature Signed EIP712 bid digest.
     */
    struct BidParams {
        Bid bid;
        bytes signature;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         FUNCTIONS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to execute an array of orders.
     * @param orders Array of orders to execute.
     */
    function executeOrders(OrderParams[] calldata orders) external payable;

    /**
     * Function used to execute an array of bids.
     * @param bids Array of bids to execute.
     */
    function executeBids(BidParams[] calldata bids) external;

    /**
     * Function used to cancel an array of orders.
     * @param orders Array of orders to cancel.
     */
    function cancelOrders(Order[] calldata orders) external;

    /**
     * Function used to cancel an array of bids.
     * @param bids Array of bids to cancel.
     */
    function cancelBids(Bid[] calldata bids) external;

    /**
     * Function used to execute a buy back of all keys from existing holders.
     * @param keyId Unique key idenitifier.
     * @param holders Array of holders to purchase the keys from.
     */
    function executeBuyBack(uint256 keyId, address[] calldata holders) external payable;

    /**
     * Function used to purchase keys at the reserve price from existing holders.
     * @param keyId Unique key idenitifier.
     * @param holders Array of holders to purchase the keys from.
     */
    function buyAtReserve(uint256 keyId, address[] calldata holders) external payable;

    /**
     * Function used to set the key terms associated with a key idenitifier.
     * @param finalTerms The terms associated with the key ID.
     * @param keyId Unique key idenitifier.
     */
    function setKeyTerms(uint256 keyId, KeyTerms calldata finalTerms) external;

    /**
     * Function used to toggle trading of multi-asset vault keys.
     */
    function toggleMultiKeyTrading() external;

    /**
     * Function used to toggle access to the Key Exchange for restricted users.
     */
    function toggleAllowRestrictedUsers() external;

    /**
     * Function used to adjust the currently defined protocol fee percentage.
     * @param newProtocolFee New protocol fee value.
     */
    function setProtocolFee(uint256 newProtocolFee) external;

    /**
     * Function used to set a new fee receiver address.
     * @param newFeeReceiver New protocol fee receiver.
     */
    function setFeeReceiver(address newFeeReceiver) external;

    /**
     * Function used to view the terms associated with a given key identifier.
     * @param keyId Unique key idenitifier.
     */
    function keyTerms(uint256 keyId) external view returns (KeyTerms memory);

    /**
     * Function used to increment the nonce associated with the caller.
     */
    function incrementNonce() external;

    /**
     * Function used to view the nonce associated with a given account.
     * @param account The account to view the current nonce value for.
     */
    function getNonce(address account) external view returns (uint256);

    /**
     * Function used to view the EIP712 hash of an Order struct.
     * @param order Order struct to hash.
     */
    function hashOrder(Order calldata order) external view returns (bytes32);

    /**
     * Function used to view the EIP712 hash of a Bid struct.
     * @param bid Bid struct to hash.
     */
    function hashBid(Bid calldata bid) external view returns (bytes32);
}


// File: src/interfaces/IAccessRegistry.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import { ISignerRegistry } from "../interfaces/ISignerRegistry.sol";

/**
 * @title IAccessRegistry
 */
interface IAccessRegistry {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Thrown when a user tries to define an access type for an already defined address.
     */
    error AccessTypeDefined();

    /**
     * Thrown when a user tries to set an access type with the default value.
     */
    error InvalidAccessType();

    /**
     * Thrown when a user tries to use an expired signature when initializing their access type.
     */
    error DeadlinePassed();

    /**
     * Thrown when the zero address is provided.
     */
    error ZeroAddressInvalid();

    /**
     * Thrown when the provided nonce has been consumed.
     */
    error NonceUsed();

    /**
     * Thrown when the user address does not match `msg.sender`.
     */
    error UserAddressMismatch();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ENUMS                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Enum encapsulating the access type related to a specified address.
     * @custom:value BLOCKED: User does not have access.
     * @custom:value RESTRICTED: User has restricted access.
     * @custom:value UNRESTRICTED: User has unrestricted access.
     */
    enum AccessType {
        BLOCKED,
        RESTRICTED,
        UNRESTRICTED
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STRUCTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Struct encapsulating the data related to setting an access type.
     * @param user Account that is being granted the access type.
     * @param deadline The timestamp by which the signature must be used.
     * @param nonce Unique nonce.
     * @param accessType Type of access the user has within the protocol.
     */
    struct AccessParams {
        address user;
        uint256 deadline;
        uint256 nonce;
        AccessType accessType;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Emitted when the access type of an address has been set for the first time.
     * @param account The address whose access type has been set.
     * @param accessType Associated `{AccessType}` Enum.
     * @param signature Signature used for access registration.
     */
    event AccessTypeSet(address indexed account, AccessType accessType, bytes signature);

    /**
     * Emitted when the access type of an address has been modified by an admin.
     * @param admin The address of the admin that made the update.
     * @param account The address whose access type was modified.
     * @param oldAccessType Previous `{AccessType}` Enum value of account.
     * @param newAccessType New `{AccessType}` Enum value for account.
     */
    event AccessTypeModified(
        address indexed admin, address indexed account, AccessType oldAccessType, AccessType newAccessType
    );

    /**
     * Emitted when the Signer Registry address is updated.
     * @param oldSignerRegistry Old Signer Registry address.
     * @param newSignerRegistry New Signer Registry address.
     */
    event SignerRegistryUpdated(ISignerRegistry indexed oldSignerRegistry, ISignerRegistry indexed newSignerRegistry);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         FUNCTIONS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to initialise the access type of an address.
     * @param accessParams Desired `{AccessParams}` struct.
     * @param signature Signed message digest.
     */
    function initAccessType(AccessParams calldata accessParams, bytes calldata signature) external;

    /**
     * Function used to modify the access type of an address.
     * @param account The address whose access type is being modified.
     * @param newAccessType Desired `{AccessType}` Enum value.
     */
    function modifyAccessType(address account, AccessType newAccessType) external;

    /**
     * Function used to set a new signer module address.
     * @param newSignerRegistry The new signer registry address.
     */
    function setSignerRegistry(ISignerRegistry newSignerRegistry) external;

    /**
     * Function used to view the access type of an address.
     * @param account Account to view the access type for.
     */
    function accessType(address account) external view returns (AccessType);

    /**
     * Function used to view the nonce for a given account.
     * @param account Account to check the nonce for.
     */
    function accountNonce(address account) external view returns (uint256);

    /**
     * Function used to get the `AccessParams` struct hash in accordance with EIP712.
     * @param accessParams Desired `AccessParams` struct.
     */
    function hashAccessParams(AccessParams calldata accessParams) external view returns (bytes32);
}


// File: src/interfaces/IMAVault.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import { IKeys } from "./IKeys.sol";
import { Asset, KeyConfig } from "../types/DataTypes.sol";

/**
 * @title IMAVault
 */
interface IMAVault {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Thrown when trying to unlock a zero amount of assets.
     */
    error ZeroAssetAmount();

    /**
     * Thrown when a native token unlock transfer fails.
     */
    error NativeTokenUnlockFailed();

    /**
     * Thrown when trying to bind keys to an already key binded vault.
     */
    error KeysBindedToVault();

    /**
     * Thrown when trying to unbind keys from a non-key binded vault.
     */
    error NoKeysBindedToVault();

    /**
     * Thrown when trying to unlock an asset of class `NONE`.
     */
    error NoneAssetType();

    /**
     * Thrown when the zero address is provided.
     */
    error ZeroAddressInvalid();

    /**
     * Thrown when an input array with zero length is provided.
     */
    error ZeroLengthArray();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Emitted when native token is unlocked.
     * @param receiver Account receiving the native token.
     * @param amount Amount of native token being unlocked.
     */
    event NativeTokenUnlocked(address indexed receiver, uint256 amount);

    /**
     * Emitted when changes to the delegation rights of an asset are performed.
     * @param delegationHash Unique delegation identifier.
     */
    event DelegationPerformed(bytes32 indexed delegationHash);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         FUNCTIONS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to return the key ID associated with a vault.
     */
    function boundKeyId() external view returns (uint256);

    /**
     * Function used to initialize the vault.
     * @param owner_ Address of the caller that created the vault.
     * @param keys_ Address of {SegMintKeys} contract.
     * @param keyAmount_ Number of keys to bind to the vault.
     * @param delegateAssets_ Flag indicating if the underlying assets should be delegated to the Vault creator.
     */
    function initialize(address owner_, IKeys keys_, uint256 keyAmount_, bool delegateAssets_) external;

    /**
     * Function used to unlock assets from the vault.
     * @param assets Array of assets to lock.
     * @param receiver Receiving address of the assets being unlocked.
     */
    function unlockAssets(Asset[] calldata assets, address receiver) external;

    /**
     * Function used to unlock the Native Token from the vault.
     * @param receiver Receiving address of the unlocked Ether.
     */
    function unlockNativeToken(address receiver) external;

    /**
     * Function used to claim ownership of the vault, enabling asset and native token unlocking.
     */
    function claimOwnership() external;

    /**
     * Function used to modify delegation rights of underlying assets contained within the Vault.
     * @param delegationPayloads Array of encoded delegation calls to make.
     * @dev It is expected that only delegation calls should be made with this function, such as:
     * `delegateAll`, `delegateContract`, `delegateERC20`, `delegateERC721` and `delegateERC1155`.
     */
    function modifyAssetDelegation(bytes[] calldata delegationPayloads) external;

    /**
     * Function used to view the key config associated the vaults key ID.
     */
    function getKeyConfig() external view returns (KeyConfig memory);
}


// File: src/interfaces/IKeys.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import { IAccessRegistry } from "./IAccessRegistry.sol";
import { VaultType, KeyConfig } from "../types/DataTypes.sol";

/**
 * @title IKeys
 */
interface IKeys {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Thrown when an account already has an active lend for the specified key ID.
     */
    error HasActiveLend();

    /**
     * Thrown when trying to lend a key outside of the defined lending duration boundaries.
     */
    error InvalidLendDuration();

    /**
     * Thrown when trying to reclaim keys before the defined lending period has elapsed.
     */
    error LendStillActive();

    /**
     * Thrown when trying to relcaim keys for a lendee with no active lend for key ID.
     */
    error NoActiveLend();

    /**
     * Thrown when trying to transfer keys that taps into the accounts lended key balance.
     */
    error CannotTransferLendedKeys();

    /**
     * Thrown when trying to transfer a zero amount of keys.
     */
    error ZeroKeyTransfer();

    /**
     * Thrown when trying to create an invalid number of keys.
     */
    error InvalidKeyAmount();

    /**
     * Thrown when trying to transfer keys that have been frozen.
     */
    error KeysFrozen();

    /**
     * Thrown when an non-registered vault address attempts to create keys.
     */
    error CallerNotVault();

    /**
     * Thrown when attempting to lend out zero keys.
     */
    error ZeroLendAmount();

    /**
     * Thrown when trying to lend keys to self.
     */
    error CannotLendToSelf();

    /**
     * Thrown when the caller is not the exchange.
     */
    error CallerNotExchange();

    /**
     * Thrown when the zero address is provided.
     */
    error ZeroAddressInvalid();

    /**
     * Thrown when two arrays don't share the same length.
     */
    error ArrayLengthMismatch();

    /**
     * Thrown when trying to lend out lended keys.
     */
    error CannotLendOutLendedKeys();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Emitted when a specific key identifier is frozen.
     * @param admin Address of the admin that froze the keys.
     * @param keyId Key identifier that was frozen.
     */
    event KeyFrozen(address indexed admin, uint256 indexed keyId);

    /**
     * Emitted when a specific key identifier is unfrozen.
     * @param admin Address of the admin that unfroze the keys.
     * @param keyId Key ID that was unfrozen.
     */
    event KeyUnfrozen(address indexed admin, uint256 indexed keyId);

    /**
     * Emitted when a new vault is registered.
     * @param registeredVault Address of the newly registered vault.
     */
    event VaultRegistered(address indexed registeredVault);

    /**
     * Emitted when the Access Registry address is updated.
     * @param oldAccessRegistry Old Access Registry address.
     * @param newAccessRegistry New Access Registry address.
     */
    event AccessRegistryUpdated(IAccessRegistry indexed oldAccessRegistry, IAccessRegistry indexed newAccessRegistry);

    /**
     * Emitted when the Key Exchange address is updated.
     * @param oldKeyExchange Previous Key Exchange address.
     * @param newKeyExchange New Key Exchange address.
     */
    event KeyExchangeUpdated(address indexed oldKeyExchange, address indexed newKeyExchange);

    /**
     * Emitted when the token URI is updated.
     * @param newURI New token URI.
     */
    event URIUpdated(string newURI);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STRUCTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Struct encapsulating the information associated with a keys lending terms.
     * @param lender The address that initiated the lend.
     * @param amount Number of keys that were provided on lend.
     * @param expiryTime Timestamp of when the lend expires.
     */
    struct LendingTerms {
        address lender;
        uint56 amount;
        uint40 expiryTime;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         FUNCTIONS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to mint new keys and return the key ID associated with them.
     * @param amount Number of keys to create.
     * @param receiver Address that will receive the newly created keys.
     * @param vaultType Type of vault that keys are being associated with.
     */
    function createKeys(uint256 amount, address receiver, VaultType vaultType) external returns (uint256);

    /**
     * Function used to burn keys.
     * @param holder Account that is burning the keys.
     * @param keyId Unique key identifier.
     * @param amount Number of keys being burnt.
     */
    function burnKeys(address holder, uint256 keyId, uint256 amount) external;

    /**
     * Function used to lend keys out to a lendee.
     * @param lendee Account receiving the keys.
     * @param keyId Unique key identifier.
     * @param lendAmount Number of keys being lent out.
     * @param lendDuration Total time the lendee has access to the keys for.
     */
    function lendKeys(address lendee, uint256 keyId, uint256 lendAmount, uint256 lendDuration) external;

    /**
     * Function used to reclaim all keys from a lendee.
     * @param lendee Account in possession of the lended keys.
     * @param keyId Unique key identifier.
     */
    function reclaimKeys(address lendee, uint256 keyId) external;

    /**
     * Function used to register a vault to allow for key creation.
     * @param vault Address of the vault being registered.
     */
    function registerVault(address vault) external;

    /**
     * Function used to freeze keys.
     * @param keyId Unique key identifier.
     */
    function freezeKeys(uint256 keyId) external;

    /**
     * Function used to unfreeze keys.
     * @param keyId Unique key identifier.
     */
    function unfreezeKeys(uint256 keyId) external;

    /**
     * Function used to view the config associated with a given key ID.
     * @param keyId Unique key identifier.
     */
    function getKeyConfig(uint256 keyId) external view returns (KeyConfig memory);

    /**
     * Function used to view the lending terms associated with a lendee and key ID.
     * @param lendee Address to check active lends for.
     * @param keyId Unique key identifier.
     */
    function activeLends(address lendee, uint256 keyId) external view returns (LendingTerms memory);

    /**
     * Function used to clear lending terms for a specified lendee.
     * @param lendee Address to clear a lend for.
     * @param keyId Unique key identifier.
     */
    function clearLendingTerms(address lendee, uint256 keyId) external;
}


// File: src/types/DataTypes.sol
// SPDX-License-Identifier: SegMint Code License 1.1
pragma solidity 0.8.19;

/**
 * Enum encapsulating the types of asset classes that can be vaulted.
 */
enum AssetClass {
    NONE,
    ERC20,
    ERC721,
    ERC1155
}

/**
 * Struct encapsulating the parameters for a vaulted asset.
 * @param class Enum defining the class of the asset.
 * @param token Contract address of the asset.
 * @param identifier Unique token identifier.
 * @param amount The amount of the asset being locked.
 * @dev For ERC721 tokens, the `amount` should always be 1.
 */
struct Asset {
    AssetClass class;
    address token;
    uint256 identifier;
    uint256 amount;
}

/**
 * Enum encapsulating the type of vault keys are associated with.
 */
enum VaultType {
    NONE,
    SINGLE,
    MULTI
}

/**
 * Struct encapsulating the configuration associated with a specifc key ID.
 * @param creator Address that minted the keys.
 * @param vaultType Type of vault the keys are associated with.
 * @param isFrozen Flag if the keys are tradeable.
 * @param isBurned Flag if the keys have been burnt.
 * @param supply Number of keys of key ID in circulation.
 */
struct KeyConfig {
    address creator;
    VaultType vaultType;
    bool isFrozen;
    bool isBurned;
    uint8 supply;
}


// File: lib/solady/src/auth/Ownable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Simple single owner authorization mixin.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)
/// @dev While the ownable portion follows
/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,
/// the nomenclature for the 2-step ownership handover may be unique to this codebase.
abstract contract Ownable {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       CUSTOM ERRORS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The caller is not authorized to call the function.
    error Unauthorized();

    /// @dev The `newOwner` cannot be the zero address.
    error NewOwnerIsZeroAddress();

    /// @dev The `pendingOwner` does not have a valid handover request.
    error NoHandoverRequest();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.
    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be
    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),
    /// despite it not being as lightweight as a single argument event.
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);

    /// @dev An ownership handover to `pendingOwner` has been requested.
    event OwnershipHandoverRequested(address indexed pendingOwner);

    /// @dev The ownership handover to `pendingOwner` has been canceled.
    event OwnershipHandoverCanceled(address indexed pendingOwner);

    /// @dev `keccak256(bytes("OwnershipTransferred(address,address)"))`.
    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =
        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;

    /// @dev `keccak256(bytes("OwnershipHandoverRequested(address)"))`.
    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =
        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;

    /// @dev `keccak256(bytes("OwnershipHandoverCanceled(address)"))`.
    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =
        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.
    /// It is intentionally chosen to be a high value
    /// to avoid collision with lower slots.
    /// The choice of manual storage layout is to enable compatibility
    /// with both regular and upgradeable contracts.
    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;

    /// The ownership handover slot of `newOwner` is given by:
    /// ```
    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))
    ///     let handoverSlot := keccak256(0x00, 0x20)
    /// ```
    /// It stores the expiry timestamp of the two-step ownership handover.
    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     INTERNAL FUNCTIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Initializes the owner directly without authorization guard.
    /// This function must be called upon initialization,
    /// regardless of whether the contract is upgradeable or not.
    /// This is to enable generalization to both regular and upgradeable contracts,
    /// and to save gas in case the initial owner is not the caller.
    /// For performance reasons, this function will not check if there
    /// is an existing owner.
    function _initializeOwner(address newOwner) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Clean the upper 96 bits.
            newOwner := shr(96, shl(96, newOwner))
            // Store the new value.
            sstore(not(_OWNER_SLOT_NOT), newOwner)
            // Emit the {OwnershipTransferred} event.
            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)
        }
    }

    /// @dev Sets the owner directly without authorization guard.
    function _setOwner(address newOwner) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            let ownerSlot := not(_OWNER_SLOT_NOT)
            // Clean the upper 96 bits.
            newOwner := shr(96, shl(96, newOwner))
            // Emit the {OwnershipTransferred} event.
            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)
            // Store the new value.
            sstore(ownerSlot, newOwner)
        }
    }

    /// @dev Throws if the sender is not the owner.
    function _checkOwner() internal view virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // If the caller is not the stored owner, revert.
            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {
                mstore(0x00, 0x82b42900) // `Unauthorized()`.
                revert(0x1c, 0x04)
            }
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  PUBLIC UPDATE FUNCTIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Allows the owner to transfer the ownership to `newOwner`.
    function transferOwnership(address newOwner) public payable virtual onlyOwner {
        /// @solidity memory-safe-assembly
        assembly {
            if iszero(shl(96, newOwner)) {
                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.
                revert(0x1c, 0x04)
            }
        }
        _setOwner(newOwner);
    }

    /// @dev Allows the owner to renounce their ownership.
    function renounceOwnership() public payable virtual onlyOwner {
        _setOwner(address(0));
    }

    /// @dev Request a two-step ownership handover to the caller.
    /// The request will automatically expire in 48 hours (172800 seconds) by default.
    function requestOwnershipHandover() public payable virtual {
        unchecked {
            uint256 expires = block.timestamp + ownershipHandoverValidFor();
            /// @solidity memory-safe-assembly
            assembly {
                // Compute and set the handover slot to `expires`.
                mstore(0x0c, _HANDOVER_SLOT_SEED)
                mstore(0x00, caller())
                sstore(keccak256(0x0c, 0x20), expires)
                // Emit the {OwnershipHandoverRequested} event.
                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())
            }
        }
    }

    /// @dev Cancels the two-step ownership handover to the caller, if any.
    function cancelOwnershipHandover() public payable virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute and set the handover slot to 0.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, caller())
            sstore(keccak256(0x0c, 0x20), 0)
            // Emit the {OwnershipHandoverCanceled} event.
            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())
        }
    }

    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.
    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.
    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute and set the handover slot to 0.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, pendingOwner)
            let handoverSlot := keccak256(0x0c, 0x20)
            // If the handover does not exist, or has expired.
            if gt(timestamp(), sload(handoverSlot)) {
                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.
                revert(0x1c, 0x04)
            }
            // Set the handover slot to 0.
            sstore(handoverSlot, 0)
        }
        _setOwner(pendingOwner);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   PUBLIC READ FUNCTIONS                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the owner of the contract.
    function owner() public view virtual returns (address result) {
        /// @solidity memory-safe-assembly
        assembly {
            result := sload(not(_OWNER_SLOT_NOT))
        }
    }

    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.
    function ownershipHandoverExpiresAt(address pendingOwner)
        public
        view
        virtual
        returns (uint256 result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the handover slot.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, pendingOwner)
            // Load the handover slot.
            result := sload(keccak256(0x0c, 0x20))
        }
    }

    /// @dev Returns how long a two-step ownership handover is valid for in seconds.
    function ownershipHandoverValidFor() public view virtual returns (uint64) {
        return 48 * 3600;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         MODIFIERS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Marks a function as only callable by the owner.
    modifier onlyOwner() virtual {
        _checkOwner();
        _;
    }
}


// File: lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: lib/openzeppelin-contracts/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     *
     * Furthermore, `isContract` will also return true if the target contract within
     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
     * which only has an effect at the end of a transaction.
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: lib/solady/src/utils/EIP712.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Contract for EIP-712 typed structured data hashing and signing.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)
/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)
/// Note, this implementation:
/// - Uses `address(this)` for the `verifyingContract` field.
/// - Does NOT use the optional EIP-712 salt.
/// - Does NOT use any EIP-712 extensions.
/// This is for simplicity and to save gas.
/// If you need to customize, please fork / modify accordingly.
abstract contract EIP712 {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  CONSTANTS AND IMMUTABLES                  */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.
    bytes32 internal constant _DOMAIN_TYPEHASH =
        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

    address private immutable _cachedThis;
    uint256 private immutable _cachedChainId;
    bytes32 private immutable _cachedNameHash;
    bytes32 private immutable _cachedVersionHash;
    bytes32 private immutable _cachedDomainSeparator;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTRUCTOR                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Cache the hashes for cheaper runtime gas costs.
    /// In the case of upgradeable contracts (i.e. proxies),
    /// or if the chain id changes due to a hard fork,
    /// the domain separator will be seamlessly calculated on-the-fly.
    constructor() {
        _cachedThis = address(this);
        _cachedChainId = block.chainid;

        (string memory name, string memory version) = _domainNameAndVersion();
        bytes32 nameHash = keccak256(bytes(name));
        bytes32 versionHash = keccak256(bytes(version));
        _cachedNameHash = nameHash;
        _cachedVersionHash = versionHash;

        bytes32 separator;
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Load the free memory pointer.
            mstore(m, _DOMAIN_TYPEHASH)
            mstore(add(m, 0x20), nameHash)
            mstore(add(m, 0x40), versionHash)
            mstore(add(m, 0x60), chainid())
            mstore(add(m, 0x80), address())
            separator := keccak256(m, 0xa0)
        }
        _cachedDomainSeparator = separator;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   FUNCTIONS TO OVERRIDE                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Please override this function to return the domain name and version.
    /// ```
    ///     function _domainNameAndVersion()
    ///         internal
    ///         pure
    ///         virtual
    ///         returns (string memory name, string memory version)
    ///     {
    ///         name = "Solady";
    ///         version = "1";
    ///     }
    /// ```
    function _domainNameAndVersion()
        internal
        pure
        virtual
        returns (string memory name, string memory version);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     HASHING OPERATIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the EIP-712 domain separator.
    function _domainSeparator() internal view virtual returns (bytes32 separator) {
        separator = _cachedDomainSeparator;
        if (_cachedDomainSeparatorInvalidated()) {
            separator = _buildDomainSeparator();
        }
    }

    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,
    /// given `structHash`, as defined in
    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.
    ///
    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:
    /// ```
    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(
    ///         keccak256("Mail(address to,string contents)"),
    ///         mailTo,
    ///         keccak256(bytes(mailContents))
    ///     )));
    ///     address signer = ECDSA.recover(digest, signature);
    /// ```
    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {
        bytes32 separator = _cachedDomainSeparator;
        if (_cachedDomainSeparatorInvalidated()) {
            separator = _buildDomainSeparator();
        }
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the digest.
            mstore(0x00, 0x1901000000000000) // Store "\x19\x01".
            mstore(0x1a, separator) // Store the domain separator.
            mstore(0x3a, structHash) // Store the struct hash.
            digest := keccak256(0x18, 0x42)
            // Restore the part of the free memory slot that was overwritten.
            mstore(0x3a, 0)
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    EIP-5267 OPERATIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267
    function eip712Domain()
        public
        view
        virtual
        returns (
            bytes1 fields,
            string memory name,
            string memory version,
            uint256 chainId,
            address verifyingContract,
            bytes32 salt,
            uint256[] memory extensions
        )
    {
        fields = hex"0f"; // `0b01111`.
        (name, version) = _domainNameAndVersion();
        chainId = block.chainid;
        verifyingContract = address(this);
        salt = salt; // `bytes32(0)`.
        extensions = extensions; // `new uint256[](0)`.
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      PRIVATE HELPERS                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the EIP-712 domain separator.
    function _buildDomainSeparator() private view returns (bytes32 separator) {
        bytes32 nameHash = _cachedNameHash;
        bytes32 versionHash = _cachedVersionHash;
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Load the free memory pointer.
            mstore(m, _DOMAIN_TYPEHASH)
            mstore(add(m, 0x20), nameHash)
            mstore(add(m, 0x40), versionHash)
            mstore(add(m, 0x60), chainid())
            mstore(add(m, 0x80), address())
            separator := keccak256(m, 0xa0)
        }
    }

    /// @dev Returns if the cached domain separator has been invalidated.
    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {
        uint256 cachedChainId = _cachedChainId;
        address cachedThis = _cachedThis;
        /// @solidity memory-safe-assembly
        assembly {
            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))
        }
    }
}


// File: src/interfaces/ISignerRegistry.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/**
 * @title ISignerRegistry
 */
interface ISignerRegistry {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Thrown when the recovered signer address does not match the expected signer address.
     */
    error SignerMismatch();

    /**
     * Thrown when the zero address is provided.
     */
    error ZeroAddressInvalid();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Emitted when the signer address is updated.
     * @param admin Address of the admin that updated the signer address.
     * @param oldSigner Previous signer address.
     * @param newSigner New signer address.
     */
    event SignerUpdated(address indexed admin, address oldSigner, address newSigner);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         FUNCTIONS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * Function used to set a new signer address.
     * @param newSigner Newly desired signer address.
     */
    function setSigner(address newSigner) external;

    /**
     * Function used to get the current signer address.
     */
    function getSigner() external view returns (address);
}

