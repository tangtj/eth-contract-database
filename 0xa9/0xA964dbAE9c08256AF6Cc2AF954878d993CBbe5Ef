{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}"},"tradingtest.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport \"./IERC20.sol\";\n\ncontract TradingGame {\n  constructor(address _token, uint256[3] memory _holdingStages, uint256[4] memory _paymentStages) {\n    token = _token;\n    owner = msg.sender;\n\n    holdingStages = _holdingStages;\n    paymentStages = _paymentStages;\n  }\n\n  struct Stock {\n    address usrAdd;\n    string ticker;\n    uint256 quantity;\n    uint256 timestamp;\n    uint256 priceperstock;\n  }\n\n  struct Player {\n    address usrAdd;\n    uint256 balance;\n    bool didGetInitialBalance;\n  }\n\n  struct Airdrop {\n    uint256 airdropId;\n    string airdropName;\n    uint256 airdropAmount;\n    uint256 airdropMinHoldingAmount;\n    uint256 airdropAvailableSlots;\n    address[] airdropWinners;\n  }\n\n  struct AirdropQuestion {\n    uint256 airdropId;\n    uint256 questionId;\n    string question;\n  }\n\n  struct AirdropAnswer {\n    uint256 questionId;\n    address userAdd;\n    string answer;\n  }\n\n  address public token;\n\n  address public owner;\n\n  Airdrop[] public airdrops;\n\n  AirdropQuestion[] public airdropQuestions;\n\n  AirdropAnswer[] public airdropAnswers;\n\n  Player[] public players;\n\n  Stock[] public stocks;\n\n  uint256[3] public holdingStages;\n  uint256[4] public paymentStages;\n\n  uint256 public airdropCounter;\n  uint256 public questionCounter;\n\n  function createUser() public {\n    (, bool err) = getUserAccountIdx(msg.sender);\n\n    require(err == false, \"User already exists\");\n\n    players.push(Player(msg.sender, 0, false));\n\n    payUser(msg.sender);\n  }\n\n  function getUserAccount(address userAdd) public view returns (Player memory, bool) {\n    for (uint256 i = 0; i \u003c players.length; i++) {\n      if (players[i].usrAdd == userAdd) {\n        return (players[i], true);\n      }\n    }\n    return (Player(userAdd, 0, false), false);\n  }\n\n  function getUserAccountIdx(address userAdd) private view returns (uint256, bool) {\n    if (players.length \u003e 0) {\n      for (uint256 i = 0; i \u003c players.length; i++) {\n        if (players[i].usrAdd == userAdd) {\n          return (i, true);\n        }\n      }\n    }\n    return (0, false);\n  }\n\n  function getStocksForUser() public view returns (Stock[] memory) {\n    uint256 userStocksCounter = 0;\n\n    for (uint256 i = 0; i \u003c stocks.length; i++) {\n      if (stocks[i].usrAdd == msg.sender) {\n        userStocksCounter += 1;\n      }\n    }\n\n    Stock[] memory userStocks = new Stock[](userStocksCounter);\n\n    uint256 userStocksIdx = 0;\n\n    for (uint256 i = 0; i \u003c stocks.length; i++) {\n      if (stocks[i].usrAdd == msg.sender) {\n        userStocks[userStocksIdx] = stocks[i];\n        userStocksIdx += 1;\n      }\n    }\n\n    return userStocks;\n  }\n\n  function getHoldingStages() public view returns (uint256[3] memory) {\n    return holdingStages;\n  }\n\n  function getPaymentStages() public view returns (uint256[4] memory) {\n    return paymentStages;\n  }\n\n  function payUser(address useradd) private {\n    IERC20 tokenInstance = IERC20(token);\n\n    // Get the token balance of the caller\n    uint256 balance = tokenInstance.balanceOf(useradd);\n    (uint256 userAccountIdx, bool err) = getUserAccountIdx(useradd);\n\n    require(err == true, \"User not found\");\n\n    require(players[userAccountIdx].didGetInitialBalance == false, \"User already got initial balance\");\n\n    if (balance \u003e holdingStages[2]) {\n      players[userAccountIdx].balance += paymentStages[3];\n    } else if (balance \u003e holdingStages[1]) {\n      players[userAccountIdx].balance += paymentStages[2];\n    } else if (balance \u003e holdingStages[0]) {\n      players[userAccountIdx].balance += paymentStages[1];\n    } else {\n      players[userAccountIdx].balance += paymentStages[0];\n    }\n\n    players[userAccountIdx].didGetInitialBalance = true;\n  }\n\n  modifier _onlyOwner() {\n    require(msg.sender == owner, \"Only owner can call this function\");\n    _;\n  }\n\n  function changeOwner(address _newOwner) public _onlyOwner {\n    owner = _newOwner;\n  }\n\n  function changeToken(address _newToken) public _onlyOwner {\n    token = _newToken;\n  }\n\n  function buyStockForUser(Stock memory stockdetails, address useradd) public _onlyOwner {\n    (uint256 userAccountIdx, bool err) = getUserAccountIdx(useradd);\n\n    require(err == true, \"User not found\");\n\n    require(\n      players[userAccountIdx].balance \u003e= stockdetails.priceperstock * stockdetails.quantity,\n      \"Insufficient balance\"\n    );\n\n    stocks.push(stockdetails);\n\n    players[userAccountIdx].balance -= stockdetails.priceperstock * stockdetails.quantity;\n  }\n\n  function sellStockForUser(Stock memory stockdetails, address useradd) public _onlyOwner {\n    (uint256 userAccountIdx, bool err) = getUserAccountIdx(useradd);\n\n    require(stockdetails.quantity \u003e 0, \"Quantity should be greater than 0\");\n\n    require(err == true, \"User not found\");\n\n    uint256 stockQuantity = 0;\n\n    uint256 stockEntryAmount = 0;\n\n    for (uint256 i = 0; i \u003c stocks.length; i++) {\n      if (\n        stocks[i].usrAdd == useradd \u0026\u0026\n        keccak256(abi.encodePacked(stocks[i].ticker)) == keccak256(abi.encodePacked(stockdetails.ticker)) \u0026\u0026\n        stocks[i].quantity \u003e 0\n      ) {\n        stockEntryAmount += 1;\n      }\n    }\n\n    require(stockEntryAmount \u003e 0, \"No stocks found\");\n\n    uint256[] memory stockIdx = new uint256[](stockEntryAmount);\n\n    uint256 stockIdxCounter = 0;\n\n    for (uint256 i = 0; i \u003c stocks.length; i++) {\n      if (\n        stocks[i].usrAdd == useradd \u0026\u0026\n        keccak256(abi.encodePacked(stocks[i].ticker)) == keccak256(abi.encodePacked(stockdetails.ticker)) \u0026\u0026\n        stocks[i].quantity \u003e 0\n      ) {\n        stockIdx[stockIdxCounter] = i;\n        stockIdxCounter += 1;\n      }\n    }\n\n    for (uint256 i = 0; i \u003c stockIdx.length; i++) {\n      stockQuantity += stocks[stockIdx[i]].quantity;\n    }\n\n    require(stockQuantity \u003e= stockdetails.quantity, \"Insufficient stocks\");\n\n    for (uint256 i = 0; i \u003c stockIdx.length; i++) {\n      if (stockdetails.quantity == 0) {\n        break;\n      }\n\n      if (stocks[stockIdx[i]].quantity \u003e stockdetails.quantity) {\n        stocks[stockIdx[i]].quantity -= stockdetails.quantity;\n        players[userAccountIdx].balance += stockdetails.priceperstock * stockdetails.quantity;\n        break;\n      } else {\n        players[userAccountIdx].balance += stockdetails.priceperstock * stocks[stockIdx[i]].quantity;\n        stocks[stockIdx[i]].quantity = 0;\n      }\n    }\n  }\n\n  function getUsersSortedFromMostMoneyToLeast() public view returns (Player[] memory) {\n    Player[] memory sortedPlayers = players;\n\n    for (uint256 i = 0; i \u003c sortedPlayers.length; i++) {\n      for (uint256 j = i + 1; j \u003c sortedPlayers.length; j++) {\n        if (sortedPlayers[i].balance \u003c sortedPlayers[j].balance) {\n          Player memory temp = sortedPlayers[i];\n          sortedPlayers[i] = sortedPlayers[j];\n          sortedPlayers[j] = temp;\n        }\n      }\n    }\n\n    return sortedPlayers;\n  }\n\n  function setAirdrop(Airdrop memory _airdrop, AirdropQuestion[] memory questions) public _onlyOwner {\n    airdrops.push(\n      Airdrop(\n        airdropCounter,\n        _airdrop.airdropName,\n        _airdrop.airdropAmount,\n        _airdrop.airdropMinHoldingAmount,\n        _airdrop.airdropAvailableSlots,\n        _airdrop.airdropWinners\n      )\n    );\n\n    for (uint256 i = 0; i \u003c questions.length; i++) {\n      airdropQuestions.push(AirdropQuestion(airdropCounter, questionCounter, questions[i].question));\n      questionCounter += 1;\n    }\n\n    airdropCounter += 1;\n  }\n\n  function getCurrentAirdropQuestions() public view returns (AirdropQuestion[] memory, Airdrop memory) {\n    uint256 airdropId = airdrops.length - 1;\n\n    uint256 _questionCounter = 0;\n\n    for (uint256 i = 0; i \u003c airdropQuestions.length; i++) {\n      if (airdropQuestions[i].airdropId == airdropId) {\n        _questionCounter += 1;\n      }\n    }\n\n    AirdropQuestion[] memory questions = new AirdropQuestion[](_questionCounter);\n\n    uint256 questionIdx = 0;\n\n    for (uint256 i = 0; i \u003c airdropQuestions.length; i++) {\n      if (airdropQuestions[i].airdropId == airdropId) {\n        questions[questionIdx] = airdropQuestions[i];\n        questionIdx += 1;\n      }\n    }\n\n    return (questions, airdrops[airdropId]);\n  }\n\n  function submitAnswersAndGetAirdropForLatest(AirdropAnswer[] memory answers, address usrAdd) public _onlyOwner {\n    uint256 airdropId = airdrops.length - 1;\n\n    require(airdrops[airdropId].airdropAvailableSlots \u003e 0, \"No slots available\");\n\n    uint256 _questionCounter = 0;\n\n    for (uint256 i = 0; i \u003c airdropQuestions.length; i++) {\n      if (airdropQuestions[i].airdropId == airdropId) {\n        _questionCounter += 1;\n      }\n    }\n\n    for (uint256 i = 0; i \u003c answers.length; i++) {\n      airdropAnswers.push(answers[i]);\n    }\n\n    require(_questionCounter == answers.length, \"Number of answers should be equal to number of questions\");\n\n    uint256 playerIdx = 0;\n\n    for (uint256 i = 0; i \u003c players.length; i++) {\n      if (players[i].usrAdd == usrAdd) {\n        playerIdx = i;\n        break;\n      }\n    }\n\n    players[playerIdx].balance += airdrops[airdropId].airdropAmount;\n\n    airdrops[airdropId].airdropAvailableSlots -= 1;\n\n    airdrops[airdropId].airdropWinners.push(usrAdd);\n  }\n\n  function getAllAirdropsQuestionsNAnswers()\n    public\n    view\n    _onlyOwner\n    returns (Airdrop[] memory, AirdropQuestion[] memory, AirdropAnswer[] memory)\n  {\n    return (airdrops, airdropQuestions, airdropAnswers);\n  }\n}\n"}}