{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"contract.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\n\r\ncontract EHIVE_NEW is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public maxSupply; // what the total supply can reach and not go beyond\r\n\r\n    IUniswapV2Router02 private uniswapV2Router;\r\n    address private uniswapV2Pair;\r\n\r\n    bool private _swapping;\r\n\r\n    address private _swapFeeReceiver;\r\n    \r\n    uint256 public swapTokensThreshold;\r\n\r\n    uint256 public totalFees;\r\n    uint256 private _marketingFee;\r\n    uint256 private _liquidityFee;\r\n    uint256 private _validatorFee;\r\n    \r\n    uint256 private _tokensForMarketing;\r\n    uint256 private _tokensForLiquidity;\r\n    uint256 private _tokensForValidator;\r\n    \r\n    // staking vars\r\n    uint256 public totalStaked;\r\n    uint256 public totalClaimed;\r\n    uint256 public apr;\r\n\r\n    bool public stakingEnabled = false;\r\n    uint256[] public monthlyReward = [0, 0, 0]; // [timestamp, totalStaked, weekly eth]\r\n\r\n    struct Staker {\r\n        address staker;\r\n        uint256 start;\r\n        uint256 staked;\r\n        uint256 earned;\r\n        uint256 ethEarned;\r\n    }\r\n\r\n    struct ClaimHistory {\r\n        uint256[] dates;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    // exlcude from fees and max transaction amount\r\n    mapping (address =\u003e bool) private _isExcludedFromFees;\r\n\r\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\r\n    // could be subject to a maximum transfer amount\r\n    mapping (address =\u003e bool) private _automatedMarketMakerPairs;\r\n\r\n    // to stop bot spam buys and sells on launch\r\n    mapping(address =\u003e uint256) private _holderLastTransferBlock;\r\n\r\n    // stake data\r\n    mapping(address =\u003e Staker) public stakers;\r\n    mapping(address =\u003e ClaimHistory) private _claimHistory;\r\n    mapping(address =\u003e mapping(uint256 =\u003e bool)) public userMonthlyClaimed; //specific to the months timestmap\r\n    mapping (address =\u003e bool) private _isBlacklisted;\r\n\r\n    event Stake(uint256 amount);\r\n    event Claim(uint256 amount);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the _swapFeeReceiver\r\n     */\r\n    modifier teamOROwner() {\r\n        require(_swapFeeReceiver == _msgSender() || owner() == _msgSender(), \"Caller is not the _swapFeeReceiver address nor owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier isStakingEnabled() {\r\n        require(stakingEnabled, \"Staking is not enabled.\");\r\n        _;\r\n    }\r\n\r\n    constructor() ERC20(\"Ethereum Hive\", \"EHIVE\") {\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        uint256 marketingFee = 2;\r\n        uint256 liquidityFee = 1;\r\n        uint256 validatorFee = 3;\r\n\r\n        uint256 totalSupply = 55e10 * 1e18;\r\n        maxSupply = 1e12 * 1e18;\r\n\r\n        swapTokensThreshold = 62500000000000000000000000;\r\n        \r\n        _marketingFee = marketingFee;\r\n        _liquidityFee = liquidityFee;\r\n        _validatorFee = validatorFee;\r\n        totalFees = _marketingFee + _liquidityFee + _validatorFee;\r\n\r\n        _swapFeeReceiver = owner();\r\n\r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n        \r\n        apr = 50;\r\n\r\n        _mint(msg.sender, totalSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Exclude from fee calculation\r\n    */\r\n    function excludeFromFees(address account, bool excluded) public teamOROwner {\r\n        _isExcludedFromFees[account] = excluded;\r\n    }\r\n    \r\n    function setAutomatedMarketMakerPairs(address account, bool allow) public teamOROwner {\r\n        _automatedMarketMakerPairs[account] = allow;\r\n    }\r\n\r\n    function setBlacklisted(address[] memory blacklisted_) external onlyOwner {\r\n        for (uint i = 0; i \u003c blacklisted_.length; i++) {\r\n            if (blacklisted_[i] != uniswapV2Pair \u0026\u0026 blacklisted_[i] != address(uniswapV2Router)) {\r\n                _isBlacklisted[blacklisted_[i]] = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function delBlacklisted(address[] memory blacklisted_) external onlyOwner {\r\n        for (uint i = 0; i \u003c blacklisted_.length; i++) {\r\n            _isBlacklisted[blacklisted_[i]] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Update token fees (max set to initial fee)\r\n    */\r\n    function updateFees(uint256 marketingFee, uint256 liquidityFee, uint256 validatorFee) external onlyOwner {\r\n        _marketingFee = marketingFee;\r\n        _liquidityFee = liquidityFee;\r\n        _validatorFee = validatorFee;\r\n\r\n        totalFees = _marketingFee + _liquidityFee + _validatorFee;\r\n\r\n        require(totalFees \u003c= 6, \"Must keep fees at 6% or less\");\r\n    }\r\n\r\n    /**\r\n    * @dev Update wallet that receives fees and newly added LP\r\n    */\r\n    function updateFeeReceiver(address newWallet) external teamOROwner {\r\n        _swapFeeReceiver = newWallet;\r\n    }\r\n\r\n    /**\r\n    * @dev Very important function. \r\n    * Updates the threshold of how many tokens that must be in the contract calculation for fees to be taken\r\n    */\r\n    function updateSwapTokensThreshold(uint256 newThreshold) external teamOROwner returns (bool) {\r\n  \t    require(newThreshold \u003e= totalSupply() * 1 / 100000, \"Swap threshold cannot be lower than 0.001% total supply.\");\r\n  \t    require(newThreshold \u003c= totalSupply() * 5 / 1000, \"Swap threshold cannot be higher than 0.5% total supply.\");\r\n  \t    swapTokensThreshold = newThreshold;\r\n  \t    return true;\r\n  \t}\r\n\r\n    /**\r\n    * @dev Check if an address is excluded from the fee calculation\r\n    */\r\n    function isExcludedFromFees(address account) external view returns(bool) {\r\n        return _isExcludedFromFees[account];\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_isBlacklisted[from], \"You are unable to transfer or swap due to blacklist.\");\r\n\r\n        if (amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n        \r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n        bool canSwap = contractTokenBalance \u003e= swapTokensThreshold;\r\n        if (\r\n            canSwap \u0026\u0026\r\n            !_swapping \u0026\u0026\r\n            !_automatedMarketMakerPairs[from] \u0026\u0026\r\n            !_isExcludedFromFees[from] \u0026\u0026\r\n            !_isExcludedFromFees[to]\r\n        ) {\r\n            _swapping = true;\r\n            swapBack();\r\n            _swapping = false;\r\n        }\r\n\r\n        bool takeFee = !_swapping;\r\n\r\n        // if any addy belongs to _isExcludedFromFee or isn\u0027t a swap then remove the fee\r\n        if (\r\n            _isExcludedFromFees[from] || \r\n            _isExcludedFromFees[to] || \r\n            (!_automatedMarketMakerPairs[from] \u0026\u0026 !_automatedMarketMakerPairs[to])\r\n        ) takeFee = false;\r\n        \r\n        uint256 fees = 0;\r\n        if (takeFee) {\r\n            fees = amount.mul(totalFees).div(100);\r\n            _tokensForLiquidity += fees * _liquidityFee / totalFees;\r\n            _tokensForValidator += fees * _validatorFee / totalFees;\r\n            _tokensForMarketing += fees * _marketingFee / totalFees;\r\n            \r\n            if (fees \u003e 0) {\r\n                super._transfer(from, address(this), fees);\r\n            }\r\n        \t\r\n        \tamount -= fees;\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }\r\n\r\n    function _swapTokensForEth(uint256 tokenAmount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            _swapFeeReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapBack() internal {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = _tokensForLiquidity + _tokensForMarketing + _tokensForValidator;\r\n        \r\n        if (contractBalance == 0 || totalTokensToSwap == 0) return;\r\n        if (contractBalance \u003e swapTokensThreshold) contractBalance = swapTokensThreshold;\r\n        \r\n        \r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = contractBalance * _tokensForLiquidity / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\r\n        \r\n        uint256 initialETHBalance = address(this).balance;\r\n\r\n        _swapTokensForEth(amountToSwapForETH);\r\n        \r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n        uint256 ethForMarketing = ethBalance.mul(_tokensForMarketing).div(totalTokensToSwap);\r\n        uint256 ethForValidator = ethBalance.mul(_tokensForValidator).div(totalTokensToSwap);\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForValidator;\r\n        \r\n        _tokensForLiquidity = 0;\r\n        _tokensForMarketing = 0;\r\n        _tokensForValidator = 0;\r\n\r\n        payable(_swapFeeReceiver).transfer(ethForMarketing.add(ethForValidator));\r\n                \r\n        if (liquidityTokens \u003e 0 \u0026\u0026 ethForLiquidity \u003e 0) {\r\n            _addLiquidity(liquidityTokens, ethForLiquidity);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer eth stuck in contract to _swapFeeReceiver\r\n    */\r\n    function withdrawContractETH() external {\r\n        payable(_swapFeeReceiver).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n    * @dev In case swap wont do it and sells/buys might be blocked\r\n    */\r\n    function forceSwap() external teamOROwner {\r\n        _swapTokensForEth(balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n        *\r\n        * @dev Staking part starts here\r\n        *\r\n    */\r\n\r\n    /**\r\n    * @dev Checks if holder is staking\r\n    */\r\n    function isStaking(address stakerAddr) public view returns (bool) {\r\n        return stakers[stakerAddr].staker == stakerAddr;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns how much staker is staking\r\n    */\r\n    function userStaked(address staker) public view returns (uint256) {\r\n        return stakers[staker].staked;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns how much staker has claimed over time\r\n    */\r\n    function userClaimHistory(address staker) public view returns (ClaimHistory memory) {\r\n        return _claimHistory[staker];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns how much staker has earned\r\n    */\r\n    function userEarned(address staker) public view returns (uint256) {\r\n        uint256 currentlyEarned = _userEarned(staker);\r\n        uint256 previouslyEarned = stakers[msg.sender].earned;\r\n\r\n        if (previouslyEarned \u003e 0) return currentlyEarned.add(previouslyEarned);\r\n        return currentlyEarned;\r\n    }\r\n\r\n    function _userEarned(address staker) private view returns (uint256) {\r\n        require(isStaking(staker), \"User is not staking.\");\r\n\r\n        uint256 staked = userStaked(staker);\r\n        uint256 stakersStartInSeconds = stakers[staker].start.div(1 seconds);\r\n        uint256 blockTimestampInSeconds = block.timestamp.div(1 seconds);\r\n        uint256 secondsStaked = blockTimestampInSeconds.sub(stakersStartInSeconds);\r\n\r\n        uint256 earn = staked.mul(apr).div(100);\r\n        uint256 rewardPerSec = earn.div(365).div(24).div(60).div(60);\r\n        uint256 earned = rewardPerSec.mul(secondsStaked);\r\n\r\n        return earned;\r\n    }\r\n \r\n    /**\r\n    * @dev Stake tokens in validator\r\n    */\r\n    function stake(uint256 stakeAmount) external isStakingEnabled {\r\n        require(totalSupply() \u003c= maxSupply, \"There are no more rewards left to be claimed.\");\r\n\r\n        // Check user is registered as staker\r\n        if (isStaking(msg.sender)) {\r\n            stakers[msg.sender].earned += _userEarned(msg.sender);\r\n            stakers[msg.sender].staked += stakeAmount;\r\n            stakers[msg.sender].start = block.timestamp;\r\n        } else {\r\n            stakers[msg.sender] = Staker(msg.sender, block.timestamp, stakeAmount, 0, 0);\r\n        }\r\n\r\n        totalStaked += stakeAmount;\r\n        _burn(msg.sender, stakeAmount);\r\n\r\n        emit Stake(stakeAmount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Claim earned tokens from stake in validator\r\n    */\r\n    function claim() external isStakingEnabled {\r\n        require(isStaking(msg.sender), \"You are not staking!?\");\r\n        require(totalSupply() \u003c= maxSupply, \"There are no more rewards left to be claimed.\");\r\n\r\n        uint256 reward = userEarned(msg.sender);\r\n\r\n        _claimHistory[msg.sender].dates.push(block.timestamp);\r\n        _claimHistory[msg.sender].amounts.push(reward);\r\n        totalClaimed += reward;\r\n\r\n        _mint(msg.sender, reward);\r\n\r\n        stakers[msg.sender].start = block.timestamp;\r\n        stakers[msg.sender].earned = 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Claim earned and staked tokens from validator\r\n    */\r\n    function unstake() external {\r\n        require(isStaking(msg.sender), \"You are not staking!?\");\r\n\r\n        uint256 ethReward = stakers[msg.sender].ethEarned;\r\n        if (!userMonthlyClaimed[msg.sender][monthlyReward[0]]) ethReward += _calcMonthlyReward();\r\n\r\n        if (ethReward \u003e 0) withdrawETHRewards();\r\n\r\n        uint256 reward = userEarned(msg.sender);\r\n        uint256 staked = stakers[msg.sender].staked;\r\n\r\n        if (totalSupply().add(reward) \u003c maxSupply \u0026\u0026 stakingEnabled) {\r\n            _claimHistory[msg.sender].dates.push(block.timestamp);\r\n            _claimHistory[msg.sender].amounts.push(reward);\r\n            totalClaimed += reward;\r\n\r\n            _mint(msg.sender, staked.add(reward));\r\n        } else {\r\n            _mint(msg.sender, staked);\r\n        }\r\n\r\n        totalStaked -= staked;\r\n\r\n        delete stakers[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @dev Add monthly eth reward for stakers\r\n    */\r\n    function addRewards() external payable teamOROwner {\r\n        monthlyReward = [block.timestamp, totalStaked, msg.value];\r\n    }\r\n\r\n    function _calcMonthlyReward() private view returns (uint256) {\r\n        require(isStaking(msg.sender), \"You are not staking!?\");\r\n        require(!userMonthlyClaimed[msg.sender][monthlyReward[0]], \"You already claimed your monthly reward.\");\r\n        require(stakers[msg.sender].start \u003c monthlyReward[0], \"You will not receive ETH rewards until next period.\");\r\n\r\n        uint256 staked = stakers[msg.sender].staked;\r\n        uint256 total = monthlyReward[1];\r\n        uint256 P = (staked * 1e18) / total;\r\n        uint256 reward = monthlyReward[2] * P / 1e18;\r\n\r\n        return reward;\r\n    }\r\n\r\n    /**\r\n    * @dev Claiming of eth rewards\r\n    */\r\n    function claimETHRewards() external {\r\n        uint256 reward = _calcMonthlyReward();\r\n\r\n        userMonthlyClaimed[msg.sender][monthlyReward[0]] = true;\r\n\r\n        stakers[msg.sender].ethEarned += reward;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdrawing of eth rewards\r\n    */\r\n    function withdrawETHRewards() public {\r\n        uint256 reward = stakers[msg.sender].ethEarned;\r\n        if (!userMonthlyClaimed[msg.sender][monthlyReward[0]]) reward += _calcMonthlyReward();\r\n\r\n        require(reward \u003e 0, \"There is no ETH to be withdrawn.\");\r\n        \r\n        userMonthlyClaimed[msg.sender][monthlyReward[0]] = true;\r\n\r\n        stakers[msg.sender].ethEarned = 0;\r\n        payable(msg.sender).transfer(reward);\r\n\r\n        emit Claim(reward);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Enables/disables staking\r\n    */\r\n    function setStakingState(bool onoff) external teamOROwner {\r\n        stakingEnabled = onoff;\r\n    }\r\n\r\n    receive() external payable {}\r\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}"},"IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"IUniswapV2Pair.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"IUniswapV2Router01.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e=0.6.2;\r\n\r\nimport \u0027./IUniswapV2Router01.sol\u0027;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}