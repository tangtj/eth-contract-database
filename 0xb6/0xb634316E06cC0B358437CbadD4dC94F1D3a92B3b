{"CommandBuilder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary CommandBuilder {\n\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\n    uint256 constant IDX_VALUE_MASK = 0x7f;\n    uint256 constant IDX_END_OF_ARGS = 0xff;\n    uint256 constant IDX_USE_STATE = 0xfe;\n\n    function buildInputs(\n        bytes[] memory state,\n        bytes4 selector,\n        bytes32 indices\n    ) internal view returns (bytes memory ret) {\n        uint256 free; // Pointer to first free byte in tail part of message\n        uint256 idx;\n\n        // Determine the length of the encoded data\n        for (uint256 i; i \u003c 32;) {\n            idx = uint8(indices[i]);\n            if (idx == IDX_END_OF_ARGS) break;\n            unchecked{free += 32;}\n            unchecked{++i;}\n        }\n\n        // Encode it\n        uint256 bytesWritten;\n        assembly {\n            ret := mload(0x40)\n            bytesWritten := add(bytesWritten, 4)\n            mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n            mstore(add(ret, 32), selector)\n        }\n        uint256 count = 0;\n        bytes memory stateData; // Optionally encode the current state if the call requires it\n        for (uint256 i; i \u003c 32;) {\n            idx = uint8(indices[i]);\n            if (idx == IDX_END_OF_ARGS) break;\n\n            if (idx \u0026 IDX_VARIABLE_LENGTH != 0) {\n                if (idx == IDX_USE_STATE) {\n                    assembly {\n                        bytesWritten := add(bytesWritten, 32)\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    if (stateData.length == 0) {\n                        stateData = abi.encode(state);\n                    }\n                    assembly {\n                        bytesWritten := add(bytesWritten, mload(stateData))\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n                    }\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\n                    free += stateData.length - 32;\n                } else {\n                    bytes memory stateVar = state[idx \u0026 IDX_VALUE_MASK];\n                    uint256 arglen = stateVar.length;\n\n                    // Variable length data; put a pointer in the slot and write the data at the end\n                    assembly {\n                        bytesWritten := add(bytesWritten, 32)\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    assembly {\n                        bytesWritten := add(bytesWritten, arglen)\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n                    }\n                    memcpy(\n                        stateVar,\n                        0,\n                        ret,\n                        free + 4,\n                        arglen\n                    );\n                    free += arglen;\n                }\n            } else {\n                // Fixed length data; write it directly\n                bytes memory stateVar = state[idx \u0026 IDX_VALUE_MASK];\n                assembly {\n                    bytesWritten := add(bytesWritten, mload(stateVar))\n                    mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\n                    mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\n                }\n            }\n            unchecked{count += 32;}\n            unchecked{++i;}\n        }\n        assembly {\n            mstore(ret, bytesWritten)\n        }\n    }\n\n    function writeOutputs(\n        bytes[] memory state,\n        bytes1 index,\n        bytes memory output\n    ) internal pure returns (bytes[] memory) {\n        uint256 idx = uint8(index);\n        if (idx == IDX_END_OF_ARGS) return state;\n\n        if (idx \u0026 IDX_VARIABLE_LENGTH != 0) {\n            if (idx == IDX_USE_STATE) {\n                state = abi.decode(output, (bytes[]));\n            } else {\n                // Check the first field is 0x20 (because we have only a single return value)\n                uint256 argptr;\n                assembly {\n                    argptr := mload(add(output, 32))\n                }\n                require(\n                    argptr == 32,\n                    \"Only one return value permitted (variable)\"\n                );\n\n                assembly {\n                    // Overwrite the first word of the return data with the length - 32\n                    mstore(add(output, 32), sub(mload(output), 32))\n                    // Insert a pointer to the return data, starting at the second word, into state\n                    mstore(\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\n                        add(output, 32)\n                    )\n                }\n            }\n        } else {\n            // Single word\n            require(\n                output.length == 32,\n                \"Only one return value permitted (static)\"\n            );\n\n            state[idx \u0026 IDX_VALUE_MASK] = output;\n        }\n\n        return state;\n    }\n\n    function writeTuple(\n        bytes[] memory state,\n        bytes1 index,\n        bytes memory output\n    ) internal view {\n        uint256 idx = uint256(uint8(index));\n        if (idx == IDX_END_OF_ARGS) return;\n\n        bytes memory entry = state[idx \u0026 IDX_VALUE_MASK] = new bytes(output.length + 32);\n\n        memcpy(output, 0, entry, 32, output.length);\n        assembly {\n            let l := mload(output)\n            mstore(add(entry, 32), l)\n        }\n    }\n\n    function memcpy(\n        bytes memory src,\n        uint256 srcidx,\n        bytes memory dest,\n        uint256 destidx,\n        uint256 len\n    ) internal view {\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    4,\n                    add(add(src, 32), srcidx),\n                    len,\n                    add(add(dest, 32), destidx),\n                    len\n                )\n            )\n        }\n    }\n}\n"},"TradeHandler.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.17;\n\nimport \"./VM.sol\";\nimport \"./TradeHandlerHelper.sol\";\n\n/**\n@title Trade Handler\n@author yearn.finance\n@notice TradeHandler is in charge of tracking which strategy wants to do certain\ntrade. The strategy registers what they have and what they want and wait for an\nasync trade. TradeHandler trades are executed by mechs through a weiroll VM.\n*/\n\ncontract TradeHandler is VM {\n    address payable public governance;\n    address payable public pendingGovernance;\n\n    // Treasury multisig for sweeps\n    address payable public treasury;\n\n    // COW protocol settlement contract address.\n    address public settlement;\n\n    // Mechs are addresses other than `settlement` that are authorized to\n    // to call `execute()`\n    mapping(address =\u003e bool) public mechs;\n\n    // Solvers are EOAs authorised by COW protocol\u0027s settlement contract to\n    // settle batches won at an auction\n    mapping(address =\u003e bool) public solvers;\n\n    event UpdatedSettlement(address settlement);\n\n    event UpdatedTreasury(address treasury);\n\n    event UpdatedGovernance(address governance);\n\n    event AddedMech(address mech);\n    event RemovedMech(address mech);\n\n    event AddedSolver(address solver);\n    event RemovedSolver(address solver);\n\n    event TradeEnabled(\n        address indexed seller,\n        address indexed tokenIn,\n        address indexed tokenOut\n    );\n    event TradeDisabled(\n        address indexed seller,\n        address indexed tokenIn,\n        address indexed tokenOut\n    );\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    // The settlement contract must be authorized to call `execute()`, but additional\n    // safeguards are needed because solvers other than Seasolver are also authorized\n    // to call settlement.settle().\n    modifier onlyAuthorized() {\n        require(\n            ((msg.sender == settlement) \u0026\u0026 solvers[tx.origin]) ||\n                ((msg.sender != settlement \u0026\u0026 mechs[msg.sender])),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    constructor(address payable _governance) {\n        governance = _governance;\n        treasury = _governance;\n        mechs[_governance] = true;\n    }\n\n    function setGovernance(address payable _governance)\n        external\n        onlyGovernance\n    {\n        pendingGovernance = _governance;\n    }\n\n    function setTreasury(address payable _treasury) external onlyGovernance {\n        treasury = _treasury;\n        emit UpdatedTreasury(_treasury);\n    }\n\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance);\n        governance = pendingGovernance;\n        delete pendingGovernance;\n        emit UpdatedGovernance(governance);\n    }\n\n    function setSettlement(address _settlement) external onlyGovernance {\n        // Settlement can\u0027t be a mech.\n        require(!mechs[_settlement]);\n        settlement = _settlement;\n        emit UpdatedSettlement(_settlement);\n    }\n\n    function addMech(address _mech) external onlyGovernance {\n        // Settlement can\u0027t be set as mech as that would grant\n        // other solvers power to execute.\n        require(settlement != _mech);\n        mechs[_mech] = true;\n        emit AddedMech(_mech);\n    }\n\n    function removeMech(address _mech) external onlyGovernance {\n        delete mechs[_mech];\n        emit RemovedMech(_mech);\n    }\n\n    function addSolver(address _solver) external onlyGovernance {\n        solvers[_solver] = true;\n        emit AddedSolver(_solver);\n    }\n\n    function removeSolver(address _solver) external onlyGovernance {\n        delete solvers[_solver];\n        emit RemovedSolver(_solver);\n    }\n\n    function enable(address _tokenIn, address _tokenOut) external {\n        require(_tokenIn != address(0));\n        require(_tokenOut != address(0));\n\n        emit TradeEnabled(msg.sender, _tokenIn, _tokenOut);\n    }\n\n    function disable(address _tokenIn, address _tokenOut) external {\n        _disable(msg.sender, _tokenIn, _tokenOut);\n    }\n\n    function disableByAdmin(\n        address _strategy,\n        address _tokenIn,\n        address _tokenOut\n    ) external onlyGovernance {\n        _disable(_strategy, _tokenIn, _tokenOut);\n    }\n\n    function _disable(\n        address _strategy,\n        address _tokenIn,\n        address _tokenOut\n    ) internal {\n        emit TradeDisabled(_strategy, _tokenIn, _tokenOut);\n    }\n\n    function execute(bytes32[] calldata commands, bytes[] memory state)\n        external\n        onlyAuthorized\n        returns (bytes[] memory)\n    {\n        return _execute(commands, state);\n    }\n\n    function sweep(address[] calldata _tokens, uint256[] calldata _amounts)\n        external\n    {\n        uint256 _size = _tokens.length;\n        require(_size == _amounts.length);\n\n        for (uint256 i = 0; i \u003c _size; i++) {\n            if (_tokens[i] == address(0)) {\n                // Native ETH\n                TradeHandlerHelper.safeTransferETH(treasury, _amounts[i]);\n            } else {\n                // ERC20s\n                TradeHandlerHelper.safeTransfer(\n                    _tokens[i],\n                    treasury,\n                    _amounts[i]\n                );\n            }\n        }\n    }\n\n    // `fallback` is called when msg.data is not empty\n    fallback() external payable {}\n\n    // `receive` is called when msg.data is empty\n    receive() external payable {}\n}\n"},"TradeHandlerHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary TradeHandlerHelper {\n    function insertElement(\n        bytes calldata tuple,\n        uint256 index,\n        bytes32 element,\n        bool returnRaw\n    ) public pure returns (bytes memory newTuple) {\n        uint256 byteIndex;\n        unchecked {\n            byteIndex = index * 32;\n        }\n        require(byteIndex \u003c= tuple.length);\n        newTuple = bytes.concat(tuple[:byteIndex], element, tuple[byteIndex:]);\n        if (returnRaw) {\n            assembly {\n                return(add(newTuple, 32), tuple.length)\n            }\n        }\n    }\n\n    function replaceElement(\n        bytes calldata tuple,\n        uint256 index,\n        bytes32 element,\n        bool returnRaw\n    ) public pure returns (bytes memory newTuple) {\n        uint256 byteIndex;\n        unchecked {\n            byteIndex = index * 32;\n            require(tuple.length \u003e= 32 \u0026\u0026 byteIndex \u003c= tuple.length - 32);\n            newTuple = bytes.concat(\n                tuple[:byteIndex],\n                element,\n                tuple[byteIndex + 32:]\n            );\n        }\n        if (returnRaw) {\n            assembly {\n                return(add(newTuple, 32), tuple.length)\n            }\n        }\n    }\n\n    function getElement(bytes memory tuple, uint256 index)\n        public\n        pure\n        returns (bytes32)\n    {\n        assembly {\n            return(add(tuple, mul(add(index, 1), 32)), 32)\n        }\n    }\n\n    function power(uint256 a, uint256 b) public pure returns (uint256) {\n        return a**b;\n    }\n\n    function sum(uint256 a, uint256 b) public pure returns (uint256) {\n        return a + b;\n    }\n\n    function subtract(uint256 a, uint256 b) public pure returns (uint256) {\n        return a - b;\n    }\n\n    function multiply(uint256 a, uint256 b) public pure returns (uint256) {\n        return a * b;\n    }\n\n    function divide(uint256 a, uint256 b) public pure returns (uint256) {\n        return a / b;\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(\n                freeMemoryPointer,\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"!transfer\");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(\n                freeMemoryPointer,\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"!transferFrom\");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTransferResult(address token)\n        private\n        view\n        returns (bool success)\n    {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // \u003chttps://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html\u003e\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(\"Error(string)\")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, \"\\x08\\xc3\\x79\\xa0\")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n            // Non-standard ERC20 transfer without return.\n            case 0 {\n                // NOTE: When the return data size is 0, verify that there\n                // is code at the address. This is done in order to maintain\n                // compatibility with Solidity calling conventions.\n                // \u003chttps://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls\u003e\n                if iszero(extcodesize(token)) {\n                    revertWithMessage(20, \"!contract\")\n                }\n\n                success := 1\n            }\n            // Standard ERC20 transfer returning boolean success value.\n            case 32 {\n                returndatacopy(0, 0, returndatasize())\n\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\n                // as `true` for a boolean. In order to stay compatible with\n                // OpenZeppelin\u0027s `SafeERC20` library which is known to work\n                // with the existing ERC20 implementation we care about,\n                // make sure we return success for any non-zero return value\n                // from the `transfer*` call.\n                success := iszero(iszero(mload(0)))\n            }\n            default {\n                revertWithMessage(31, \"malformed\") // malformed transfer result\n            }\n        }\n    }\n\n    function safeTransferETH(address to, uint256 amount) external {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"!safeTransferETH\");\n    }\n}\n"},"VM.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./CommandBuilder.sol\";\n\nabstract contract VM {\n    using CommandBuilder for bytes[];\n\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\n    uint256 constant FLAG_CT_CALL = 0x01;\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\n    uint256 constant FLAG_CT_MASK = 0x03;\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\n\n    uint256 constant SHORT_COMMAND_FILL = 0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    address immutable self;\n\n    error ExecutionFailed(\n        uint256 command_index,\n        address target,\n        string message\n    );\n\n    constructor() {\n        self = address(this);\n    }\n\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\n      internal returns (bytes[] memory)\n    {\n        bytes32 command;\n        uint256 flags;\n        bytes32 indices;\n\n        bool success;\n        bytes memory outdata;\n\n        uint256 commandsLength = commands.length;\n        for (uint256 i; i \u003c commandsLength;) {\n            command = commands[i];\n            flags = uint256(command \u003e\u003e 216) \u0026 0xFF; // more efficient\n            // flags = uint256(uint8(bytes1(command \u003c\u003c 32))); // more readable\n\n            if (flags \u0026 FLAG_EXTENDED_COMMAND != 0) {\n                indices = commands[++i];\n            } else {\n                indices = bytes32(uint256(command \u003c\u003c 40) | SHORT_COMMAND_FILL);\n            }\n\n            if (flags \u0026 FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\n                (success, outdata) = address(uint160(uint256(command))).delegatecall( // target\n                    // inputs\n                    state.buildInputs(\n                        //selector\n                        bytes4(command),\n                        indices\n                    )\n                );\n            } else if (flags \u0026 FLAG_CT_MASK == FLAG_CT_CALL) {\n                (success, outdata) = address(uint160(uint256(command))).call( // target\n                    // inputs\n                    state.buildInputs(\n                        //selector\n                        bytes4(command),\n                        indices\n                    )\n                );\n            } else if (flags \u0026 FLAG_CT_MASK == FLAG_CT_STATICCALL) {\n                (success, outdata) = address(uint160(uint256(command))).staticcall( // target\n                    // inputs\n                    state.buildInputs(\n                        //selector\n                        bytes4(command),\n                        indices\n                    )\n                );\n            } else if (flags \u0026 FLAG_CT_MASK == FLAG_CT_VALUECALL) {\n                uint256 callEth;\n                bytes memory v = state[uint8(bytes1(indices))];\n                require(v.length == 32, \"_execute: value call has no value indicated.\");\n                assembly {\n                    callEth := mload(add(v, 0x20))\n                }\n                (success, outdata) = address(uint160(uint256(command))).call{ // target\n                    value: callEth\n                }(\n                    // inputs\n                    state.buildInputs(\n                        //selector\n                        bytes4(command),\n                        bytes32(uint256(indices \u003c\u003c 8) | CommandBuilder.IDX_END_OF_ARGS)\n                    )\n                );\n            } else {\n                revert(\"Invalid calltype\");\n            }\n\n            if (!success) {\n                if (outdata.length \u003e 0) {\n                    assembly {\n                        outdata := add(outdata, 68)\n                    }\n                }\n                revert ExecutionFailed({\n                    command_index: 0,\n                    target: address(uint160(uint256(command))),\n                    message: outdata.length \u003e 0 ? string(outdata) : \"Unknown\"\n                });\n            }\n\n            if (flags \u0026 FLAG_TUPLE_RETURN != 0) {\n                state.writeTuple(bytes1(command \u003c\u003c 88), outdata);\n            } else {\n                state = state.writeOutputs(bytes1(command \u003c\u003c 88), outdata);\n            }\n            unchecked{++i;}\n        }\n        return state;\n    }\n}\n"}}