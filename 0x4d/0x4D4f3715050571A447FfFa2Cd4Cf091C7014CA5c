{"ApproveAndCallFallBack.sol":{"content":"    //SPDX-License-Identifier: MIT\n    pragma solidity 0.8.5;\n\n\n\n    // ----------------------------------------------------------------------------\n\n    // Contract function to receive approval and execute function in one call\n\n    // Borrowed from MiniMeToken\n\n    // ----------------------------------------------------------------------------\n\n    abstract contract ApproveAndCallFallBack {\n\n        function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual ;\n\n    }\n\n"},"ERC20.sol":{"content":"    //SPDX-License-Identifier: MIT\n    pragma solidity 0.8.5;\n\n\n    // ----------------------------------------------------------------------------\n\n    // ERC Token Standard #20 Interface\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n\n    // ----------------------------------------------------------------------------\n\n    abstract contract ERC20Interface {\n\n        function totalSupply() public view virtual returns (uint);\n\n        function balanceOf(address tokenOwner) public view virtual returns (uint balance);\n\n        function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\n\n        function transfer(address to, uint tokens) public virtual returns (bool success);\n\n        function approve(address spender, uint tokens) public virtual returns (bool success);\n\n        function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n\n\n        event Transfer(address indexed from, address indexed to, uint tokens);\n\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n    }\n\n\n"},"ERC918.sol":{"content":"    //SPDX-License-Identifier: MIT\n    pragma solidity 0.8.5;\n\n\n    // ----------------------------------------------------------------------------\n\n    // ERC Token Standard #918 Interface\n\n    // https://eips.ethereum.org/EIPS/eip-918\n\n    // ----------------------------------------------------------------------------\n\n    interface ERC918  {\n\n        function mint(uint256 nonce) external returns (bool success);\n\n        function getAdjustmentInterval() external view returns (uint);\n\n        function getChallengeNumber() external view returns (bytes32);\n\n        function getMiningDifficulty() external view returns (uint);\n\n        function getMiningTarget() external view returns (uint);\n\n        function getMiningReward() external view returns (uint);\n       \n        function decimals() external view returns (uint8);\n\n\n        event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);\n    }"},"Owned.sol":{"content":"    //SPDX-License-Identifier: MIT\n    pragma solidity 0.8.5;\n\n\n\n    // ----------------------------------------------------------------------------\n\n    // Owned contract\n\n    // ----------------------------------------------------------------------------\n\n    abstract contract Owned {\n\n        address public owner;\n\n        address public newOwner;\n\n\n        event OwnershipTransferred(address indexed _from, address indexed _to);\n\n\n        constructor() {\n\n            owner = msg.sender;\n\n        }\n\n\n        modifier onlyOwner {\n\n            require(msg.sender == owner);\n\n            _;\n\n        }\n\n\n        function transferOwnership(address _newOwner) public onlyOwner {\n\n            require(_newOwner != address(0), \"Invalid address\");\n\n            newOwner = _newOwner;\n\n        }\n\n        function acceptOwnership() external {\n\n            require(msg.sender == newOwner);\n\n            emit OwnershipTransferred(owner, newOwner);\n\n            owner = newOwner;\n\n            newOwner = address(0);\n\n        }\n\n    }\n\n"},"SummerToken.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n\nimport \"./ERC20.sol\";\nimport \"./ERC918.sol\";\nimport \"./Owned.sol\";\nimport \"./ApproveAndCallFallBack.sol\";\n\n\n// ----------------------------------------------------------------------------\n\n// \u0027Summer Token\u0027 contract\n\n// ERC20 \u0026 ERC918 Mineable Token using Proof Of Work\n\n// Symbol      : SUMMER\n\n// Name        : Summer Token\n\n// Total supply: 33,112,800.00\n\n// Decimals    : 18\n\n// Initial mining reward: 140\n\n// Fraction of total supply released before first halving: 1/3\n\n// ----------------------------------------------------------------------------\n\n\n\n\n\ncontract SummerToken is ERC20Interface, ERC918, Owned {\n\n    string private constant SYMBOL = \"SUMMER\";\n\n    string private constant NAME = \"Summer Token\";\n\n    uint256 public constant TOKEN_IDENTIFIER = 2;\n\n    uint8 public constant DECIMALS = 18;\n\n    uint256 public constant TOTAL_SUPPLY = 33112800 * 10**18;\n\n    uint256 public constant INITIAL_REWARD = 140 * 10**18;\n\n    uint256 public constant MAX_REWARDS_AVAILABLE = 72; // no more than 72 rewards per mint\n\n    uint256 public constant REWARD_INTERVAL = 600; // rewards every ten minutes on average\n\n    uint256 public constant DURATION_OF_FIRST_ERA = (365 * 24 * 60 * 60 * 3) / 2; // 18 months\n\n    uint256 public constant DURATION_OF_ERA = 3 * 365 * 24 * 60 * 60; // three years\n\n    uint256 public constant MINIMUM_TARGET = 2**16;\n\n    uint256 public constant MAXIMUM_TARGET = 2**234;\n\n    uint256 public immutable contractCreationTime;\n\n    uint256 public lastRewardBlockTime;\n\n    uint256 public maxNumberOfRewardsPerMint;\n\n    bytes32 private challengeNumber;\n        \n    uint256 private miningTarget;\n\n    uint256 public tokensMinted;\n\n    mapping(address =\u003e uint256) internal balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal allowed;\n\n\n    constructor() {\n\n        miningTarget = MAXIMUM_TARGET / 2**19;\n\n        contractCreationTime = block.timestamp;\n        lastRewardBlockTime = block.timestamp;\n\n        maxNumberOfRewardsPerMint = 1;\n\n        challengeNumber = _getNewChallengeNumber(0);\n\n    }\n\n    function name() public pure returns (string memory) {\n        return NAME;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return SYMBOL;\n    }\n\n    function mint(uint256 nonce) override public returns (bool success) {\n\n        uint256 _lastRewardBlockTime = lastRewardBlockTime;\n        \n        uint256 singleRewardAmount = _getMiningReward(_lastRewardBlockTime);\n\n        // no more minting when reward reaches zero\n        if (singleRewardAmount == 0) revert(\"Reward has reached zero\");\n\n        // the PoW must contain work that includes the challenge number and the msg.sender\u0027s address\n        bytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n\n        uint256 _miningTarget = miningTarget;\n        // the digest must be smaller than the target\n        if (uint256(digest) \u003e _miningTarget) revert(\"Digest is larger than mining target\");\n\n        uint256 _previousMaxNumberOfRewards = maxNumberOfRewardsPerMint;\n        uint256 numberOfRewardsToGive = _numberOfRewardsToGive(_miningTarget / uint256(digest), \n                                                               _lastRewardBlockTime,\n                                                               _previousMaxNumberOfRewards,\n                                                               block.timestamp);\n        uint256 totalRewardAmount = singleRewardAmount * numberOfRewardsToGive;\n\n        uint256 _tokensMinted = _giveRewards(totalRewardAmount);\n        \n        _setNextMaxNumberOfRewards(numberOfRewardsToGive, _previousMaxNumberOfRewards);\n\n        miningTarget = _adjustDifficulty(_miningTarget, _lastRewardBlockTime,\n                                         numberOfRewardsToGive, block.timestamp);\n\n        bytes32 newChallengeNumber = _getNewChallengeNumber(_tokensMinted);\n        challengeNumber = newChallengeNumber;\n\n        lastRewardBlockTime = block.timestamp;\n\n        emit Mint(msg.sender, totalRewardAmount, _scheduledNumberOfRewards(block.timestamp), \n                  newChallengeNumber);\n\n        return true;\n    }\n\n    function _numberOfRewardsAvailable(uint256 _lastRewardBlockTime, \n                                       uint256 _previousMaxNumberOfRewards, \n                                       uint256 currentTime) internal pure returns (uint256) {\n\n        uint256 numberAvailable = _previousMaxNumberOfRewards;\n        uint256 intervalsSinceLastReward = (currentTime - _lastRewardBlockTime) / REWARD_INTERVAL;\n        \n        if (intervalsSinceLastReward \u003e numberAvailable)\n            numberAvailable = intervalsSinceLastReward;\n\n        if (numberAvailable \u003e MAX_REWARDS_AVAILABLE)\n            numberAvailable = MAX_REWARDS_AVAILABLE;\n\n        return numberAvailable;\n    }\n\n    function _numberOfRewardsToGive(uint256 numberEarned, uint256 _lastRewardBlockTime, \n                                    uint256 _previousMaxNumberOfRewards,\n                                    uint256 currentTime) internal pure returns (uint256) {\n\n        uint256 numberAvailable = _numberOfRewardsAvailable(_lastRewardBlockTime,\n                                                         _previousMaxNumberOfRewards,\n                                                         currentTime);\n        if (numberEarned \u003c numberAvailable)\n            return numberEarned;\n\n        return numberAvailable;\n    }\n\n    function _giveRewards(uint256 totalReward) internal returns (uint256) {\n\n        balances[msg.sender] += totalReward;\n        uint256 _tokensMinted = tokensMinted + totalReward;\n        tokensMinted = _tokensMinted;\n        return _tokensMinted;\n    }\n\n    function _setNextMaxNumberOfRewards(uint256 numberOfRewardsGivenNow, \n                                        uint256 _previousMaxNumberOfRewards) internal {\n\n        // the value of the rewards given to this miner presumably exceed the gas costs\n        // for processing the transaction. the next miner can submit a proof of enough work\n        // to claim up to the same number of rewards immediately, or, if gas costs have increased,\n        // wait until the maximum number of rewards claimable has increased enough to overcome\n        // the costs.\n\n        if (numberOfRewardsGivenNow != _previousMaxNumberOfRewards)\n            maxNumberOfRewardsPerMint = numberOfRewardsGivenNow;\n    }\n\n    // backwards compatible mint function\n    function mint(uint256 _nonce, bytes32 _challengeDigest) external returns (bool) {\n\n        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, _nonce));\n        require(digest == _challengeDigest, \"Challenge digest does not match expected digest on token contract\");\n        \n        return mint(_nonce);\n    }\n\n    function _getNewChallengeNumber(uint256 _tokensMinted) internal view returns (bytes32) {\n        \n        // make the latest ethereum block hash a part of the next challenge\n\n        // xor with a number unique to this token to avoid merged mining\n        \n        // xor with the number of tokens minted to ensure that the challenge changes\n        // even if there are multiple mints in the same ethereum block\n        \n        return bytes32(uint256(blockhash(block.number - 1)) ^ _tokensMinted ^ TOKEN_IDENTIFIER);\n    }\n\n\n    function _scheduledNumberOfRewards(uint256 currentTime) internal view returns (uint256) {\n        return (currentTime - contractCreationTime) / REWARD_INTERVAL;\n    }\n\n    function _adjustDifficulty(uint256 _miningTarget, \n                               uint256 _lastRewardBlockTime, \n                               uint256 rewardsGivenNow,\n                               uint256 currentTime) internal pure returns (uint256){\n\n        uint256 timeSinceLastReward = currentTime - _lastRewardBlockTime;\n\n        // we target a median interval of 10 minutes multiplied by log(2) ~ 61/88 \n        // this gives a mean interval of 10 minutes per reward\n\n        if (timeSinceLastReward * 88 \u003c rewardsGivenNow * REWARD_INTERVAL * 61)\n            _miningTarget = (_miningTarget * 99) / 100;   // slow down\n        else\n            _miningTarget = (_miningTarget * 100) / 99;   // speed up\n\n        if (_miningTarget \u003c MINIMUM_TARGET)\n            _miningTarget = MINIMUM_TARGET;\n        \n        if (_miningTarget \u003e MAXIMUM_TARGET) \n            _miningTarget = MAXIMUM_TARGET;\n\n        return _miningTarget;\n    }\n\n\n    function rewardEra(uint256 _time) public view returns (uint256) {\n\n        uint256 timeSinceContractCreation = _time - contractCreationTime;\n\n        if (timeSinceContractCreation \u003c DURATION_OF_FIRST_ERA)\n            return 0;\n        else\n            return 1 + (timeSinceContractCreation - DURATION_OF_FIRST_ERA) / DURATION_OF_ERA;\n    }\n\n    function getAdjustmentInterval() public view override returns (uint256) {\n        return REWARD_INTERVAL * maxNumberOfRewardsPerMint;\n    }\n\n    function getChallengeNumber() public view override returns (bytes32) {\n        return challengeNumber;\n    }\n\n    function getMiningDifficulty() public view override returns (uint256) {\n        // 64 f\u0027s:         1234567890123456789012345678901234567890123456789012345678901234\n        uint256 maxInt = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        return maxInt / miningTarget;\n    }\n\n    function getMiningTarget() public view override returns (uint256) {\n       return miningTarget;\n   }\n\n    function getMiningReward() public view override returns (uint256) {\n\n        // use the timestamp of the ethereum block that gave the last reward\n        // because ethereum miners can manipulate the value of block.timestamp\n        return _getMiningReward(lastRewardBlockTime);\n    }\n\n    function _getMiningReward(uint256 _time) internal view returns (uint256) {\n        return INITIAL_REWARD / 2**rewardEra(_time);\n    }\n\n    function getNumberOfRewardsAvailable(uint256 currentTime) external view returns (uint256) {\n        return _numberOfRewardsAvailable(lastRewardBlockTime, \n                                         maxNumberOfRewardsPerMint, \n                                         currentTime);\n    }\n\n    function getRewardAmountForAchievingTarget(uint256 targetAchieved, uint256 currentTime) external view returns (uint256) {\n        uint256 numberOfRewardsToGive = _numberOfRewardsToGive(miningTarget / targetAchieved, \n                                                               lastRewardBlockTime, \n                                                               maxNumberOfRewardsPerMint, \n                                                               currentTime);\n        return _getMiningReward(currentTime) * numberOfRewardsToGive;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n\n        return tokensMinted;\n    }\n\n\n    // ------------------------------------------------------------------------\n\n    // Get the token balance for account `tokenOwner`\n\n    // ------------------------------------------------------------------------\n\n    function balanceOf(address tokenOwner) public view override returns (uint256 balance) {\n\n        return balances[tokenOwner];\n\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Transfer the balance from token owner\u0027s account to `to` account\n\n    // - Owner\u0027s account must have sufficient balance to transfer\n\n    // - 0 value transfers are allowed\n\n    // ------------------------------------------------------------------------\n\n    function transfer(address to, uint256 tokens) public override returns (bool success) {\n        \n        require(to != address(0) \u0026\u0026 to != address(this), \"Invalid address\");\n        \n        balances[msg.sender] = balances[msg.sender] - tokens;\n\n        balances[to] = balances[to] + tokens;\n\n        emit Transfer(msg.sender, to, tokens);\n\n        return true;\n\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n\n    // from the token owner\u0027s account\n\n    //\n\n    // Warning: This function is vulnerable to double-spend attacks and is\n\n    // included for backwards compatibility. Use safeApprove instead.\n\n    // ------------------------------------------------------------------------\n\n    function approve(address spender, uint256 tokens) public override returns (bool success) {\n        \n        require(spender != address(0) \u0026\u0026 spender != address(this), \"Invalid address\");\n\n        allowed[msg.sender][spender] = tokens;\n\n        emit Approval(msg.sender, spender, tokens);\n\n        return true;\n\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Allow token owner to cancel the approval if the approved amount changes from its last\n\n    // known value before this transaction is processed. This allows the owner to avoid \n\n    // unintentionally re-approving funds that have already been spent.\n\n    // ------------------------------------------------------------------------\n\n    function safeApprove(address spender, uint256 previousAllowance, uint256 newAllowance) external returns (bool success) {\n\n        require(allowed[msg.sender][spender] == previousAllowance,\n                \"Current spender allowance does not match specified value\");\n\n        return approve(spender, newAllowance);\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Transfer `tokens` from the `from` account to the `to` account\n\n    //\n\n    // The calling account must already have sufficient tokens approve(...)-d\n\n    // for spending from the `from` account and\n\n    // - From account must have sufficient balance to transfer\n\n    // - Spender must have sufficient allowance to transfer\n\n    // - 0 value transfers are allowed\n\n    // ------------------------------------------------------------------------\n\n    function transferFrom(address from, address to, uint256 tokens) public override returns (bool success) {\n        \n        require(to != address(0) \u0026\u0026 to != address(this), \"Invalid address\");\n\n        balances[from] = balances[from] - tokens;\n\n        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\n\n        balances[to] = balances[to] + tokens;\n\n        emit Transfer(from, to, tokens);\n\n        return true;\n\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Returns the amount of tokens approved by the owner that can be\n\n    // transferred to the spender\u0027s account\n\n    // ------------------------------------------------------------------------\n\n    function allowance(address tokenOwner, address spender) public view override returns (uint256 remaining){\n\n        return allowed[tokenOwner][spender];\n\n    }\n\n\n    // ------------------------------------------------------------------------\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n\n    // from the token owner\u0027s account. The `spender` contract function\n\n    // `receiveApproval(...)` is then executed. This is vulnerable to double-spend attacks\n\n    // when called directly, so it is declared internal and called by safeApproveAndCall\n\n    // ------------------------------------------------------------------------\n\n    function approveAndCall(address spender, uint256 tokens, bytes memory data) internal returns (bool success) {\n        \n        require(spender != address(0) \u0026\u0026 spender != address(this), \"Invalid address\");\n\n        allowed[msg.sender][spender] = tokens;\n\n        emit Approval(msg.sender, spender, tokens);\n\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n\n        return true;\n\n    }\n\n\n    // ------------------------------------------------------------------------\n\n    // Allow safe approvals with calls to receiving contract\n\n    // ------------------------------------------------------------------------\n\n    function safeApproveAndCall(address spender, uint256 previousAllowance, \n                                uint256 newAllowance, bytes memory data) external returns (bool success) {\n\n        require(allowed[msg.sender][spender] == previousAllowance,\n                \"Current spender allowance does not match specified value\");\n\n        return approveAndCall(spender, newAllowance, data);\n    }\n\n\n    // ------------------------------------------------------------------------\n\n    // Owner can transfer out any accidentally sent ERC20 tokens\n\n    // ------------------------------------------------------------------------\n\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) external onlyOwner returns (bool success) {\n\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n\n    }\n\n}\n"}}