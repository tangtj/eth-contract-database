{"ERC20_Asset_Pool.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./IMultisigControl.sol\";\nimport \"./IERC20.sol\";\n\n/// @title ERC20 Asset Pool\n/// @author Vega Protocol\n/// @notice This contract is the target for all deposits to the ERC20 Bridge via ERC20_Bridge_Logic\ncontract ERC20_Asset_Pool {\n    event Multisig_Control_Set(address indexed new_address);\n    event Bridge_Address_Set(address indexed new_address);\n\n    /// @return Current MultisigControl contract address\n    address public multisig_control_address;\n\n    /// @return Current ERC20_Bridge_Logic contract address\n    address public erc20_bridge_address;\n\n    /// @param multisig_control The initial MultisigControl contract address\n    /// @notice Emits Multisig_Control_Set event\n    constructor(address multisig_control) {\n        require(multisig_control != address(0), \"invalid MultisigControl address\");\n        multisig_control_address = multisig_control;\n        emit Multisig_Control_Set(multisig_control);\n    }\n\n    /// @notice this contract is not intended to accept ether directly\n    receive() external payable {\n        revert(\"this contract does not accept ETH\");\n    }\n\n    /// @param new_address The new MultisigControl contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_multisig_control order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Multisig_Control_Set event\n    function set_multisig_control(\n        address new_address,\n        uint256 nonce,\n        bytes memory signatures\n    ) external {\n        require(new_address != address(0), \"invalid MultisigControl address\");\n        require(is_contract(new_address), \"new address must be contract\");\n\n        bytes memory message = abi.encode(new_address, nonce, \"set_multisig_control\");\n        require(\n            IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        multisig_control_address = new_address;\n        emit Multisig_Control_Set(new_address);\n    }\n\n    /// @param new_address The new ERC20_Bridge_Logic contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_bridge_address order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Bridge_Address_Set event\n    function set_bridge_address(\n        address new_address,\n        uint256 nonce,\n        bytes memory signatures\n    ) external {\n        bytes memory message = abi.encode(new_address, nonce, \"set_bridge_address\");\n        require(\n            IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        erc20_bridge_address = new_address;\n        emit Bridge_Address_Set(new_address);\n    }\n\n    /// @notice This function can only be run by the current \"multisig_control_address\" and, if available, will send the target tokens to the target\n    /// @param token_address Contract address of the ERC20 token to be withdrawn\n    /// @param target Target Ethereum address that the ERC20 tokens will be sent to\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @dev amount is in whatever the lowest decimal value the ERC20 token has. For instance, an 18 decimal ERC20 token, 1 \"amount\" == 0.000000000000000001\n    function withdraw(\n        address token_address,\n        address target,\n        uint256 amount\n    ) external {\n        require(msg.sender == erc20_bridge_address, \"msg.sender not authorized bridge\");\n        require(is_contract(token_address), \"token_address must be contract\");\n\n        (bool success, bytes memory returndata) = token_address.call(\n            abi.encodeWithSignature(\"transfer(address,uint256)\", target, amount)\n        );\n        require(success, \"token transfer failed\");\n\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"token transfer failed\");\n        }\n    }\n\n    function is_contract(address addr) internal view returns (bool) {\n        uint256 code_size;\n        assembly {\n            code_size := extcodesize(addr)\n        }\n        return code_size \u003e 0;\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"ERC20_Bridge_Logic_Restricted.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20_Bridge_Logic_Restricted.sol\";\nimport \"./IMultisigControl.sol\";\nimport \"./ERC20_Asset_Pool.sol\";\n\n/// @title ERC20 Bridge Logic\n/// @author Vega Protocol\n/// @notice This contract is used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the assigned ERC20_Asset_Pool\ncontract ERC20_Bridge_Logic_Restricted is IERC20_Bridge_Logic_Restricted {\n    address payable public erc20_asset_pool_address;\n    // asset address =\u003e is listed\n    mapping(address =\u003e bool) listed_tokens;\n    // Vega asset ID =\u003e asset_source\n    mapping(bytes32 =\u003e address) vega_asset_ids_to_source;\n    // asset_source =\u003e Vega asset ID\n    mapping(address =\u003e bytes32) asset_source_to_vega_asset_id;\n\n    /// @param erc20_asset_pool Initial Asset Pool contract address\n    constructor(address payable erc20_asset_pool) {\n        require(erc20_asset_pool != address(0), \"invalid asset pool address\");\n        erc20_asset_pool_address = erc20_asset_pool;\n    }\n\n    function multisig_control_address() internal view returns (address) {\n        return ERC20_Asset_Pool(erc20_asset_pool_address).multisig_control_address();\n    }\n\n    /***************************FUNCTIONS*************************/\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\n    /// @param lifetime_limit Initial lifetime deposit limit *RESTRICTION FEATURE*\n    /// @param withdraw_threshold Amount at which the withdraw delay goes into effect *RESTRICTION FEATURE*\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Listed if successful\n    function list_asset(\n        address asset_source,\n        bytes32 vega_asset_id,\n        uint256 lifetime_limit,\n        uint256 withdraw_threshold,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        require(asset_source != address(0), \"invalid asset source\");\n        require(!listed_tokens[asset_source], \"asset already listed\");\n        bytes memory message = abi.encode(\n            asset_source,\n            vega_asset_id,\n            lifetime_limit,\n            withdraw_threshold,\n            nonce,\n            \"list_asset\"\n        );\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        listed_tokens[asset_source] = true;\n        vega_asset_ids_to_source[vega_asset_id] = asset_source;\n        asset_source_to_vega_asset_id[asset_source] = vega_asset_id;\n        asset_deposit_lifetime_limit[asset_source] = lifetime_limit;\n        withdraw_thresholds[asset_source] = withdraw_threshold;\n        emit Asset_Listed(asset_source, vega_asset_id, nonce);\n    }\n\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Removed if successful\n    function remove_asset(\n        address asset_source,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        require(listed_tokens[asset_source], \"asset not listed\");\n        bytes memory message = abi.encode(asset_source, nonce, \"remove_asset\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        listed_tokens[asset_source] = false;\n        emit Asset_Removed(asset_source, nonce);\n    }\n\n    /************************RESTRICTIONS***************************/\n    // user =\u003e asset_source =\u003e deposit total\n    mapping(address =\u003e mapping(address =\u003e uint256)) user_lifetime_deposits;\n    // asset_source =\u003e deposit_limit\n    mapping(address =\u003e uint256) asset_deposit_lifetime_limit;\n    uint256 public default_withdraw_delay = 432000;\n    // asset_source =\u003e threshold\n    mapping(address =\u003e uint256) withdraw_thresholds;\n    bool public is_stopped;\n\n    // depositor =\u003e is exempt from deposit limits\n    mapping(address =\u003e bool) exempt_depositors;\n\n    /// @notice This function sets the lifetime maximum deposit for a given asset\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param lifetime_limit Deposit limit for a given ethereum address\n    /// @param threshold Withdraw size above which the withdraw delay goes into effect\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev asset must first be listed\n    function set_asset_limits(\n        address asset_source,\n        uint256 lifetime_limit,\n        uint256 threshold,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external override {\n        require(listed_tokens[asset_source], \"asset not listed\");\n        bytes memory message = abi.encode(asset_source, lifetime_limit, threshold, nonce, \"set_asset_limits\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        asset_deposit_lifetime_limit[asset_source] = lifetime_limit;\n        withdraw_thresholds[asset_source] = threshold;\n\n        emit Asset_Limits_Updated(asset_source, lifetime_limit, threshold);\n    }\n\n    /// @notice This view returns the lifetime deposit limit for the given asset\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Lifetime limit for the given asset\n    function get_asset_deposit_lifetime_limit(address asset_source) external view override returns (uint256) {\n        return asset_deposit_lifetime_limit[asset_source];\n    }\n\n    /// @notice This view returns the given token\u0027s withdraw threshold above which the withdraw delay goes into effect\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Withdraw threshold\n    function get_withdraw_threshold(address asset_source) external view override returns (uint256) {\n        return withdraw_thresholds[asset_source];\n    }\n\n    /// @notice This function sets the withdraw delay for withdrawals over the per-asset set thresholds\n    /// @param delay Amount of time to delay a withdrawal\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    function set_withdraw_delay(\n        uint256 delay,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external override {\n        bytes memory message = abi.encode(delay, nonce, \"set_withdraw_delay\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        default_withdraw_delay = delay;\n        emit Bridge_Withdraw_Delay_Set(delay);\n    }\n\n    /// @notice This function triggers the global bridge stop that halts all withdrawals and deposits until it is resumed\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev bridge must not be stopped already\n    /// @dev emits Bridge_Stopped if successful\n    function global_stop(uint256 nonce, bytes calldata signatures) external override {\n        require(!is_stopped, \"bridge already stopped\");\n        bytes memory message = abi.encode(nonce, \"global_stop\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        is_stopped = true;\n        emit Bridge_Stopped();\n    }\n\n    /// @notice This function resumes bridge operations from the stopped state\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev bridge must be stopped\n    /// @dev emits Bridge_Resumed if successful\n    function global_resume(uint256 nonce, bytes calldata signatures) external override {\n        require(is_stopped, \"bridge not stopped\");\n        bytes memory message = abi.encode(nonce, \"global_resume\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        is_stopped = false;\n        emit Bridge_Resumed();\n    }\n\n    /// @notice this function allows the sender to exempt themselves from the deposit limits\n    /// @notice this feature is specifically for liquidity and rewards providers\n    /// @dev emits Depositor_Exempted if successful\n    function exempt_depositor() external override {\n        require(!exempt_depositors[msg.sender], \"sender already exempt\");\n        exempt_depositors[msg.sender] = true;\n        emit Depositor_Exempted(msg.sender);\n    }\n\n    /// @notice this function allows the exemption_lister to revoke a depositor\u0027s exemption from deposit limits\n    /// @notice this feature is specifically for liquidity and rewards providers\n    /// @dev emits Depositor_Exemption_Revoked if successful\n    function revoke_exempt_depositor() external override {\n        require(exempt_depositors[msg.sender], \"sender not exempt\");\n        exempt_depositors[msg.sender] = false;\n        emit Depositor_Exemption_Revoked(msg.sender);\n    }\n\n    /// @notice this view returns true if the given despoitor address has been exempted from deposit limits\n    /// @param depositor The depositor to check\n    /// @return true if depositor is exempt\n    function is_exempt_depositor(address depositor) external view override returns (bool) {\n        return exempt_depositors[depositor];\n    }\n\n    /***********************END RESTRICTIONS*************************/\n\n    /// @notice This function withdraws assets to the target Ethereum address\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\n    /// @param creation Timestamp of when requestion was created *RESTRICTION FEATURE*\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits Asset_Withdrawn if successful\n    function withdraw_asset(\n        address asset_source,\n        uint256 amount,\n        address target,\n        uint256 creation,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        require(!is_stopped, \"bridge stopped\");\n        require(\n            withdraw_thresholds[asset_source] \u003e amount || creation + default_withdraw_delay \u003c= block.timestamp,\n            \"large withdraw is not old enough\"\n        );\n        bytes memory message = abi.encode(asset_source, amount, target, creation, nonce, \"withdraw_asset\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        ERC20_Asset_Pool(erc20_asset_pool_address).withdraw(asset_source, target, amount);\n        emit Asset_Withdrawn(target, asset_source, amount, nonce);\n    }\n\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of tokens to be deposited into Vega\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\n    /// @dev emits Asset_Deposited if successful\n    /// @dev ERC20 approve function should be run before running this\n    /// @notice ERC20 approve function should be run before running this\n    function deposit_asset(\n        address asset_source,\n        uint256 amount,\n        bytes32 vega_public_key\n    ) external override {\n        require(!is_stopped, \"bridge stopped\");\n\n        if (!exempt_depositors[msg.sender]) {\n            require(\n                user_lifetime_deposits[msg.sender][asset_source] + amount \u003c= asset_deposit_lifetime_limit[asset_source],\n                \"deposit over lifetime limit\"\n            );\n            user_lifetime_deposits[msg.sender][asset_source] += amount;\n        }\n\n        require(listed_tokens[asset_source], \"asset not listed\");\n        require(is_contract(asset_source), \"asset_source must be contract\");\n\n        (bool success, bytes memory returndata) = asset_source.call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\",\n                msg.sender,\n                erc20_asset_pool_address,\n                amount\n            )\n        );\n        require(success, \"token transfer failed\");\n\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"token transfer failed\");\n        }\n\n        emit Asset_Deposited(msg.sender, asset_source, amount, vega_public_key);\n    }\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return True if asset is listed\n    function is_asset_listed(address asset_source) external view override returns (bool) {\n        return listed_tokens[asset_source];\n    }\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() external view override returns (address) {\n        return multisig_control_address();\n    }\n\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return The assigned Vega Asset Id for given ERC20 token\n    function get_vega_asset_id(address asset_source) external view override returns (bytes32) {\n        return asset_source_to_vega_asset_id[asset_source];\n    }\n\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\n    /// @return The ERC20 token contract address for a given Vega Asset Id\n    function get_asset_source(bytes32 vega_asset_id) external view override returns (address) {\n        return vega_asset_ids_to_source[vega_asset_id];\n    }\n\n    function is_contract(address addr) internal view returns (bool) {\n        uint256 code_size;\n        assembly {\n            code_size := extcodesize(addr)\n        }\n        return code_size \u003e 0;\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"ETH_Asset_Pool.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./IMultisigControl.sol\";\n\n/// @title ETH Asset Pool\n/// @author Vega Protocol\n/// @notice This contract is the target for all deposits to the ETH Bridge via ETH_Bridge_Logic\ncontract ETH_Asset_Pool {\n    event Multisig_Control_Set(address indexed new_address);\n    event Bridge_Address_Set(address indexed new_address);\n    event Received(address indexed sender, uint256 amount);\n\n    /// @return Current MultisigControl contract address\n    address public multisig_control_address;\n\n    /// @return Current ETH_Bridge_Logic contract address\n    address public ETH_bridge_address;\n\n    /// @param multisig_control The initial MultisigControl contract address\n    /// @notice Emits Multisig_Control_Set event\n    constructor(address multisig_control) {\n        require(multisig_control != address(0), \"invalid MultisigControl address\");\n        multisig_control_address = multisig_control;\n        emit Multisig_Control_Set(multisig_control);\n    }\n\n    /// @param new_address The new MultisigControl contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_multisig_control order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Multisig_Control_Set event\n    function set_multisig_control(\n        address new_address,\n        uint256 nonce,\n        bytes memory signatures\n    ) external {\n        require(new_address != address(0), \"invalid MultisigControl address\");\n        uint256 size;\n        assembly {\n            size := extcodesize(new_address)\n        }\n        require(size \u003e 0, \"new address must be contract\");\n        bytes memory message = abi.encode(new_address, nonce, \"set_multisig_control\");\n        require(\n            IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        multisig_control_address = new_address;\n        emit Multisig_Control_Set(new_address);\n    }\n\n    /// @param new_address The new ETH_Bridge_Logic contract address.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_bridge_address order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Emits Bridge_Address_Set event\n    function set_bridge_address(\n        address new_address,\n        uint256 nonce,\n        bytes memory signatures\n    ) external {\n        require(new_address != address(0), \"invalid bridge address\");\n        bytes memory message = abi.encode(new_address, nonce, \"set_bridge_address\");\n        require(\n            IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        ETH_bridge_address = new_address;\n        emit Bridge_Address_Set(new_address);\n    }\n\n    /// @notice This function can only be run by the current \"multisig_control_address\" and, if available, will send the target eth to the target\n    /// @param target Target Ethereum address that the ETH will be sent to\n    /// @param amount Amount of ETH to withdraw\n    /// @dev amount is in wei, 1 wei == 0.000000000000000001 ETH\n    function withdraw(address payable target, uint256 amount) external {\n        require(target != address(0), \"invalid target address\");\n        require(msg.sender == ETH_bridge_address, \"msg.sender not authorized bridge\");\n        /// @dev reentry is protected by the non-reusable nonce in the signature check in the ETH_Bridge_Logic\n        (bool success, ) = target.call{value: amount}(\"\");\n        require(success, \"eth transfer failed\");\n    }\n\n    /// @notice A contract can have at most one receive function,\n    /// declared using receive() external payable { ... }\n    /// (without the function keyword). This function cannot have arguments,\n    /// cannot return anything and must have external visibility and payable state\n    /// mutability. It is executed on a call to the contract with empty calldata.\n    /// This is the function that is executed on plain Ether transfers (e.g. via .send()\n    /// or .transfer()). If no such function exists, but a payable fallback\n    /// function exists, the fallback function will be called on a plain Ether\n    /// transfer. If neither a receive Ether nor a payable fallback function is\n    /// present, the contract cannot receive Ether through regular transactions\n    /// and throws an exception.\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"ETH_Bridge_Logic.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./IETH_Bridge_Logic.sol\";\nimport \"./IMultisigControl.sol\";\nimport \"./ETH_Asset_Pool.sol\";\n\n/// @title ETH Bridge Logic\n/// @author Vega Protocol\n/// @notice This contract is used by Vega network users to deposit and withdraw ETH to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the assigned ETH_Asset_Pool\ncontract ETH_Bridge_Logic is IETH_Bridge_Logic {\n    address payable ETH_asset_pool_address;\n\n    // minimum deposit amt\n    uint256 minimum_deposit;\n    // maximum deposit amt\n    uint256 maximum_deposit;\n\n    /// @param ETH_asset_pool Initial Asset Pool contract address\n    constructor(address payable ETH_asset_pool) {\n        require(ETH_asset_pool != address(0), \"invalid asset pool address\");\n        ETH_asset_pool_address = ETH_asset_pool;\n    }\n\n    function multisig_control_address() internal view returns (address) {\n        return ETH_Asset_Pool(ETH_asset_pool_address).multisig_control_address();\n    }\n\n    /// @notice This function sets the minimum allowable deposit for ETH\n    /// @param minimum_amount Minimum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits ETH_Deposit_Minimum_Set if successful\n    function set_deposit_minimum(\n        uint256 minimum_amount,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        bytes memory message = abi.encode(minimum_amount, nonce, \"set_deposit_minimum\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        minimum_deposit = minimum_amount;\n        emit ETH_Deposit_Minimum_Set(minimum_amount, nonce);\n    }\n\n    /// @notice This function sets the maximum allowable deposit for ETH\n    /// @param maximum_amount Maximum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits ETH_Deposit_Maximum_Set if successful\n    function set_deposit_maximum(\n        uint256 maximum_amount,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        bytes memory message = abi.encode(maximum_amount, nonce, \"set_deposit_maximum\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        maximum_deposit = maximum_amount;\n        emit ETH_Deposit_Maximum_Set(maximum_amount, nonce);\n    }\n\n    /// @notice This function allows the withdrawal of ETH\n    /// @param amount Amount of ETH to withdraw\n    /// @param expiry Vega-assigned timestamp of withdrawal order expiration\n    /// @param target Target Ethereum address to receive withdrawn ETH\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits ETH_Withdrawn if successful\n    function withdraw_asset(\n        uint256 amount,\n        uint256 expiry,\n        address payable target,\n        uint256 nonce,\n        bytes memory signatures\n    ) external override {\n        require(expiry \u003e block.timestamp, \"withdrawal has expired\");\n        bytes memory message = abi.encode(amount, expiry, target, nonce, \"withdraw_asset\");\n        require(\n            IMultisigControl(multisig_control_address()).verify_signatures(signatures, message, nonce),\n            \"bad signatures\"\n        );\n        ETH_Asset_Pool(ETH_asset_pool_address).withdraw(target, amount);\n        emit ETH_Withdrawn(target, amount, nonce);\n    }\n\n    /// @notice This function allows a user to deposit ETH into Vega\n    /// @param vega_public_key Target vega public key to be credited with this deposit\n    /// @dev Emits ETH_Deposited if successful\n    function deposit_asset(bytes32 vega_public_key) external payable override {\n        require(maximum_deposit == 0 || msg.value \u003c= maximum_deposit, \"deposit above maximum\");\n        require(msg.value \u003e= minimum_deposit, \"deposit below minimum\");\n        ETH_asset_pool_address.transfer(msg.value);\n        emit ETH_Deposited(msg.sender, msg.value, vega_public_key);\n    }\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns minimum valid deposit\n    /// @return Minimum valid deposit of ETH\n    function get_deposit_minimum() external view override returns (uint256) {\n        return minimum_deposit;\n    }\n\n    /// @notice This view returns maximum valid deposit\n    /// @return Maximum valid deposit of ETH\n    function get_deposit_maximum() external view override returns (uint256) {\n        return maximum_deposit;\n    }\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() external view override returns (address) {\n        return multisig_control_address();\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20_Bridge_Logic_Restricted.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\n/// @title ERC20 Bridge Logic Interface\n/// @author Vega Protocol\n/// @notice Implementations of this interface are used by Vega network users to deposit and withdraw ERC20 tokens to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the ERC20_Asset_Pool\nabstract contract IERC20_Bridge_Logic_Restricted {\n    /***************************EVENTS****************************/\n    event Asset_Withdrawn(address indexed user_address, address indexed asset_source, uint256 amount, uint256 nonce);\n    event Asset_Deposited(\n        address indexed user_address,\n        address indexed asset_source,\n        uint256 amount,\n        bytes32 vega_public_key\n    );\n    event Asset_Listed(address indexed asset_source, bytes32 indexed vega_asset_id, uint256 nonce);\n    event Asset_Removed(address indexed asset_source, uint256 nonce);\n    event Asset_Limits_Updated(address indexed asset_source, uint256 lifetime_limit, uint256 withdraw_threshold);\n    event Bridge_Withdraw_Delay_Set(uint256 withdraw_delay);\n    event Bridge_Stopped();\n    event Bridge_Resumed();\n    event Depositor_Exempted(address indexed depositor);\n    event Depositor_Exemption_Revoked(address indexed depositor);\n\n    /***************************FUNCTIONS*************************/\n    /// @notice This function lists the given ERC20 token contract as valid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param vega_asset_id Vega-generated asset ID for internal use in Vega Core\n    /// @param lifetime_limit Initial lifetime deposit limit *RESTRICTION FEATURE*\n    /// @param withdraw_threshold Amount at which the withdraw delay goes into effect *RESTRICTION FEATURE*\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Listed if successful\n    function list_asset(\n        address asset_source,\n        bytes32 vega_asset_id,\n        uint256 lifetime_limit,\n        uint256 withdraw_threshold,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice This function removes from listing the given ERC20 token contract. This marks the token as invalid for deposit to this bridge\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Removed if successful\n    function remove_asset(\n        address asset_source,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice This function sets the lifetime maximum deposit for a given asset\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param lifetime_limit Deposit limit for a given ethereum address\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev asset must first be listed\n    function set_asset_limits(\n        address asset_source,\n        uint256 lifetime_limit,\n        uint256 threshold,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external virtual;\n\n    /// @notice This function sets the withdraw delay for withdrawals over the per-asset set thresholds\n    /// @param delay Amount of time to delay a withdrawal\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    function set_withdraw_delay(\n        uint256 delay,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external virtual;\n\n    /// @notice This function triggers the global bridge stop that halts all withdrawals and deposits until it is resumed\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev bridge must not be stopped already\n    /// @dev MUST emit Bridge_Stopped if successful\n    function global_stop(uint256 nonce, bytes calldata signatures) external virtual;\n\n    /// @notice This function resumes bridge operations from the stopped state\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @dev bridge must be stopped\n    /// @dev MUST emit Bridge_Resumed if successful\n    function global_resume(uint256 nonce, bytes calldata signatures) external virtual;\n\n    /// @notice this function allows the exemption_lister to exempt a depositor from the deposit limits\n    /// @notice this feature is specifically for liquidity and rewards providers\n    /// @dev MUST emit Depositor_Exempted if successful\n    function exempt_depositor() external virtual;\n\n    /// @notice this function allows the exemption_lister to revoke a depositor\u0027s exemption from deposit limits\n    /// @notice this feature is specifically for liquidity and rewards providers\n    /// @dev MUST emit Depositor_Exemption_Revoked if successful\n    function revoke_exempt_depositor() external virtual;\n\n    /// @notice This function withdrawals assets to the target Ethereum address\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of ERC20 tokens to withdraw\n    /// @param target Target Ethereum address to receive withdrawn ERC20 tokens\n    /// @param creation Timestamp of when requestion was created *RESTRICTION FEATURE*\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Withdrawn if successful\n    function withdraw_asset(\n        address asset_source,\n        uint256 amount,\n        address target,\n        uint256 creation,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice this view returns true if the given despoitor address has been exempted from deposit limits\n    /// @param depositor The depositor to check\n    /// @return true if depositor is exempt\n    function is_exempt_depositor(address depositor) external view virtual returns (bool);\n\n    /// @notice This function allows a user to deposit given ERC20 tokens into Vega\n    /// @param asset_source Contract address for given ERC20 token\n    /// @param amount Amount of tokens to be deposited into Vega\n    /// @param vega_public_key Target Vega public key to be credited with this deposit\n    /// @dev MUST emit Asset_Deposited if successful\n    /// @dev ERC20 approve function should be run before running this\n    /// @notice ERC20 approve function should be run before running this\n    function deposit_asset(\n        address asset_source,\n        uint256 amount,\n        bytes32 vega_public_key\n    ) external virtual;\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns true if the given ERC20 token contract has been listed valid for deposit\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return True if asset is listed\n    function is_asset_listed(address asset_source) external view virtual returns (bool);\n\n    /// @notice This view returns the lifetime deposit limit for the given asset\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Lifetime limit for the given asset\n    function get_asset_deposit_lifetime_limit(address asset_source) external view virtual returns (uint256);\n\n    /// @notice This view returns the given token\u0027s withdraw threshold above which the withdraw delay goes into effect\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return Withdraw threshold\n    function get_withdraw_threshold(address asset_source) external view virtual returns (uint256);\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() external view virtual returns (address);\n\n    /// @param asset_source Contract address for given ERC20 token\n    /// @return The assigned Vega Asset ID for given ERC20 token\n    function get_vega_asset_id(address asset_source) external view virtual returns (bytes32);\n\n    /// @param vega_asset_id Vega-assigned asset ID for which you want the ERC20 token address\n    /// @return The ERC20 token contract address for a given Vega Asset ID\n    function get_asset_source(bytes32 vega_asset_id) external view virtual returns (address);\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"IETH_Bridge_Logic.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\n/// @title ETH Bridge Logic Interface\n/// @author Vega Protocol\n/// @notice Implementations of this interface are used by Vega network users to deposit and withdraw ETH to/from Vega.\n// @notice All funds deposited/withdrawn are to/from the ETH_Asset_Pool\nabstract contract IETH_Bridge_Logic {\n    /***************************EVENTS****************************/\n    event ETH_Withdrawn(address indexed user_address, uint256 amount, uint256 nonce);\n    event ETH_Deposited(address indexed user_address, uint256 amount, bytes32 vega_public_key);\n    event ETH_Deposit_Minimum_Set(uint256 new_minimum, uint256 nonce);\n    event ETH_Deposit_Maximum_Set(uint256 new_maximum, uint256 nonce);\n\n    /***************************FUNCTIONS*************************/\n    /// @notice This function sets the minimum allowable deposit for ETH\n    /// @param minimum_amount Minimum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Deposit_Minimum_Set if successful\n    function set_deposit_minimum(\n        uint256 minimum_amount,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice This function sets the maximum allowable deposit for ETH\n    /// @param maximum_amount Maximum deposit amount\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Deposit_Maximum_Set if successful\n    function set_deposit_maximum(\n        uint256 maximum_amount,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice This function withdraws assets to the target Ethereum address\n    /// @param amount Amount of ETH to withdraw\n    /// @param expiry Vega-assigned timestamp of withdrawal order expiration\n    /// @param target Target Ethereum address to receive withdrawn ETH\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit Asset_Withdrawn if successful\n    function withdraw_asset(\n        uint256 amount,\n        uint256 expiry,\n        address payable target,\n        uint256 nonce,\n        bytes memory signatures\n    ) external virtual;\n\n    /// @notice This function allows a user to deposit ETH into Vega\n    /// @param vega_public_key Target vega public key to be credited with this deposit\n    /// @dev MUST emit Asset_Deposited if successful\n    /// @dev ETH approve function should be run before running this\n    /// @notice ETH approve function should be run before running this\n    function deposit_asset(bytes32 vega_public_key) external payable virtual;\n\n    /***************************VIEWS*****************************/\n    /// @notice This view returns minimum valid deposit\n    /// @return Minimum valid deposit of ETH\n    function get_deposit_minimum() external view virtual returns (uint256);\n\n    /// @notice This view returns maximum valid deposit\n    /// @return Maximum valid deposit of ETH\n    function get_deposit_maximum() external view virtual returns (uint256);\n\n    /// @return current multisig_control_address\n    function get_multisig_control_address() external view virtual returns (address);\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"IMultisigControl.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\n/// @title MultisigControl Interface\n/// @author Vega Protocol\n/// @notice Implementations of this interface are used by the Vega network to control smart contracts without the need for Vega to have any Ethereum of its own.\n/// @notice To do this, the Vega validators sign a MultisigControl order to construct a signature bundle. Any interested party can then take that signature bundle and pay the gas to run the command on Ethereum\nabstract contract IMultisigControl {\n    /***************************EVENTS****************************/\n    event SignerAdded(address new_signer, uint256 nonce);\n    event SignerRemoved(address old_signer, uint256 nonce);\n    event ThresholdSet(uint16 new_threshold, uint256 nonce);\n    event NonceBurnt(uint256 nonce);\n\n    /**************************FUNCTIONS*********************/\n    /// @notice Sets threshold of signatures that must be met before function is executed.\n    /// @param new_threshold New threshold value\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\n    /// @notice signatures are OK if they are \u003e= threshold count of total valid signers\n    /// @dev MUST emit ThresholdSet event\n    function set_threshold(\n        uint16 new_threshold,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external virtual;\n\n    /// @notice Adds new valid signer and adjusts signer count.\n    /// @param new_signer New signer address\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit \u0027SignerAdded\u0027 event\n    function add_signer(\n        address new_signer,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external virtual;\n\n    /// @notice Removes currently valid signer and adjusts signer count.\n    /// @param old_signer Address of signer to be removed.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev MUST emit \u0027SignerRemoved\u0027 event\n    function remove_signer(\n        address old_signer,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external virtual;\n\n    /// @notice Burn an nonce before it gets used by a user. Useful in case the validators needs to prevents a malicious user to do un-permitted action.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits \u0027NonceBurnt\u0027 event\n    function burn_nonce(uint256 nonce, bytes calldata signatures) external virtual;\n\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\n    /// @notice message to hash to sign follows this pattern:\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\n    /// @notice Note that validating_contract_or_submitter_address is the the submitting party. If on MultisigControl contract itself, it\u0027s the submitting ETH address\n    /// @notice if function on bridge that then calls Multisig, then it\u0027s the address of that contract\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\n    /// @return MUST return true if valid signatures are over the threshold\n    function verify_signatures(\n        bytes calldata signatures,\n        bytes memory message,\n        uint256 nonce\n    ) public virtual returns (bool);\n\n    /**********************VIEWS*********************/\n    /// @return Number of valid signers\n    function get_valid_signer_count() external view virtual returns (uint8);\n\n    /// @return Current threshold\n    function get_current_threshold() external view virtual returns (uint16);\n\n    /// @param signer_address target potential signer address\n    /// @return true if address provided is valid signer\n    function is_valid_signer(address signer_address) external view virtual returns (bool);\n\n    /// @param nonce Nonce to lookup\n    /// @return true if nonce has been used\n    function is_nonce_used(uint256 nonce) external view virtual returns (bool);\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"},"MultisigControl.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./IMultisigControl.sol\";\n\n/// @title MultisigControl\n/// @author Vega Protocol\n/// @notice This contract enables validators, through a multisignature process, to run functions on contracts by consensus\ncontract MultisigControl is IMultisigControl {\n    constructor() {\n        // set initial threshold to 50%\n        threshold = 500;\n        signers[msg.sender] = true;\n        signer_count++;\n        emit SignerAdded(msg.sender, 0);\n    }\n\n    uint16 threshold;\n    uint8 signer_count;\n    mapping(address =\u003e bool) public signers;\n    mapping(uint256 =\u003e bool) used_nonces;\n\n    /**************************FUNCTIONS*********************/\n    /// @notice Sets threshold of signatures that must be met before function is executed.\n    /// @param new_threshold New threshold value\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\n    /// @notice signatures are OK if they are \u003e= threshold count of total valid signers\n    /// @dev Emits ThresholdSet event\n    function set_threshold(\n        uint16 new_threshold,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external override {\n        require(new_threshold \u003c 1000 \u0026\u0026 new_threshold \u003e 0, \"new threshold outside range\");\n        bytes memory message = abi.encode(new_threshold, nonce, \"set_threshold\");\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\n        threshold = new_threshold;\n        emit ThresholdSet(new_threshold, nonce);\n    }\n\n    /// @notice Adds new valid signer and adjusts signer count.\n    /// @param new_signer New signer address\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits \u0027SignerAdded\u0027 event\n    function add_signer(\n        address new_signer,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external override {\n        bytes memory message = abi.encode(new_signer, nonce, \"add_signer\");\n        require(!signers[new_signer], \"signer already exists\");\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\n        signers[new_signer] = true;\n        signer_count++;\n        emit SignerAdded(new_signer, nonce);\n    }\n\n    /// @notice Removes currently valid signer and adjusts signer count.\n    /// @param old_signer Address of signer to be removed.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits \u0027SignerRemoved\u0027 event\n    function remove_signer(\n        address old_signer,\n        uint256 nonce,\n        bytes calldata signatures\n    ) external override {\n        bytes memory message = abi.encode(old_signer, nonce, \"remove_signer\");\n        require(signers[old_signer], \"signer doesn\u0027t exist\");\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\n        signers[old_signer] = false;\n        signer_count--;\n        emit SignerRemoved(old_signer, nonce);\n    }\n\n    /// @notice Burn an nonce before it gets used by a user. Useful in case the validators needs to prevents a malicious user to do un-permitted action.\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\n    /// @notice See MultisigControl for more about signatures\n    /// @dev Emits \u0027NonceBurnt\u0027 event\n    function burn_nonce(uint256 nonce, bytes calldata signatures) external override {\n        bytes memory message = abi.encode(nonce, \"burn_nonce\");\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\n        emit NonceBurnt(nonce);\n    }\n\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\n    /// @notice message to hash to sign follows this pattern:\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\n    /// @notice Note that validating_contract_or_submitter_address is the submitting party. If on MultisigControl contract itself, it\u0027s the submitting ETH address\n    /// @notice if function on bridge that then calls Multisig, then it\u0027s the address of that contract\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\n    /// @return Returns true if valid signatures are over the threshold\n    function verify_signatures(\n        bytes calldata signatures,\n        bytes memory message,\n        uint256 nonce\n    ) public override returns (bool) {\n        require(signatures.length % 65 == 0, \"bad sig length\");\n        require(signatures.length \u003e 0, \"must contain at least 1 sig\");\n        require(!used_nonces[nonce], \"nonce already used\");\n\n        uint8 size = 0;\n        address[] memory signers_temp = new address[](signer_count);\n\n        bytes32 message_hash = keccak256(abi.encode(message, msg.sender));\n        uint256 offset;\n        assembly {\n            offset := signatures.offset\n        }\n        for (uint256 msg_idx = 0; msg_idx \u003c signatures.length; msg_idx += 65) {\n            //recover address from that msg\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                // first 32 bytes, after the length prefix\n                r := calldataload(add(offset, msg_idx))\n                // second 32 bytes\n                s := calldataload(add(add(offset, msg_idx), 32))\n                // final byte (first byte of the next 32 bytes)\n                v := byte(0, calldataload(add(add(offset, msg_idx), 64)))\n            }\n            // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n            // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n            // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n            // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n            //\n            // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n            // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n            // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n            // these malleable signatures as well.\n            require(\n                uint256(s) \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n                \"Malleable signature error\"\n            );\n            if (v \u003c 27) v += 27;\n\n            address recovered_address = ecrecover(message_hash, v, r, s);\n\n            if (signers[recovered_address] \u0026\u0026 !has_signed(signers_temp, recovered_address, size)) {\n                signers_temp[size] = recovered_address;\n                size++;\n            }\n        }\n\n        used_nonces[nonce] = ((uint256(size) * 1000) / (uint256(signer_count))) \u003e threshold;\n        return used_nonces[nonce];\n    }\n\n    function has_signed(\n        address[] memory signers_temp,\n        address signer,\n        uint8 size\n    ) private pure returns (bool) {\n        for (uint256 i; i \u003c size; i++) {\n            if (signers_temp[i] == signer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @return Number of valid signers\n    function get_valid_signer_count() external view override returns (uint8) {\n        return signer_count;\n    }\n\n    /// @return Current threshold\n    function get_current_threshold() external view override returns (uint16) {\n        return threshold;\n    }\n\n    /// @param signer_address target potential signer address\n    /// @return true if address provided is valid signer\n    function is_valid_signer(address signer_address) external view override returns (bool) {\n        return signers[signer_address];\n    }\n\n    /// @param nonce Nonce to lookup\n    /// @return true if nonce has been used\n    function is_nonce_used(uint256 nonce) external view override returns (bool) {\n        return used_nonces[nonce];\n    }\n}\n\n/**\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................MMM\nMMMMZ.............................+MM....................DDD\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\n"}}