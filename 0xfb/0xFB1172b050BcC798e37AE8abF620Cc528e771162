{"GoMeat.sol":{"content":"pragma solidity  0.4.24;\nimport \u0027./SafeMath.sol\u0027;\n\n/**\n\n    GOMT Token implementation\n\n*/\n\ncontract GOMT is SafeMath {\n\n    string public constant standard = \u0027Token 0.1\u0027;\n\n    uint8 public constant decimals = 8;\n\n \n\n    string public constant name = \u0027GoMeat\u0027;\n\n    string public constant symbol = \u0027GOMT\u0027;\n\n   \n\n    uint256 public constant totalSupply = 10 ** 6 * 5 * 10 ** uint256(decimals);\n\n \n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n \n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n \n\n    function GOMT()\n\n    public{\n\n        balanceOf[msg.sender] = totalSupply;\n\n    }\n\n \n\n    modifier validAddress(address _address) {\n\n        require(_address != 0x0);\n\n        _;\n\n    }\n\n \n\n    function transfer(address _to, uint256 _value)\n\n    external\n\n    validAddress(_to)\n\n    returns(bool success)\n\n    {\n\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n\n    }\n\n \n\n    function transferFrom(address _from, address _to, uint256 _value)\n\n    external\n\n    validAddress(_from)\n\n    validAddress(_to)\n\n    returns(bool success)\n\n    {\n\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\n\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n\n        Transfer(_from, _to, _value);\n\n        return true;\n\n    }\n\n \n\n    function approve(address _spender, uint256 _value)\n\n    external\n\n    validAddress(_spender)\n\n    returns(bool success)\n\n    {\n\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n\n        allowance[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n \n\n    function () public payable {\n\n        revert();\n\n    }\n\n}"},"SafeMath.sol":{"content":"pragma solidity  0.4.24;\n\n/* taking ideas from FirstBlood token */\ncontract SafeMath {\n\n    function SafeMath() public {\n    }\n\n    function safeAdd(uint256 _x, uint256 _y) pure internal returns(uint256) {\n        uint256 z = _x + _y;\n        //assert replaced with require *\n        require(z \u003e= _x);\n        return z;\n    }\n\n    function safeSub(uint256 _x, uint256 _y) pure internal returns(uint256) {\n        //assert replaced with require *\n        require(_x \u003e= _y);\n        return _x - _y;\n    }\n\n    function safeMul(uint256 _x, uint256 _y) pure internal returns(uint256) {\n        uint256 z = _x * _y;\n        //assert replaced with require *\n        require(_x == 0 || z / _x == _y);\n        return z;\n    }\n\n}"}}