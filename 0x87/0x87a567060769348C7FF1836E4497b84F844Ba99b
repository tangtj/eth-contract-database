{"Adapter.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./AdapterHelper.sol\";\n\ncontract Adapter is AdapterHelper {\n\n    constructor(\n        address _tokenProfitAddress,\n        address _uniV2RouterAddress,\n        address _liquidNFTsRouterAddress,\n        address _liquidNFTsWETHPool,\n        address _liquidNFTsUSDCPool\n    )\n        AdapterDeclarations(\n            _tokenProfitAddress,\n            _uniV2RouterAddress,\n            _liquidNFTsRouterAddress,\n            _liquidNFTsWETHPool,\n            _liquidNFTsUSDCPool\n        )\n    {\n        admin = tx.origin;\n        multisig = tx.origin;\n    }\n\n    /**\n    * @dev Overview for services and ability to syncronize them\n    */\n    function syncServices()\n        external\n    {\n        liquidNFTsUSDCPool.manualSyncPool();\n        liquidNFTsWETHPool.manualSyncPool();\n    }\n\n    /**\n    * @dev Allows admin to swap USDC for ETH using UniswapV2\n    */\n    function swapUSDCForETH(\n        uint256 _amount,\n        uint256 _minAmountOut\n    )\n        external\n        onlyMultiSig\n        returns (\n            uint256 amountIn,\n            uint256 amountOut\n        )\n    {\n        address[] memory path = new address[](2);\n\n        path[0] = USDC_ADDRESS;\n        path[1] = WETH_ADDRESS;\n\n        uint256[] memory amounts = _executeSwap(\n            path,\n            _amount,\n            _minAmountOut\n        );\n\n        emit AdminSwap(\n            USDC_ADDRESS,\n            WETH_ADDRESS,\n            amounts[0],\n            amounts[1]\n        );\n\n        return (\n            amounts[0],\n            amounts[1]\n        );\n    }\n\n    function _precisionWithFee()\n        internal\n        view\n        returns (uint256)\n    {\n        return FEE_PRECISION + buyFee;\n    }\n\n    /**\n    * @dev Calculates tokens to mint given exact ETH amount\n    * input for the TokenProfit contract during mint\n    */\n    function getTokenAmountFromEthAmount(\n        uint256 _ethAmount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return tokenProfit.totalSupply()\n            * _ethAmount\n            * FEE_PRECISION\n            / _precisionWithFee()\n            / _calculateTotalEthValue(\n                0\n            );\n    }\n\n    /**\n    * @dev Calculates ETH amount necessary to pay to\n    * receive fixed token amount from the TokenProfit contract\n    */\n    function getEthAmountFromTokenAmount(\n        uint256 _tokenAmount,\n        uint256 _msgValue\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _calculateTotalEthValue(\n            _msgValue\n        )\n            * _tokenAmount\n            * PRECISION_FACTOR\n            * _precisionWithFee()\n            / FEE_PRECISION\n            / tokenProfit.totalSupply()\n            / PRECISION_FACTOR;\n    }\n\n    function proposeNewMultisig(\n        address _proposedMultisig\n    )\n        external\n        onlyMultiSig\n    {\n        address oldProposedMultisig = proposedMultisig;\n        proposedMultisig = _proposedMultisig;\n\n        emit MultisigUpdateProposed(\n            oldProposedMultisig,\n            _proposedMultisig\n        );\n    }\n\n    function claimMultisigOwnership()\n        external\n        onlyProposedMultisig\n    {\n        address oldMultisig = multisig;\n        multisig = proposedMultisig;\n        proposedMultisig = ZERO_ADDRESS;\n\n        emit MultisigUpdate(\n            oldMultisig,\n            multisig\n        );\n    }\n\n    /**\n    * @dev Starts the process to change the admin address\n    */\n    function proposeNewAdmin(\n        address _newProposedAdmin\n    )\n        external\n        onlyMultiSig\n    {\n        address oldProposedAdmin = proposedAdmin;\n        proposedAdmin = _newProposedAdmin;\n\n        emit AdminUpdateProposed(\n            oldProposedAdmin,\n            _newProposedAdmin\n        );\n    }\n\n   /**\n    * @dev Finalize the change of the admin address\n    */\n    function claimAdminOwnership()\n        external\n        onlyProposedAdmin\n    {\n        address oldAdmin = admin;\n        admin = proposedAdmin;\n        proposedAdmin = ZERO_ADDRESS;\n\n        emit AdminUpdate(\n            oldAdmin,\n            admin\n        );\n    }\n\n    /**\n    * @dev Ability for multisig to change the buy fee\n    */\n    function changeBuyFee(\n        uint256 _newFeeValue\n    )\n        external\n        onlyMultiSig\n    {\n        require(\n            FEE_THRESHOLD \u003e _newFeeValue,\n            \"Adapter: FEE_TOO_HIGH\"\n        );\n\n        require(\n            _newFeeValue \u003e FEE_LOWER_BOUND,\n            \"Adapter: FEE_TOO_LOW\"\n        );\n\n        uint256 oldValue = buyFee;\n        buyFee = _newFeeValue;\n\n        emit BuyFeeChanged(\n            oldValue,\n            _newFeeValue\n        );\n    }\n\n    /**\n    * @dev Allows multisig to swap ETH for USDC using UniswapV2\n    */\n    function swapETHforUSDC(\n        uint256 _amount,\n        uint256 _minAmountOut\n    )\n        external\n        onlyMultiSig\n        returns (\n            uint256 amountIn,\n            uint256 amountOut\n        )\n    {\n        address[] memory path = new address[](2);\n\n        path[0] = WETH_ADDRESS;\n        path[1] = USDC_ADDRESS;\n\n        uint256[] memory amounts = _executeSwapWithValue(\n            path,\n            _amount,\n            _minAmountOut\n        );\n\n        emit AdminSwap(\n            WETH_ADDRESS,\n            USDC_ADDRESS,\n            amounts[0],\n            amounts[1]\n        );\n\n        return (\n            amounts[0],\n            amounts[1]\n        );\n    }\n\n    /**\n    * @dev Allows admin to deposit ETH into LiquidNFTs pool\n    */\n    function depositETHLiquidNFTs(\n        uint256 _amount\n    )\n        external\n        onlyAdmin\n    {\n        _wrapETH(\n            _amount\n        );\n\n        _depositLiquidNFTsWrapper(\n            liquidNFTsWETHPool,\n            _amount\n        );\n    }\n\n    /**\n    * @dev Allows admin to deposit USDC into LiquidNFTs pool\n    */\n    function depositUSDCLiquidNFTs(\n        uint256 _amount\n    )\n        external\n        onlyAdmin\n    {\n        _depositLiquidNFTsWrapper(\n            liquidNFTsUSDCPool,\n            _amount\n        );\n    }\n\n    /**\n    * @dev Allows admin to withdraw USDC from LiquidNFTs pool\n    */\n    function withdrawUSDCLiquidNFTs(\n        uint256 _amount\n    )\n        external\n        onlyAdmin\n    {\n        _withdrawLiquidNFTsWrapper(\n            liquidNFTsUSDCPool,\n            _amount\n        );\n    }\n\n    /**\n    * @dev Allows admin to withdraw ETH from LiquidNFTs pool\n    */\n    function withdrawETHLiquidNFTs(\n        uint256 _amount\n    )\n        external\n        onlyAdmin\n    {\n        _withdrawLiquidNFTsWrapper(\n            liquidNFTsWETHPool,\n            _amount\n        );\n\n        _unwrapETH(\n            WETH.balanceOf(\n                TOKEN_PROFIT_ADDRESS\n            )\n        );\n    }\n\n    /**\n    * @dev Allows TokenProfit contract to withdraw tokens from services\n    */\n    function assistWithdrawTokens(\n        uint256 _index,\n        uint256 _amount\n    )\n        external\n        onlyTokenProfit\n        returns (uint256)\n    {\n        if (tokens[_index].tokenERC20 == USDC) {\n            return _USDCRoutine(\n                _amount\n            );\n        }\n\n        revert InvalidToken();\n    }\n\n    /**\n    * @dev Allows TokenProfit contract to withdraw ETH from services\n    */\n    function assistWithdrawETH(\n        uint256 _amount\n    )\n        external\n        onlyTokenProfit\n        returns (uint256)\n    {\n        return _WETHRoutine(\n            _amount\n        );\n    }\n}\n"},"AdapterDeclarations.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./AdapterInterfaces.sol\";\n\nerror InvalidFeed();\nerror InvalidToken();\nerror InvalidDecimals();\n\ncontract AdapterDeclarations {\n\n    struct TokenData {\n        IERC20 tokenERC20;\n        IChainLink feedLink;\n        uint8 feedDecimals;\n        uint8 tokenDecimals;\n    }\n\n    uint256 constant TOKENS = 1;\n    TokenData[TOKENS] public tokens;\n\n    IERC20 public immutable WETH;\n    IERC20 public immutable USDC;\n\n    address public immutable WETH_ADDRESS;\n    address public immutable USDC_ADDRESS;\n\n    address public immutable TOKEN_PROFIT_ADDRESS;\n    address public immutable UNIV2_ROUTER_ADDRESS;\n    address public immutable LIQUID_NFT_ROUTER_ADDRESS;\n\n    ITokenProfit public immutable tokenProfit;\n    ILiquidNFTsPool public immutable liquidNFTsWETHPool;\n    ILiquidNFTsPool public immutable liquidNFTsUSDCPool;\n\n    address public admin;\n    address public multisig;\n    address public proposedMultisig;\n    address public proposedAdmin;\n\n    uint256 public buyFee = 1000;\n\n    uint256 constant public FEE_PRECISION = 1E4;\n    uint256 constant public FEE_THRESHOLD = 50000;\n    uint256 constant public FEE_LOWER_BOUND = 10;\n    uint256 constant public PRECISION_FACTOR = 1E18;\n\n    uint80 constant MAX_ROUND_COUNT = 50;\n    address constant ZERO_ADDRESS = address(0x0);\n    uint256 constant UINT256_MAX = type(uint256).max;\n\n    mapping(address =\u003e uint256) public chainLinkHeartBeat;\n\n    modifier onlyAdmin() {\n        require(\n            msg.sender == admin,\n            \"AdapterDeclarations: NOT_ADMIN\"\n        );\n        _;\n    }\n\n    modifier onlyTokenProfit() {\n        require(\n            msg.sender == TOKEN_PROFIT_ADDRESS,\n            \"AdapterDeclarations: NOT_TOKEN_PROFIT\"\n        );\n        _;\n    }\n\n    modifier onlyProposedMultisig() {\n        require(\n            msg.sender == proposedMultisig,\n            \"AdapterDeclarations: NOT_PROPOSED_MULTISIG\"\n        );\n        _;\n    }\n\n    modifier onlyProposedAdmin() {\n        require(\n            msg.sender == proposedAdmin,\n            \"AdapterDeclarations: NOT_PROPOSED_ADMIN\"\n        );\n        _;\n    }\n\n    modifier onlyMultiSig() {\n        require(\n            msg.sender == multisig,\n            \"AdapterDeclarations: NOT_MULTISIG\"\n        );\n        _;\n    }\n\n    event AdminSwap(\n        address indexed from,\n        address indexed to,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    event BuyFeeChanged(\n        uint256 indexed oldFee,\n        uint256 indexed newFee\n    );\n\n    event MultisigUpdate(\n        address oldMultisig,\n        address newMultisig\n    );\n\n    event MultisigUpdateProposed(\n        address oldProposedMultisig,\n        address newProposedMultisig\n    );\n\n    event AdminUpdate(\n        address oldAdmin,\n        address newAdmin\n    );\n\n    event AdminUpdateProposed(\n        address oldProposedAdmin,\n        address newProposedAdmin\n    );\n\n    constructor(\n        address _tokenProfitAddress,\n        address _uniV2RouterAddress,\n        address _liquidNFTsRouterAddress,\n        address _liquidNFTsWETHPool,\n        address _liquidNFTsUSDCPool\n    ) {\n        // --- liquidNFTs group ---\n\n        liquidNFTsWETHPool = ILiquidNFTsPool(\n            _liquidNFTsWETHPool\n        );\n\n        liquidNFTsUSDCPool = ILiquidNFTsPool(\n            _liquidNFTsUSDCPool\n        );\n\n        LIQUID_NFT_ROUTER_ADDRESS = _liquidNFTsRouterAddress;\n\n        // --- token group ---\n\n        USDC_ADDRESS = liquidNFTsUSDCPool.poolToken();\n        WETH_ADDRESS = liquidNFTsWETHPool.poolToken();\n\n        USDC = IERC20(\n            USDC_ADDRESS\n        );\n\n        WETH = IWETH(\n            WETH_ADDRESS\n        );\n\n        IChainLink chainLinkFeed = IChainLink(\n            0x986b5E1e1755e3C2440e960477f25201B0a8bbD4\n        );\n\n        tokens[0] = TokenData({\n            tokenERC20: USDC,\n            feedLink: chainLinkFeed,\n            feedDecimals: chainLinkFeed.decimals(),\n            tokenDecimals: USDC.decimals()\n        });\n\n        _validateData();\n\n        // --- tokenProfit group ---\n\n        tokenProfit = ITokenProfit(\n            _tokenProfitAddress\n        );\n\n        TOKEN_PROFIT_ADDRESS = _tokenProfitAddress;\n        UNIV2_ROUTER_ADDRESS = _uniV2RouterAddress;\n    }\n\n    function _validateData()\n        private\n    {\n        for (uint256 i = 0; i \u003c TOKENS; i++) {\n\n            TokenData memory token = tokens[i];\n\n            if (token.tokenDecimals == 0) {\n                revert InvalidDecimals();\n            }\n\n            if (token.feedDecimals == 0) {\n                revert InvalidDecimals();\n            }\n\n            if (token.tokenERC20 == IERC20(ZERO_ADDRESS)) {\n                revert InvalidToken();\n            }\n\n            if (token.feedLink == IChainLink(ZERO_ADDRESS)) {\n                revert InvalidFeed();\n            }\n\n            string memory expectedFeedName = string.concat(\n                token.tokenERC20.symbol(),\n                \" / \"\n                \"ETH\"\n            );\n\n            string memory chainLinkFeedName = token.feedLink.description();\n\n            require(\n                keccak256(abi.encodePacked(expectedFeedName)) ==\n                keccak256(abi.encodePacked(chainLinkFeedName)),\n                \"AdapterDeclarations: INVALID_CHAINLINK_FEED\"\n            );\n\n            recalibrate(\n                address(token.feedLink)\n            );\n        }\n    }\n\n    /**\n     * @dev Determines info for the heartbeat update\n     *  mechanism for chainlink oracles (roundIds)\n     */\n    function getLatestAggregatorRoundId(\n        IChainLink _feed\n    )\n        public\n        view\n        returns (uint80)\n    {\n        (\n            uint80 roundId,\n            ,\n            ,\n            ,\n        ) = _feed.latestRoundData();\n\n        return uint64(roundId);\n    }\n\n    /**\n     * @dev Determines number of iterations necessary during recalibrating\n     * heartbeat.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80)\n    {\n        return _latestAggregatorRoundId \u003e MAX_ROUND_COUNT\n            ? MAX_ROUND_COUNT\n            : _latestAggregatorRoundId;\n    }\n\n    /**\n     * @dev fetches timestamp of a byteshifted aggregatorRound with specific\n     * phaseID. For more info see chainlink historical price data documentation\n     */\n    function _getRoundTimestamp(\n        IChainLink _feed,\n        uint16 _phaseId,\n        uint80 _aggregatorRoundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp,\n        ) = _feed.getRoundData(\n            getRoundIdByByteShift(\n                _phaseId,\n                _aggregatorRoundId\n            )\n        );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Determines info for the heartbeat update mechanism for chainlink\n     * oracles (shifted round Ids)\n     */\n    function getRoundIdByByteShift(\n        uint16 _phaseId,\n        uint80 _aggregatorRoundId\n    )\n        public\n        pure\n        returns (uint80)\n    {\n        return uint80(uint256(_phaseId) \u003c\u003c 64 | _aggregatorRoundId);\n    }\n\n    /**\n     * @dev Function to recalibrate the heartbeat for a specific feed\n     */\n    function recalibrate(\n        address _feed\n    )\n        public\n    {\n        chainLinkHeartBeat[_feed] = recalibratePreview(\n            IChainLink(_feed)\n        );\n    }\n\n    /**\n    * @dev View function to determine the heartbeat for a specific feed\n    * Looks at the maximal last 50 rounds and takes second highest value to\n    * avoid counting offline time of chainlink as valid heartbeat\n    */\n    function recalibratePreview(\n        IChainLink _feed\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint80 latestAggregatorRoundId = getLatestAggregatorRoundId(\n            _feed\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestAggregatorRoundId\n        );\n\n        if (iterationCount \u003c 2) {\n            revert(\"LiquidRouter: SMALL_SAMPLE\");\n        }\n\n        uint16 phaseId = _feed.phaseId();\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _feed,\n            phaseId,\n            latestAggregatorRoundId\n        );\n\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        for (uint80 i = 1; i \u003c iterationCount; i++) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _feed,\n                phaseId,\n                latestAggregatorRoundId - i\n            );\n\n            currentDiff = latestTimestamp - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff \u003e= currentBiggest) {\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n            } else if (currentDiff \u003e currentSecondBiggest \u0026\u0026 currentDiff \u003c currentBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    function setApprovals()\n        external\n    {\n        address[2] memory spenders = [\n            UNIV2_ROUTER_ADDRESS,\n            LIQUID_NFT_ROUTER_ADDRESS\n        ];\n\n        for (uint256 i = 0; i \u003c spenders.length; i++) {\n            for (uint256 j = 0; j \u003c tokens.length; j++) {\n                tokenProfit.executeAdapterRequest(\n                    address(tokens[j].tokenERC20),\n                    abi.encodeWithSelector(\n                        IERC20.approve.selector,\n                        spenders[i],\n                        UINT256_MAX\n                    )\n                );\n            }\n            tokenProfit.executeAdapterRequest(\n                WETH_ADDRESS,\n                abi.encodeWithSelector(\n                    IERC20.approve.selector,\n                    spenders[i],\n                    UINT256_MAX\n                )\n            );\n        }\n    }\n}\n"},"AdapterHelper.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./AdapterDeclarations.sol\";\n\nerror SlippageTooBig();\nerror ChainLinkOffline();\n\nabstract contract AdapterHelper is AdapterDeclarations {\n\n    /**\n    * @dev Tells TokenProfit contract to perform a swap through UniswapV2 starting with ETH\n    */\n    function _executeSwapWithValue(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minAmountOut\n    )\n        internal\n        returns (uint256[] memory)\n    {\n        if (_minAmountOut == 0) {\n            revert SlippageTooBig();\n        }\n\n        bytes memory callbackData = tokenProfit.executeAdapterRequestWithValue(\n            UNIV2_ROUTER_ADDRESS,\n            abi.encodeWithSelector(\n                IUniswapV2.swapExactETHForTokens.selector,\n                _minAmountOut,\n                _path,\n                TOKEN_PROFIT_ADDRESS,\n                block.timestamp\n            ),\n            _amount\n        );\n\n        return abi.decode(\n            callbackData,\n            (\n                uint256[]\n            )\n        );\n    }\n\n    /**\n    * @dev checks if chainLink price feeds are still operating\n    */\n    function isChainlinkOffline()\n        public\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i \u003c TOKENS; i++) {\n\n            IChainLink feed = tokens[i].feedLink;\n\n            (   ,\n                ,\n                ,\n                uint256 upd\n                ,\n            ) = feed.latestRoundData();\n\n            upd = block.timestamp \u003e upd\n                ? block.timestamp - upd\n                : block.timestamp;\n\n            if (upd \u003e chainLinkHeartBeat[address(feed)]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n    * @dev Calculates ETH and token balances available for services\n    * --------------------------------\n    * availableEther is ETH balance of the TokenProfit contract\n    * availableTokens is balances of all tokens in TokenProfit contract\n    * etherAmount is availableEther + ETH deposited in other services\n    * tokenAmounts is availableTokens + tokens deposited in other services\n    */\n    function getTokenAmounts()\n        public\n        view\n        returns (\n            uint256 etherAmount,\n            uint256[] memory tokensAmounts,\n            uint256 availableEther,\n            uint256[] memory availableAmounts\n        )\n    {\n        uint256[] memory tokenAmounts = new uint256[](TOKENS);\n        uint256[] memory availableTokens = new uint256[](TOKENS);\n\n        (\n            availableEther,\n            availableTokens\n        ) = _getAvailableFunds();\n\n        for (uint256 i = 0; i \u003c TOKENS; i++) {\n            tokenAmounts[i] = _getReservesByToken(\n                tokens[i].tokenERC20\n            ) + availableTokens[i];\n        }\n\n        etherAmount = _calculateAmountFromShares(\n            liquidNFTsWETHPool,\n            TOKEN_PROFIT_ADDRESS\n        ) + availableEther;\n\n        return (\n            etherAmount,\n            tokenAmounts,\n            availableEther,\n            availableTokens\n        );\n    }\n\n    function _calculateTotalEthValue(\n        uint256 _msgValue\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isChainlinkOffline() == true) {\n            revert ChainLinkOffline();\n        }\n\n        (\n            uint256 etherAmount,\n            uint256[] memory tokensAmounts,\n            ,\n        ) = getTokenAmounts();\n\n        for (uint256 i = 0; i \u003c TOKENS; i++) {\n\n            TokenData memory token = tokens[i];\n            IChainLink feed = token.feedLink;\n\n            uint256 latestAnswer = feed.latestAnswer();\n\n            require(\n                latestAnswer \u003e 0,\n                \"AdapterHelper: CHAINLINK_OFFLINE\"\n            );\n\n            etherAmount += feed.latestAnswer()\n                * PRECISION_FACTOR\n                * tokensAmounts[i]\n                / (10 ** token.tokenDecimals)\n                / (10 ** token.feedDecimals);\n        }\n\n        return etherAmount\n            - _msgValue;\n    }\n\n    /**\n    * @dev Tells TokenProfit contract to perform\n    * a swap through UniswapV2 starting with Tokens\n    */\n    function _executeSwap(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minAmountOut\n    )\n        internal\n        returns (uint256[] memory)\n    {\n        if (_minAmountOut == 0) {\n            revert SlippageTooBig();\n        }\n\n        bytes memory callbackData = tokenProfit.executeAdapterRequest(\n            UNIV2_ROUTER_ADDRESS,\n            abi.encodeWithSelector(\n                IUniswapV2.swapExactTokensForETH.selector,\n                _amount,\n                _minAmountOut,\n                _path,\n                TOKEN_PROFIT_ADDRESS,\n                block.timestamp\n            )\n        );\n\n        return abi.decode(\n            callbackData,\n            (\n                uint256[]\n            )\n        );\n    }\n\n    /**\n    * @dev Tells TokenProfit contract to convert WETH to ETH\n    */\n    function _unwrapETH(\n        uint256 _amount\n    )\n        internal\n    {\n        tokenProfit.executeAdapterRequest(\n            WETH_ADDRESS,\n            abi.encodeWithSelector(\n                IWETH.withdraw.selector,\n                _amount\n            )\n        );\n    }\n\n    /**\n    * @dev Tells TokenProfit contract to convert ETH to WETH\n    */\n    function _wrapETH(\n        uint256 _amount\n    )\n        internal\n    {\n        tokenProfit.executeAdapterRequestWithValue(\n            WETH_ADDRESS,\n            abi.encodeWithSelector(\n                IWETH.deposit.selector\n            ),\n            _amount\n        );\n    }\n\n    /**\n    * @dev Tells TokenProfit contract to deposit funds into LiquidNFTs pool\n    */\n    function _depositLiquidNFTsWrapper(\n        ILiquidNFTsPool _pool,\n        uint256 _amount\n    )\n        internal\n    {\n        tokenProfit.executeAdapterRequest(\n            LIQUID_NFT_ROUTER_ADDRESS,\n            abi.encodeWithSelector(\n                ILiquidNFTsRouter.depositFunds.selector,\n                _amount,\n                _pool\n            )\n        );\n    }\n\n    /**\n    * @dev Tells TokenProfit contract to withdraw funds from LiquidNFTs pool\n    */\n    function _withdrawLiquidNFTsWrapper(\n        ILiquidNFTsPool _pool,\n        uint256 _amount\n    )\n        internal\n    {\n        tokenProfit.executeAdapterRequest(\n            LIQUID_NFT_ROUTER_ADDRESS,\n            abi.encodeWithSelector(\n                ILiquidNFTsRouter.withdrawFunds.selector,\n                _calculateSharesFromAmount(\n                    _pool,\n                    _amount\n                ),\n                _pool\n            )\n        );\n    }\n\n    /**\n    * @dev Routine used to deal with all services withdrawing USDC\n    */\n    function _USDCRoutine(\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 balanceBefore = USDC.balanceOf(\n            TOKEN_PROFIT_ADDRESS\n        );\n\n        _withdrawLiquidNFTsWrapper(\n            liquidNFTsUSDCPool,\n            _amount\n        );\n\n        uint256 balanceAfter = USDC.balanceOf(\n            TOKEN_PROFIT_ADDRESS\n        );\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n    * @dev Routine used to deal with all services withdrawing ETH\n    */\n    function _WETHRoutine(\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        _withdrawLiquidNFTsWrapper(\n            liquidNFTsWETHPool,\n            _amount\n        );\n\n        uint256 balance = WETH.balanceOf(\n            TOKEN_PROFIT_ADDRESS\n        );\n\n        _unwrapETH(\n            balance\n        );\n\n        return balance;\n    }\n\n    /**\n    * @dev Returns balances of TokenProfit contract - tokens and ETH\n    */\n    function _getAvailableFunds()\n        internal\n        view\n        returns (\n            uint256,\n            uint256[] memory\n        )\n    {\n        uint256[] memory availableTokens = new uint256[](TOKENS);\n\n        for (uint256 i = 0; i \u003c TOKENS; i++) {\n            IERC20 token = tokens[i].tokenERC20;\n            availableTokens[i] = token.balanceOf(\n                TOKEN_PROFIT_ADDRESS\n            );\n        }\n\n        uint256 availableEther = TOKEN_PROFIT_ADDRESS.balance;\n\n        return (\n            availableEther,\n            availableTokens\n        );\n    }\n\n    /**\n    * @dev Returns balances locked in servcies based on token\n    */\n    function _getReservesByToken(\n        IERC20 _token\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (_token == USDC) {\n            return _calculateAmountFromShares(\n                liquidNFTsUSDCPool,\n                TOKEN_PROFIT_ADDRESS\n            );\n        }\n\n        return 0;\n    }\n\n    /**\n    * @dev Helper function to calculate shares from amount for LiquidNFTs pool\n    */\n    function _calculateSharesFromAmount(\n        ILiquidNFTsPool _pool,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amountSharesCalculationWrapper(\n            _pool.totalInternalShares(),\n            _pool.pseudoTotalTokensHeld(),\n            _amount\n        );\n    }\n\n    /**\n    * @dev Helper function to calculate amount from shares for LiquidNFTs pool\n    */\n    function _calculateAmountFromShares(\n        ILiquidNFTsPool _pool,\n        address _sharesHolder\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amountSharesCalculationWrapper(\n            _pool.pseudoTotalTokensHeld(),\n            _pool.totalInternalShares(),\n            _pool.internalShares(\n                _sharesHolder\n            )\n        );\n    }\n\n    /**\n    * @dev Calculates ratios based on shares and amount\n    */\n    function _amountSharesCalculationWrapper(\n        uint256 _totalValue,\n        uint256 _correspondingTotalValue,\n        uint256 _amountValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalValue\n            * _amountValue\n            / _correspondingTotalValue;\n    }\n}\n"},"AdapterInterfaces.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./IERC20.sol\";\n\ninterface IChainLink {\n\n    function decimals()\n        external\n        view\n        returns (uint8);\n\n    function latestAnswer()\n        external\n        view\n        returns (uint256);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answerdInRound\n        );\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function phaseId()\n        external\n        view\n        returns(\n            uint16 phaseId\n        );\n\n    function aggregator()\n        external\n        view\n        returns (address);\n\n    function description()\n        external\n        view\n        returns (string memory);\n}\n\ninterface ITokenProfit {\n\n    function getAvailableMint()\n        external\n        view\n        returns (uint256);\n\n    function executeAdapterRequest(\n        address _contractToCall,\n        bytes memory _callBytes\n    )\n        external\n        returns (bytes memory);\n\n    function executeAdapterRequestWithValue(\n        address _contractToCall,\n        bytes memory _callBytes,\n        uint256 _value\n    )\n        external\n        returns (bytes memory);\n\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n}\n\ninterface ILiquidNFTsRouter {\n\n    function depositFunds(\n        uint256 _amount,\n        address _pool\n    )\n        external;\n\n    function withdrawFunds(\n        uint256 _amount,\n        address _pool\n    )\n        external;\n}\n\ninterface ILiquidNFTsPool {\n\n    function pseudoTotalTokensHeld()\n        external\n        view\n        returns (uint256);\n\n    function totalInternalShares()\n        external\n        view\n        returns (uint256);\n\n    function manualSyncPool()\n        external;\n\n    function internalShares(\n        address _user\n    )\n        external\n        view\n        returns (uint256);\n\n    function poolToken()\n        external\n        view\n        returns (address);\n\n    function chainLinkETH()\n        external\n        view\n        returns (address);\n}\n\ninterface IUniswapV2 {\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n      external\n      payable\n      returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n       uint256 amountIn,\n       uint256 amountOutMin,\n       address[] calldata path,\n       address to,\n       uint256 deadline\n   )\n       external\n       returns (uint256[] memory amounts);\n}\n\ninterface IWETH is IERC20 {\n\n    function deposit()\n        payable\n        external;\n\n    function withdraw(\n        uint256 _amount\n    )\n        external;\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\ninterface IERC20 {\n\n    function transfer(\n        address _to,\n        uint256 _amount\n    )\n        external;\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        external;\n\n    function balanceOf(\n        address _account\n    )\n        external\n        view\n        returns (uint256);\n\n    function approve(\n        address _spender,\n        uint256 _amount\n    )\n        external;\n\n    function allowance(\n        address _user,\n        address _spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function decimals()\n        external\n        view\n        returns (uint8);\n\n    function symbol()\n        external\n        view\n        returns (string memory);\n}\n"},"TokenBase.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./IERC20.sol\";\n\ncontract TokenBase {\n\n    string public constant name = \"WISEr Token\";\n    string public constant symbol = \"WISEr\";\n    uint8 public constant decimals = 18;\n\n    address constant ZERO_ADDRESS = address(0);\n    uint256 constant UINT256_MAX = type(uint256).max;\n\n    uint256 public totalSupply;\n\n    uint256 public constant INITIAL_TOTAL_SUPPLY = 1E27;\n    uint256 public constant MIN_ETH_AMOUNT = 1E5;\n\n    mapping(address =\u003e uint256) public balanceOf;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n    mapping(address =\u003e uint256) public nonces;\n\n    bytes32 public immutable DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Received(\n        address indexed from,\n        uint256 indexed amount\n    );\n\n    event SupplyPurchase(\n        address indexed buyer,\n        uint256 ethAmount,\n        uint256 tokenAmountReceived,\n        uint256 indexed appliedFee\n    );\n\n    event RewardsRedeemed(\n        uint256 _burnAmount,\n        uint256[] tokenRedeemAmounts,\n        uint256 etherRedeemAmount\n    );\n\n    constructor() {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        totalSupply =\n        totalSupply + _value;\n\n        unchecked {\n            balanceOf[_to] =\n            balanceOf[_to] + _value;\n        }\n\n        emit Transfer(\n            ZERO_ADDRESS,\n            _to,\n            _value\n        );\n    }\n\n    function _burn(\n        address _from,\n        uint256 _value\n    )\n        internal\n    {\n        unchecked {\n            totalSupply =\n            totalSupply - _value;\n        }\n\n        balanceOf[_from] =\n        balanceOf[_from] - _value;\n\n        emit Transfer(\n            _from,\n            ZERO_ADDRESS,\n            _value\n        );\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _value\n    )\n        private\n    {\n        allowance[_owner][_spender] = _value;\n\n        emit Approval(\n            _owner,\n            _spender,\n            _value\n        );\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        private\n    {\n        balanceOf[_from] =\n        balanceOf[_from] - _value;\n\n        unchecked {\n            balanceOf[_to] =\n            balanceOf[_to] + _value;\n        }\n\n        emit Transfer(\n            _from,\n            _to,\n            _value\n        );\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            _spender,\n            _value\n        );\n\n        return true;\n    }\n\n    function increaseAllowance(\n        address _spender,\n        uint256 _addedValue\n    )\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            _spender,\n            allowance[msg.sender][_spender] + _addedValue\n        );\n\n        return true;\n    }\n\n    function decreaseAllowance(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            _spender,\n            allowance[msg.sender][_spender] - _subtractedValue\n        );\n\n        return true;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        _transfer(\n            msg.sender,\n            _to,\n            _value\n        );\n\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        external\n        returns (bool)\n    {\n        if (allowance[_from][msg.sender] != UINT256_MAX) {\n            allowance[_from][msg.sender] -= _value;\n        }\n\n        _transfer(\n            _from,\n            _to,\n            _value\n        );\n\n        return true;\n    }\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(\n            _deadline \u003e= block.timestamp,\n            \"TokenBase: PERMIT_CALL_EXPIRED\"\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        _owner,\n                        _spender,\n                        _value,\n                        nonces[_owner]++,\n                        _deadline\n                    )\n                )\n            )\n        );\n\n        if (uint256(_s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"TokenBase: INVALID_SIGNATURE\");\n        }\n\n        address recoveredAddress = ecrecover(\n            digest,\n            _v,\n            _r,\n            _s\n        );\n\n        require(\n            recoveredAddress != ZERO_ADDRESS \u0026\u0026\n            recoveredAddress == _owner,\n            \"TokenBase: INVALID_SIGNATURE\"\n        );\n\n        _approve(\n            _owner,\n            _spender,\n            _value\n        );\n    }\n}\n"},"TokenProfit.sol":{"content":"// SPDX-License-Identifier: --DAO--\n\n/**\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\npragma solidity =0.8.19;\n\nimport \"./Adapter.sol\";\nimport \"./TokenBase.sol\";\n\nerror Prevented();\nerror ExecuteFailed();\nerror InvalidAmount(\n    uint256 provided,\n    uint256 required\n);\n\ncontract TokenProfit is TokenBase {\n\n    Adapter public adapter;\n\n    address public adapterContract;\n    address public governanceContract;\n\n    address public immutable auctionContract;\n    uint256 constant PRECISION_FACTOR = 1E18;\n\n    bool public extraMintAllowed;\n\n    uint256 status;\n    uint256 constant ENTERED = 1;\n    uint256 constant NOT_ENTERED = 2;\n\n    modifier nonReentrant() {\n        nonReentrantBefore();\n        _;\n        nonReentrantAfter();\n    }\n\n    function nonReentrantBefore()\n        private\n    {\n        if (status == ENTERED) {\n            revert Prevented();\n        }\n\n        status = ENTERED;\n    }\n\n    function nonReentrantAfter()\n        private\n    {\n        status = NOT_ENTERED;\n    }\n\n    modifier onlyAdapter() {\n        require(\n            msg.sender == adapterContract,\n            \"TokenProfit: NOT_ADAPTER\"\n        );\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(\n            msg.sender == governanceContract,\n            \"TokenProfit: NOT_GOVERNANCE\"\n        );\n        _;\n    }\n\n    modifier syncAdapter() {\n        adapter.syncServices();\n        _;\n    }\n\n    receive()\n        external\n        payable\n    {\n        emit Received(\n            msg.sender,\n            msg.value\n        );\n    }\n\n    constructor(\n        address _auctionContract,\n        address _uniV2RouterAddress,\n        address _liquidNFTsRouterAddress,\n        address _liquidNFTsWETHPool,\n        address _liquidNFTsUSDCPool\n    ) {\n        adapter = new Adapter(\n            address(this),\n            _uniV2RouterAddress,\n            _liquidNFTsRouterAddress,\n            _liquidNFTsWETHPool,\n            _liquidNFTsUSDCPool\n        );\n\n        auctionContract = _auctionContract;\n        adapterContract = address(adapter);\n        governanceContract = msg.sender;\n\n        status = NOT_ENTERED;\n    }\n\n    /**\n    * @dev Allows to execute contract call controlled by Adapter contract\n    */\n    function executeAdapterRequest(\n        address _contractAddress,\n        bytes memory _callBytes\n    )\n        external\n        onlyAdapter\n        returns (bytes memory)\n    {\n        (\n            bool success,\n            bytes memory returnData\n        ) = _contractAddress.call(\n            _callBytes\n        );\n\n        if (success == false) {\n            revert ExecuteFailed();\n        }\n\n        return returnData;\n    }\n\n    /**\n    * @dev Allows to execute contract call defined by Adapter contract\n    */\n    function executeAdapterRequestWithValue(\n        address _callAddress,\n        bytes memory _callBytes,\n        uint256 _callValue\n    )\n        external\n        onlyAdapter\n        returns (bytes memory)\n    {\n        (\n            bool success,\n            bytes memory returnData\n        ) = _callAddress.call{value: _callValue}(\n            _callBytes\n        );\n\n        if (success == false) {\n            revert ExecuteFailed();\n        }\n\n        return returnData;\n    }\n\n    /**\n    * @dev Allows to change Adapter contract\n    */\n    function changeAdapter(\n        address _newAdapterAddress\n    )\n        external\n        onlyGovernance\n    {\n        adapterContract = _newAdapterAddress;\n\n        adapter = Adapter(\n            _newAdapterAddress\n        );\n    }\n\n    /**\n    * @dev Returns total amount of tokens controlled by Adapter contract\n    */\n    function getTotalTokenAmount(\n        uint8 _index\n    )\n        external\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            uint256[] memory tokenAmounts,\n            ,\n        ) = adapter.getTokenAmounts();\n\n        return tokenAmounts[_index];\n    }\n\n    /**\n    * @dev Allows user to burn TokenProfit tokens and redeem rewards\n    */\n    function redeemRewards(\n        uint256 _burnAmount\n    )\n        external\n        syncAdapter\n        nonReentrant\n        returns (\n            uint256,\n            uint256[] memory\n        )\n    {\n        (\n            uint256 availableEther,\n            uint256[] memory availableTokens,\n            uint256 etherRedeemAmount,\n            uint256[] memory tokenRedeemAmounts\n        ) = getUserRedeemAmounts(\n            _burnAmount\n        );\n\n        _burn(\n            msg.sender,\n            _burnAmount\n        );\n\n        _processTokens(\n            availableTokens,\n            tokenRedeemAmounts\n        );\n\n        _processEther(\n            availableEther,\n            etherRedeemAmount\n        );\n\n        emit RewardsRedeemed(\n            _burnAmount,\n            tokenRedeemAmounts,\n            etherRedeemAmount\n        );\n\n        return (\n            etherRedeemAmount,\n            tokenRedeemAmounts\n        );\n    }\n\n    /**\n    * @dev Calculates the max amount users can mint\n    */\n    function getAvailableMint()\n        public\n        view\n        returns (uint256 res)\n    {\n        if (totalSupply \u003e INITIAL_TOTAL_SUPPLY) {\n            return 0;\n        }\n\n        res = INITIAL_TOTAL_SUPPLY\n            - totalSupply;\n    }\n\n    /**\n    * @dev Calculates redeem rewards for the user based on burn amount\n    */\n    function getUserRedeemAmounts(\n        uint256 _burnAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256[] memory,\n            uint256,\n            uint256[] memory\n        )\n    {\n        (\n            uint256 etherAmount,\n            uint256[] memory tokenAmounts,\n            uint256 availableEther,\n            uint256[] memory availableTokens\n        ) = adapter.getTokenAmounts();\n\n        uint256 length = tokenAmounts.length;\n        uint256[] memory tokenRedeemAmounts = new uint256[](length);\n\n        for (uint256 i = 0; i \u003c length; i++) {\n            tokenRedeemAmounts[i] = _getRedeemAmount(\n                _burnAmount,\n                tokenAmounts[i],\n                totalSupply\n            );\n        }\n\n        uint256 etherRedeemAmount = _getRedeemAmount(\n            _burnAmount,\n            etherAmount,\n            totalSupply\n        );\n\n        return (\n            availableEther,\n            availableTokens,\n            etherRedeemAmount,\n            tokenRedeemAmounts\n        );\n    }\n\n    /**\n    * @dev Calculates redeem rewards based on burn amount and total supply\n    */\n    function _getRedeemAmount(\n        uint256 _burnAmount,\n        uint256 _tokenAmount,\n        uint256 _totalSupply\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return _burnAmount\n            * PRECISION_FACTOR\n            * _tokenAmount\n            / PRECISION_FACTOR\n            / _totalSupply;\n    }\n\n    /**\n    * @dev Pays out rewards to the user in all supported tokens\n    */\n    function _processTokens(\n        uint256[] memory _available,\n        uint256[] memory _redeemAmounts\n    )\n        internal\n    {\n        for (uint256 i = 0; i \u003c _available.length; i++) {\n            if (_redeemAmounts[i] \u003e _available[i]) {\n                _redeemAmounts[i] = _available[i] + adapter.assistWithdrawTokens(\n                    i,\n                    _redeemAmounts[i] - _available[i]\n                );\n            }\n\n            (\n                IERC20 token\n                ,\n                ,\n                ,\n            ) = adapter.tokens(\n                i\n            );\n\n            token.transfer(\n                msg.sender,\n                _redeemAmounts[i]\n            );\n        }\n    }\n\n    /**\n    * @dev Pays out rewards to the user in ETH currency\n    */\n    function _processEther(\n        uint256 _available,\n        uint256 _redeemAmount\n    )\n        internal\n        returns (uint256)\n    {\n        if (_redeemAmount \u003e _available) {\n            _redeemAmount = _available + adapter.assistWithdrawETH(\n                _redeemAmount - _available\n            );\n        }\n\n        payable(msg.sender).transfer(\n            _redeemAmount\n        );\n\n        return _redeemAmount;\n    }\n\n    /**\n    * @dev Allows to mint TokenProfit tokens by Auction Contract\n    */\n    function mintSupply(\n        address _mintTo,\n        uint256 _mintAmount\n    )\n        external\n        returns (bool)\n    {\n        require(\n            msg.sender == auctionContract,\n            \"TokenProfit: INVALID_MINTER\"\n        );\n\n        _mint(\n            _mintTo,\n            _mintAmount\n        );\n\n        return true;\n    }\n\n    /**\n    * @dev Allows to mint exact amount of TokenProfit tokens\n    * by anyone who provides enough ETH - does include fees\n    */\n    function buySupply(\n        uint256 _desiredAmount\n    )\n        external\n        payable\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            extraMintAllowed == true,\n            \"TokenProfit: MINT_NOT_ALLOWED\"\n        );\n\n        require(\n            getAvailableMint() \u003e= _desiredAmount,\n            \"TokenProfit: MINT_CAPPED\"\n        );\n\n        uint256 ethRequired = adapter.getEthAmountFromTokenAmount(\n            _desiredAmount,\n            msg.value\n        );\n\n        require(\n            ethRequired \u003e MIN_ETH_AMOUNT,\n            \"TokenProfit: MINT_TOO_SMALL\"\n        );\n\n        if (msg.value \u003c ethRequired) {\n            revert InvalidAmount(\n                msg.value,\n                ethRequired\n            );\n        }\n\n        _mint(\n            msg.sender,\n            _desiredAmount\n        );\n\n        payable(msg.sender).transfer(\n            msg.value - ethRequired\n        );\n\n        emit SupplyPurchase(\n            msg.sender,\n            ethRequired,\n            _desiredAmount,\n            adapter.buyFee()\n        );\n\n        return ethRequired;\n    }\n\n    /**\n    * @dev Let governance decide for extra minting\n    */\n    function setAllowMint(\n        bool _allow\n    )\n        external\n        onlyGovernance\n    {\n        extraMintAllowed = _allow;\n    }\n\n    /**\n    * @dev Allows UI to fetch mintfee more easily\n    */\n    function getCurrentBuyFee()\n        external\n        view\n        returns (uint256)\n    {\n        return adapter.buyFee();\n    }\n}\n"}}