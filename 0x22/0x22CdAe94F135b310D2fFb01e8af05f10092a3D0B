
// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    /**
     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    /**
     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }

    /**
     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }

    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
     * Revert on invalid signature.
     */
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     *
     * Furthermore, `isContract` will also return true if the target contract within
     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
     * which only has an effect at the end of a transaction.
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: contracts/interfaces/1inch/IAggregationRouterV5.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Interface for making arbitrary calls during swap
interface IAggregationExecutor {
    /// @notice propagates information about original msg.sender and executes arbitrary data
    function execute(address msgSender) external payable; // 0x4b64e492
}

interface IAggregationRouterV5 {
    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address payable srcReceiver;
        address payable dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
    }

    function swap(
        IAggregationExecutor executor,
        SwapDescription calldata desc,
        bytes calldata permit,
        bytes calldata data
    ) external payable returns (uint256 returnAmount, uint256 spentAmount);

    function uniswapV3Swap(uint256 amount, uint256 minReturn, uint256[] calldata pools)
        external
        payable
        returns (uint256 returnAmount);

    function unoswap(IERC20 srcToken, uint256 amount, uint256 minReturn, uint256[] calldata pools)
        external
        payable
        returns (uint256 returnAmount);
}


// File: contracts/interfaces/IStrategyVault.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

interface IStrategyVault {
    function totalSupply() external view returns (uint256);

    function deposit(uint256 assets_, address receiver_) external returns (uint256 shares_);

    function withdraw(uint256 assets_, address receiver_, address owner_) external returns (uint256 shares_);

    function mint(uint256 shares_, address receiver_) external returns (uint256 assets_);

    function redeem(uint256 shares_, address receiver_, address owner_) external returns (uint256 assetsAfterFee_);

    function getWithdrawFee(uint256 _amount) external view returns (uint256 amount);
}


// File: contracts/interfaces/lido/IWstETH.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWstETH is IERC20 {
    function wrap(uint256 _stETHAmount) external returns (uint256);

    function unwrap(uint256 _wstETHAmount) external returns (uint256);

    function tokensPerStEth() external view returns (uint256);

    function stEthPerToken() external view returns (uint256);

    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);

    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);
}


// File: contracts/interfaces/uniswapV3/IUniswapV3Pool.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

interface IUniswapV3Pool {
    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);
}


// File: contracts/interfaces/weth/IWETH.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWETH is IERC20 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}


// File: contracts/main/1inch/OneinchCaller.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "../../interfaces/1inch/IAggregationRouterV5.sol";
import "../../interfaces/uniswapV3/IUniswapV3Pool.sol";

/**
 * @title OneinchCaller contract
 * @author Cian
 * @notice The focal point of interacting with the 1inch protocol.
 * @dev This contract will be inherited by the strategy contract and the wrapper contract,
 * used for the necessary exchange between ETH (WETH) and stETH when necessary.
 * @dev When using this contract, it is necessary to first obtain the calldata through 1inch API.
 * The contract will then extract and verify the calldata before proceeding with the exchange.
 */
contract OneinchCaller {
    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address public constant W_ETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    // 1inch v5 protocol is currently in use.
    address public constant oneInchRouter = 0x1111111254EEB25477B68fb85Ed929f73A960582;
    uint256 private constant _UNIV3_ONE_FOR_ZERO_MASK = 1 << 255;

    /**
     * @dev Separate the function signature and detailed parameters in the calldata.
     * @param _swapData Calldata of 1inch.
     * @return functionSignature_ Function signature of the swap method.
     */
    function parseSwapCalldata(bytes memory _swapData)
        internal
        pure
        returns (bytes4 functionSignature_, bytes memory remainingBytes_)
    {
        // Extract function signature.(first 4 bytes of data)
        functionSignature_ = bytes4(_swapData[0]) | (bytes4(_swapData[1]) >> 8) | (bytes4(_swapData[2]) >> 16)
            | (bytes4(_swapData[3]) >> 24);

        uint256 remainingLength_ = _swapData.length - 4;
        // Create a variable to store the remaining bytes.
        remainingBytes_ = new bytes(remainingLength_);
        // IAggregationRouterV5.SwapDescription memory desc_;
        assembly {
            let src := add(_swapData, 0x24) // source data pointer (skip 4 bytes)
            let dst := add(remainingBytes_, 0x20) // destination data pointer
            let size := remainingLength_ // size to copy

            for {} gt(size, 31) {} {
                mstore(dst, mload(src))
                src := add(src, 0x20)
                dst := add(dst, 0x20)
                size := sub(size, 0x20)
            }
            let mask := sub(exp(2, mul(8, size)), 1)
            mstore(dst, and(mload(src), mask))
        }
        // (, desc_,,) =
        //     abi.decode(remainingBytes_, (IAggregationExecutor, IAggregationRouterV5.SwapDescription, bytes, bytes));
    }

    /**
     * @dev Executes the swap operation and verify the validity of the parameters and results.
     * @param _amount The maximum amount of currency spent.
     * @param _srcToken The token to be spent.
     * @param _dstToken The token to be received.
     * @param _swapData Calldata of 1inch.
     * @param _swapGetMin Minimum amount of the token to be received.
     * @return returnAmount_ Actual amount of the token spent.
     * @return spentAmount_ Actual amount of the token received.
     */
    function executeSwap(
        uint256 _amount,
        address _srcToken,
        address _dstToken,
        bytes memory _swapData,
        uint256 _swapGetMin
    ) internal returns (uint256 returnAmount_, uint256 spentAmount_) {
        (bytes4 functionSignature_, bytes memory remainingBytes_) = parseSwapCalldata(_swapData);
        if (functionSignature_ == IAggregationRouterV5.swap.selector) {
            (, IAggregationRouterV5.SwapDescription memory desc_,,) =
                abi.decode(remainingBytes_, (IAggregationExecutor, IAggregationRouterV5.SwapDescription, bytes, bytes));
            require(address(this) == desc_.dstReceiver, "1inch: Invalid receiver!");
            require(IERC20(_srcToken) == desc_.srcToken && IERC20(_dstToken) == desc_.dstToken, "1inch: Invalid token!");
            require(_amount >= desc_.amount, "1inch: Invalid input amount!");
            bytes memory returnData_;
            if (_srcToken == ETH_ADDR) {
                returnData_ = Address.functionCallWithValue(oneInchRouter, _swapData, _amount);
            } else {
                returnData_ = Address.functionCall(oneInchRouter, _swapData);
            }
            (returnAmount_, spentAmount_) = abi.decode(returnData_, (uint256, uint256));
            require(spentAmount_ <= desc_.amount, "1inch: unexpected spentAmount.");
            require(returnAmount_ >= _swapGetMin, "1inch: unexpected returnAmount.");
        } else if (functionSignature_ == IAggregationRouterV5.unoswap.selector) {
            (IERC20 srcTokenFromCalldata_, uint256 inputAmount_,,) =
                abi.decode(remainingBytes_, (IERC20, uint256, uint256, uint256[]));
            require(_amount >= inputAmount_, "1inch: Invalid input amount!");
            spentAmount_ = inputAmount_;
            uint256 dstTokenBefore_ =
                _dstToken == ETH_ADDR ? address(this).balance : IERC20(_dstToken).balanceOf(address(this));
            if (_srcToken == ETH_ADDR) {
                require(address(srcTokenFromCalldata_) == address(0), "1inch: Invalid token!");
                Address.functionCallWithValue(oneInchRouter, _swapData, _amount);
            } else {
                require(_srcToken == address(srcTokenFromCalldata_), "1inch: Invalid token!");
                Address.functionCall(oneInchRouter, _swapData);
            }
            returnAmount_ = _dstToken == ETH_ADDR
                ? (address(this).balance - dstTokenBefore_)
                : (IERC20(_dstToken).balanceOf(address(this)) - dstTokenBefore_);
            require(returnAmount_ > 0 && returnAmount_ >= _swapGetMin, "1inch: unexpected returnAmount.");
        } else if (functionSignature_ == IAggregationRouterV5.uniswapV3Swap.selector) {
            (uint256 inputAmount_,, uint256[] memory pools_) =
                abi.decode(remainingBytes_, (uint256, uint256, uint256[]));
            require(_amount >= inputAmount_, "1inch: Invalid input amount!");
            spentAmount_ = inputAmount_;
            address srcTokenFromCalldata_ = (pools_[0] & _UNIV3_ONE_FOR_ZERO_MASK == 0)
                ? IUniswapV3Pool(address(uint160(pools_[0]))).token0()
                : IUniswapV3Pool(address(uint160(pools_[0]))).token1();
            uint256 dstTokenBefore_ =
                _dstToken == ETH_ADDR ? address(this).balance : IERC20(_dstToken).balanceOf(address(this));
            if (_srcToken == ETH_ADDR) {
                require(srcTokenFromCalldata_ == W_ETH_ADDR, "1inch: Invalid token!");
                Address.functionCallWithValue(oneInchRouter, _swapData, _amount);
            } else {
                require(_srcToken == srcTokenFromCalldata_, "1inch: Invalid token!");
                Address.functionCall(oneInchRouter, _swapData);
            }
            returnAmount_ = _dstToken == ETH_ADDR
                ? (address(this).balance - dstTokenBefore_)
                : (IERC20(_dstToken).balanceOf(address(this)) - dstTokenBefore_);
            require(returnAmount_ > 0 && returnAmount_ >= _swapGetMin, "1inch: unexpected returnAmount.");
        } else {
            revert("1inch: Invalid function signature!");
        }
    }
}


// File: contracts/main/VaultStETHWrapper.sol
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../interfaces/lido/IWstETH.sol";
import "../interfaces/weth/IWETH.sol";
import "../interfaces/IStrategyVault.sol";
import "./1inch/OneinchCaller.sol";

/**
 * @title VaultStETHWrapper contract
 * @author Cian
 * @dev This contract is used to convert ETH into assets that the vault can accept,
 * as well as to extract assets from the vault and convert them back into ETH.
 * It facilitates the conversion between ETH and other compatible assets within the vault.
 */
contract VaultStETHWrapper is OneinchCaller {
    using SafeERC20 for IERC20;
    using SafeERC20 for IWETH;
    using SafeERC20 for IWstETH;

    address public immutable vaultAddr;
    IStrategyVault internal immutable vault;
    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant STETH_ADDR = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address public constant WSTETH_ADDR = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    IERC20 internal constant STETH_CONTRACT = IERC20(STETH_ADDR);
    IWstETH internal constant WSTETH_CONTRACT = IWstETH(WSTETH_ADDR);

    event Deposit(address sender, uint256 amount, uint256 swapGet, address receiver);
    event Withdraw(address sender, uint256 stAmount, uint256 swapGet, address receiver);
    event DepositWSTETH(address sender, uint256 stAmount, uint256 depositWst, address receiver);
    event WithdrawWSTETH(address sender, uint256 stAmount, uint256 withdrawWst, address receiver);

    constructor(address _vaultAddr) {
        vaultAddr = _vaultAddr;
        vault = IStrategyVault(_vaultAddr);
        STETH_CONTRACT.safeIncreaseAllowance(_vaultAddr, type(uint256).max);
        STETH_CONTRACT.safeIncreaseAllowance(WSTETH_ADDR, type(uint256).max);
    }

    /**
     * @dev Invest initial assets into the vault using ETH or WETH.
     * @param _wethAmount The amount of WETH to be invested.
     * @param _swapCalldata The calldata for the 1inch exchange operation.
     * @param _minStEthIn The minimum amount of token to be obtained during the 1inch exchange operation.
     * @param _receiver The recipient of the share tokens.
     * @return returnShares_ The amount of share tokens obtained.
     */
    function deposit(uint256 _wethAmount, bytes calldata _swapCalldata, uint256 _minStEthIn, address _receiver)
        external
        payable
        returns (uint256 returnShares_)
    {
        uint256 deposit_ = msg.value;
        if (_wethAmount > 0) {
            IWETH(WETH_ADDR).safeTransferFrom(msg.sender, address(this), _wethAmount);
            IWETH(WETH_ADDR).withdraw(_wethAmount);
            deposit_ += _wethAmount;
        }
        (uint256 returnAmount_, uint256 inputAmount_) =
            executeSwap(deposit_, ETH_ADDR, STETH_ADDR, _swapCalldata, _minStEthIn);
        require(inputAmount_ == deposit_, "InputInsufficient");
        returnShares_ = vault.deposit(returnAmount_, _receiver);

        emit Deposit(msg.sender, deposit_, returnAmount_, _receiver);
    }

    /**
     * @dev Invest initial assets into the vault using ETH or WETH.
     * @param _amount The amount of stETH to be withdrawn from the vault.
     * @param _swapCalldata The calldata for the 1inch exchange operation.
     * @param _minEthOut The minimum amount of token to be obtained during the 1inch exchange operation.
     * @param _receiver The recipient of the redeemed assets.
     * @param _isWeth Whether to redeem the assets in the form of WETH.
     * @return returnEthAmount_ The actual amount of ETH(WETH) redeemed.
     */
    function withdraw(
        uint256 _amount,
        bytes calldata _swapCalldata,
        uint256 _minEthOut,
        address _receiver,
        bool _isWeth
    ) external returns (uint256 returnEthAmount_) {
        uint256 stEthBalanceBefore_ = STETH_CONTRACT.balanceOf(address(this));
        uint256 withdrawFee_ = vault.getWithdrawFee(_amount);
        vault.withdraw(_amount, address(this), msg.sender);
        uint256 withdrawnAmount_ = STETH_CONTRACT.balanceOf(address(this)) - stEthBalanceBefore_;
        require(withdrawnAmount_ + withdrawFee_ <= _amount, "UnexpectedWithdrawAmount");
        STETH_CONTRACT.safeIncreaseAllowance(oneInchRouter, withdrawnAmount_);
        (returnEthAmount_,) = executeSwap(withdrawnAmount_, STETH_ADDR, ETH_ADDR, _swapCalldata, _minEthOut);
        STETH_CONTRACT.safeApprove(oneInchRouter, 0);
        if (_isWeth) {
            IWETH(WETH_ADDR).deposit{value: returnEthAmount_}();
            IWETH(WETH_ADDR).safeTransfer(_receiver, returnEthAmount_);
        } else {
            Address.sendValue(payable(_receiver), returnEthAmount_);
        }

        emit Withdraw(msg.sender, _amount, returnEthAmount_, _receiver);
    }

    /**
     * @dev Invest initial assets into the vault using wstETH.
     * @param _amount The amount of wstETH to be invested.
     * @param _receiver The recipient of the share tokens.
     * @return returnShares_ The amount of share tokens obtained.
     */
    function depositWstETH(uint256 _amount, address _receiver) external returns (uint256 returnShares_) {
        WSTETH_CONTRACT.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 depositSt_ = WSTETH_CONTRACT.unwrap(_amount);
        returnShares_ = vault.deposit(depositSt_, _receiver);

        emit DepositWSTETH(msg.sender, depositSt_, _amount, _receiver);
    }

    /**
     * @dev Invest initial assets into the vault using wstETH.
     * @param _amount The amount of stETH to be withdrawn from the vault.
     * @param _receiver The recipient of the redeemed assets.
     * @return wstAmount_ The actual amount of wstETH redeemed.
     */
    function withdrawWstETH(uint256 _amount, address _receiver) external returns (uint256 wstAmount_) {
        uint256 stEthBalanceBefore_ = STETH_CONTRACT.balanceOf(address(this));
        vault.withdraw(_amount, address(this), msg.sender);
        uint256 withdrawnAmount_ = STETH_CONTRACT.balanceOf(address(this)) - stEthBalanceBefore_;
        require(withdrawnAmount_ <= _amount, "UnexpectedWithdrawAmount");
        wstAmount_ = WSTETH_CONTRACT.wrap(withdrawnAmount_);
        WSTETH_CONTRACT.safeTransfer(_receiver, wstAmount_);

        emit WithdrawWSTETH(msg.sender, withdrawnAmount_, wstAmount_, _receiver);
    }

    /**
     * @dev When redeeming assets as ETH or WETH, the exchange is done through 1inch.
     * This method allows you to obtain the amount of tokens consumed during the exchange,
     * which can be used to request the API from 1inch.
     */
    function getWithdrawSwapAmount(uint256 amount_) external view returns (uint256 stEthSwapAmount_) {
        uint256 withdrawFee = vault.getWithdrawFee(amount_);
        stEthSwapAmount_ = amount_ - withdrawFee - 2;
    }

    receive() external payable {}
}

