{"Action.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"./Ownable.sol\";\n\ncontract Action is Ownable {\n    mapping(address =\u003e bool) private _blacklist;\n    bool private _pause;\n\n    event AddBlacklist(address indexed account);\n    event RemoveBlacklist(address indexed account);\n    event Pause(address indexed account);\n    event UnPause(address indexed account);\n\n    constructor() {\n        _pause = false;\n    }\n\n\n\n    function pause() public onlyOwner returns(bool) {\n        require(!_pause, \"Action: already pause\");\n        _pause = true;\n        emit Pause(msg.sender);\n        return true;\n    }\n\n    function unpause() public onlyOwner returns(bool) {\n        require(_pause, \"Action: already  unpause\");\n        _pause = false;\n        emit UnPause(msg.sender);\n        return true;\n    }\n\n    function paused() public view returns (bool) {\n        return _pause;\n    }\n\n    function addBlacklist(\n        address blackAddress\n    ) public onlyOwner returns (bool) {\n        require(!_blacklist[blackAddress], \"Action: already blacklisted\");\n        _blacklist[blackAddress] = true;\n        emit AddBlacklist(blackAddress);\n        return true;\n    }\n\n    function removeBlacklist(\n        address blackAddress\n    ) public onlyOwner returns (bool) {\n        require(_blacklist[blackAddress], \u0027Action: not blacklisted\u0027);\n        _blacklist[blackAddress] = false;\n        emit RemoveBlacklist(blackAddress);\n        return true;\n    }\n\n    function blackListed(address account) public view returns (bool) {\n        return _blacklist[account];\n    }\n\n    function _beforeTransferToken(\n        address from,\n        address to,\n        uint256 amount\n    ) internal view {\n        require(!_blacklist[from], \"Action: Sender blacklisted\");\n        require(!_blacklist[to], \"Action: Recipient blacklisted\");\n        require(amount \u003e 0, \"Action: transfer amount has to big than 0\");\n        require(!_pause, \"Action: paused\");\n    }\n}\n"},"CryptoCarbonEnergy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"./Action.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/*\n\n\n   _____   _______   _____ _____ ___     ___   _   ___ ___  ___  _  _   ___ _  _ ___ ___  _____   __\n  / __\\ \\ / / _ \\ \\ / / _ \\_   _/ _ \\   / __| /_\\ | _ \\ _ )/ _ \\| \\| | | __| \\| | __| _ \\/ __\\ \\ / /\n | (__ \\ V /|   /\\ V /|  _/ | || (_) | | (__ / _ \\|   / _ \\ (_) | .` | | _|| .` | _||   / (_ |\\ V /\n  \\___| |_| |_|_\\ |_| |_|   |_| \\___/   \\___/_/ \\_\\_|_\\___/\\___/|_|\\_| |___|_|\\_|___|_|_\\\\___| |_|\n\n\n*/\n\n// Contract to define a ERC20 Token with added functionality of mint and burn\ncontract CryptoCarbonEnergy is IERC20, SafeMath, Action {\n    uint256 private _totalSupply; // Total supply of tokens\n    string private _name; // Name of the token\n    string private _symbol; // Symbol of the token\n\n    // Mapping to keep track of token balances of each address\n    mapping(address =\u003e uint) private _balances;\n\n    // Mapping to keep track of allowed transfer of tokens for each address\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    // Constructor to set the name and symbol of the token\n    constructor() {\n        _name = \"Crypto Carbon Energy\";\n        _symbol = \"CYCE\";\n    }\n\n    // Function to get the total supply of tokens\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    // Function to get the balance of tokens for a specific address\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    // Function to get the allowed transfer of tokens for a specific address\n    function allowance(\n        address tokenOwner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[tokenOwner][spender];\n    }\n\n    // Function to get the name of the token\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    // Function to get the symbol of the token\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    // Function to get the decimal places of the token\n    function decimals() public pure returns (uint8) {\n        return 6;\n    }\n\n    // Function to approve a specific address to transfer a specified amount of tokens\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Require that the spender address is not zero address\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        // Require that the amount is greater than zero\n        require(amount \u003e 0, \"invalid value\");\n        // Update the allowed transfer of tokens\n        _allowances[msg.sender][spender] = amount;\n        // Emit an approval event\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // Function to transfer a specified amount of tokens from the sender to a recipient\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Call the private transfer function\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    // Function to transfer a specified amount of tokens from one address to another\n\n    // Transfer tokens from one address to another\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // Ensure that the amount of tokens being transferred does not exceed the approved amount for the transferor\n        require(\n            amount \u003c= _allowances[from][msg.sender],\n            \"ERC20: approve to the zero address\"\n        );\n        // Call the private function to handle the transfer\n        _transfer(from, to, amount);\n        // Decrement the approved amount\n        _allowances[from][msg.sender] -= amount;\n        return true;\n    }\n\n    // Private function to handle the transfer of tokens\n    function _transfer(address from, address to, uint256 amount) private {\n        // Ensure that the transferor address is not the zero address\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        // Ensure that the recipient address is not the zero address\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        // Ensure that the transferor has enough tokens to transfer\n        require(\n            _balances[from] \u003e= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        // Function call for any additional logic to be executed before the transfer\n        _beforeTransferToken(from, to, amount);\n        // Decrement the transferor\u0027s balance\n        _balances[from] = safeSub(_balances[from], amount);\n        // Increment the recipient\u0027s balance\n        _balances[to] = safeAdd(_balances[to], amount);\n        emit Transfer(from, to, amount);\n    }\n\n    // Function to mint new tokens and increase the total supply\n    /**\n     * @dev mint : To increase total supply of tokens\n     */\n    function mint(address to, uint256 tokens) public onlyOwner returns (bool) {\n        // Increase the total supply\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        // Increase the balance of the contract owner\n        _balances[to] = safeAdd(_balances[to], tokens);\n        emit Transfer(address(0), to, tokens);\n        return true;\n    }\n\n    // Function to burn tokens and decrease the total supply\n    /**\n     * @dev burn : To decrease total supply of tokens\n     */\n    function burn(uint tokens) public onlyOwner returns (bool) {\n        // Ensure that the contract owner has enough tokens to burn\n        require(\n            _balances[msg.sender] \u003e= tokens,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        // Decrease the total supply\n        _totalSupply = safeSub(_totalSupply, tokens);\n        // Decrease the balance of the contract owner\n        _balances[msg.sender] = safeSub(_balances[msg.sender], tokens);\n        emit Transfer(msg.sender, address(0), tokens);\n        return true;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n// Abstract contract defining interface for an ERC20 token\nabstract contract IERC20 {\n    // Get the total supply of tokens\n    function totalSupply() external view virtual returns (uint256);\n\n    // Transfer specified number of tokens from caller to the `to` address\n    function transfer(\n        address to,\n        uint256 tokens\n    ) external virtual returns (bool);\n\n    // Approve the `spender` address to spend the specified number of tokens on behalf of the caller\n    function approve(\n        address spender,\n        uint256 tokens\n    ) external virtual returns (bool);\n\n    // Get the approved number of tokens for a `spender` address from the `tokenOwner` address\n    function allowance(\n        address tokenOwner,\n        address spender\n    ) external view virtual returns (uint256);\n\n    // Transfer specified number of tokens from `from` address to the `to` address\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external virtual returns (bool);\n\n    // Get the balance of tokens for an `account` address\n    function balanceOf(address account) public view virtual returns (uint256);\n\n    // Event emitted when tokens are transferred\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n\n    // Event emitted when an approval is made\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ncontract Ownable {\n    address private _owner;\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Unauthorized\");\n        _;\n    }\n\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size \u003e 0);\n    }\n\n    function transferOwnership(\n        address newOwner\n    ) public onlyOwner returns (bool) {\n        require(\n            isContract(newOwner),\n            \"Ownable: New owner address is not a contract\"\n        );\n        require(_owner != newOwner, \"Ownable: The same owner\");\n        _transferOwnership(newOwner);\n        return true;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _transferOwnership(address newOwner) private {\n        _owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    function renounceOwnership() public onlyOwner returns (bool) {\n        _transferOwnership(address(0));\n        return true;\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ncontract SafeMath {\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n}\n"}}