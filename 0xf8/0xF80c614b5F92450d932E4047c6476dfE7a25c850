
// File: src/Pool.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.22;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

interface IPoolCore {
    function feeDestination() external view returns (address);
    function onPoolDeposit(uint256 amount) external view returns (bool);
    function onPoolBorrow(address caller, uint256 amount) external returns (bool);
    function onPoolRepay(address caller, uint256 amount) external returns (bool);
    function getBorrowRateBps(address pool, uint util, uint lastBorrowRate, uint lastAccrued) external view returns (uint256);
    function globalLock(address caller) external;
    function globalUnlock() external;
    function poolsData(address pool) external view returns (bool enabled, uint depositCap, uint ema, uint lastUpdate);
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint) external;
}

contract Pool {

    using SafeERC20 for IERC20;
    using ECDSA for bytes32;

    string public name;
    string public symbol;
    uint8 public constant decimals = 18;
    IERC20 public immutable asset;
    bool public immutable isWETH;
    IPoolCore public immutable core;
    uint256 internal constant MAX_UINT256 = 2**256 - 1;
    bytes32 public immutable DOMAIN_SEPARATOR;
    bytes32 public immutable PERMIT_TYPEHASH;
    bytes32 public immutable PERMIT_BORROW_TYPEHASH;
    uint public totalSupply;
    uint public debtSupply;
    uint public totalDebt;
    uint public lastAccrued;
    uint public lastBalance;
    uint public lastBorrowRate;
    uint public totalReferrerShares;
    uint public rewardIndexMantissa;
    uint constant MANTISSA = 1e18;
    uint constant MINIMUM_BALANCE = 10**3;
    uint constant REF_FEE_BPS = 1000; // 10%
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    mapping (address => mapping (address => uint)) public borrowAllowance;
    mapping(address => uint) public debtSharesOf;
    mapping(address => uint) public nonces;
    mapping(address => address) public borrowerReferrers;
    mapping(address => uint) public referrerShares;
    mapping(address => uint) public referrerIndexMantissa;
    mapping(address => uint) public accruedReferrerRewards;

    constructor(
        string memory _name,
        string memory _symbol,
        IERC20 _asset,
        bool _isWETH,
        address _core
    ) {
        name = _name;
        symbol = _symbol;
        asset = _asset;
        isWETH = _isWETH;
        core = IPoolCore(_core);
        PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
        PERMIT_BORROW_TYPEHASH = keccak256("PermitBorrow(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
        uint chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    modifier lock {
        core.globalLock(msg.sender);
        _;
        core.globalUnlock();
    }

    modifier onlyWETH {
        require(isWETH, "onlyWETH");
        _;
    }

    receive() external payable {}

    function accrueInterest() internal returns (uint _lastAccrued) {
        _lastAccrued = lastAccrued;
        uint256 timeElapsed = block.timestamp - _lastAccrued;
        // if timeElapsed is 0, it means that the interest has already been accrued for the current block
        if(timeElapsed == 0) return _lastAccrued;
        // skip interest accrual if the borrow rate is 0
        if(lastBorrowRate == 0) {
            lastAccrued = block.timestamp;
            return _lastAccrued;
        }
        // borrow rate is in basis points, timeElapsed is in seconds
        uint256 interest = totalDebt * lastBorrowRate * timeElapsed / 10000 / 365 days;
        uint shares = convertToShares(interest);
        // if shares is 0, it means that the interest is too small to be accrued
        if(shares == 0) return _lastAccrued;
        lastAccrued = block.timestamp;
        totalDebt += interest;
        totalSupply += shares;
        address borrowRateDestination = core.feeDestination();
        // before minting the interest to the fee recipient, we need to deduct the referrer rewards
        uint referrersReward;
        // skip referrer rewards if there are no referrers or if the debt supply is 0 to avoid division by zero
        if(totalReferrerShares > 0 && debtSupply > 0) {
            // only deduct REF_FEE_BPS from the portion of interest that has a referrer
            // e.g. if 50% of users have a referrer, then REF_FEE_BPS should be deducted from 50% of the interest
            // if no users have a referrer, then the full interest is minted to the fee recipient
            referrersReward = shares * totalReferrerShares * REF_FEE_BPS / debtSupply / 10000;
            // temporarily mint the referrer rewards to the pool in the form of shares for referrers to claim
            balanceOf[address(this)] += referrersReward;
            emit Transfer(address(0), address(this), referrersReward);
            // update the reward index for referrers
            rewardIndexMantissa += referrersReward * MANTISSA / totalReferrerShares;
        }
        // deduct the referrer rewards from the interest
        uint fee = referrersReward > shares ? 0 : shares - referrersReward;
        // mint the interest to the fee recipient
        balanceOf[borrowRateDestination] += fee;
        emit Transfer(address(0), borrowRateDestination, fee);
    }

    function updateReferrer(address referrer) internal {
        // deltaIndex is the difference between the current reward index and the last reward index for the referrer
        uint deltaIndex = rewardIndexMantissa - referrerIndexMantissa[referrer];
        uint bal = referrerShares[referrer];
        uint referrerDelta = bal * deltaIndex;
        referrerIndexMantissa[referrer] = rewardIndexMantissa;
        // divide by MANTISSA because rewardIndexMantissa is scaled by MANTISSA
        accruedReferrerRewards[referrer] += referrerDelta / MANTISSA;
    }

    function updateBorrowRate(uint _lastAccrued) internal {
        uint _totalAssets = totalAssets();
        uint util = _totalAssets == 0 ? 0 : totalDebt * 10000 / _totalAssets;
        lastBorrowRate = core.getBorrowRateBps(address(this), util, lastBorrowRate, _lastAccrued);
    }

    function totalAssets() public view returns (uint256) {
        return lastBalance + totalDebt;
    }

    function maxDeposit(address) public view returns (uint256) {
        (, uint depositCap,,) = core.poolsData(address(this));
        uint _totalAssets = totalAssets();
        if(_totalAssets >= depositCap) return 0;
        return depositCap - _totalAssets;
    }

    function maxMint(address) public view returns (uint256) {
        return convertToShares(maxDeposit(address(0)));
    }

    function maxWithdraw(address owner) public view returns (uint256 assets) {
        uint shares = balanceOf[owner];
        assets = convertToAssets(shares);
        if(assets > lastBalance - MINIMUM_BALANCE) {
            assets = lastBalance - MINIMUM_BALANCE;
        }
    }

    function maxRedeem(address owner) public view returns (uint256 shares) {
        shares = balanceOf[owner];
        uint assets = convertToAssets(shares);
        if(assets > lastBalance - MINIMUM_BALANCE) {
            assets = lastBalance - MINIMUM_BALANCE;
            shares = convertToShares(assets);
        }
    }    

    function mulDivUp(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 z) {
        /// @solidity memory-safe-assembly
        assembly {
            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
                revert(0, 0)
            }

            // If x * y modulo the denominator is strictly greater than 0,
            // 1 is added to round up the division of x * y by the denominator.
            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
        }
    }

    function mulDivDown(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 z) {
        /// @solidity memory-safe-assembly
        assembly {
            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
                revert(0, 0)
            }

            // Divide x * y by the denominator.
            z := div(mul(x, y), denominator)
        }
    }

    function convertToShares(uint256 assets) public view returns (uint256) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? assets : mulDivDown(assets, totalSupply, totalAssets());
    }

    function previewDeposit(uint256 assets) public view returns (uint256) {
        return convertToShares(assets);
    }

    function deposit(uint256 assets, address recipient) public lock returns (uint256 shares) {
        uint _lastAccrued = accrueInterest();
        require(core.onPoolDeposit(assets), "beforePoolDeposit");
        require((shares = previewDeposit(assets)) != 0, "zeroShares");
        balanceOf[recipient] += shares;
        totalSupply += shares;
        asset.safeTransferFrom(msg.sender, address(this), assets);
        lastBalance = asset.balanceOf(address(this));
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        emit Transfer(address(0), recipient, shares);
        emit Deposit(msg.sender, recipient, assets, shares);
        updateBorrowRate(_lastAccrued);
    }

    function deposit(uint256 assets) public returns (uint256 shares) {
        return deposit(assets, msg.sender);
    }

    function transfer(address recipient, uint256 shares) public returns (bool) {
        balanceOf[msg.sender] -= shares;
        balanceOf[recipient] += shares;
        emit Transfer(msg.sender, recipient, shares);
        return true;
    }

    function approve(address spender, uint256 shares) public returns (bool) {
        allowance[msg.sender][spender] = shares;
        emit Approval(msg.sender, spender, shares);
        return true;
    }

    function approveBorrow(address spender, uint256 amount) public returns (bool) {
        borrowAllowance[msg.sender][spender] = amount;
        emit BorrowApproval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 shares
    ) public returns (bool) {
        allowance[sender][msg.sender] -= shares;
        balanceOf[sender] -= shares;
        balanceOf[recipient] += shares;
        emit Transfer(sender, recipient, shares);
        return true;
    }

    function previewMint(uint256 shares) public view returns (uint256) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? shares : mulDivUp(shares, totalAssets(), supply);
    }

    function mint(uint256 shares, address recipient) public lock returns (uint256 assets) {
        uint _lastAccrued = accrueInterest();
        assets = previewMint(shares);
        require(core.onPoolDeposit(assets), "beforePoolDeposit");
        balanceOf[recipient] += shares;
        totalSupply += shares;
        asset.safeTransferFrom(msg.sender, address(this), assets);
        lastBalance = asset.balanceOf(address(this));
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        emit Transfer(address(0), recipient, shares);
        emit Deposit(msg.sender, recipient, assets, shares);
        updateBorrowRate(_lastAccrued);
    }

    function mint(uint256 shares) public returns (uint256 assets) {
        return mint(shares, msg.sender);
    }

    function previewWithdraw(uint256 assets) public view returns (uint256) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? assets : mulDivUp(assets, supply, totalAssets());
    }

    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public lock returns (uint256 shares) {
        uint _lastAccrued = accrueInterest();
        shares = previewWithdraw(assets);
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }
        totalSupply -= shares;
        balanceOf[owner] -= shares;
        asset.safeTransfer(receiver, assets);
        lastBalance = asset.balanceOf(address(this));
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        emit Transfer(owner, address(0), shares);
        emit Withdraw(msg.sender, receiver, owner, assets, shares);
        updateBorrowRate(_lastAccrued);
    }

    function withdraw(uint256 assets) public returns (uint256 shares) {
        return withdraw(assets, msg.sender, msg.sender);
    }

    function convertToAssets(uint256 shares) public view returns (uint256) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? shares : mulDivDown(shares, totalAssets(), supply);
    }

    function previewRedeem(uint256 shares) public view returns (uint256) {
        return convertToAssets(shares);
    }

    function redeem(uint256 shares, address receiver, address owner) public lock returns (uint256 assets) {
        uint _lastAccrued = accrueInterest();
        // Check for rounding error since we round down in previewRedeem.
        require((assets = previewRedeem(shares)) != 0, "zeroAssets");
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }
        totalSupply -= shares;
        balanceOf[owner] -= shares;
        asset.safeTransfer(receiver, assets);
        lastBalance = asset.balanceOf(address(this));
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        emit Transfer(owner, address(0), shares);
        emit Withdraw(msg.sender, receiver, owner, assets, shares);
        updateBorrowRate(_lastAccrued);
    }

    function redeem(uint256 shares) public returns (uint256 assets) {
        return redeem(shares, msg.sender, msg.sender);
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'permitExpired');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = digest.recover(v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pool: INVALID_SIGNATURE');
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function permitBorrow(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'permitExpired');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_BORROW_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = digest.recover(v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pool: INVALID_SIGNATURE');
        borrowAllowance[owner][spender] = value;
        emit BorrowApproval(owner, spender, value);
    }

    function previewBorrow(uint256 assets) public view returns (uint256) {
        uint256 supply = debtSupply; // Saves an extra SLOAD if debtSupply is non-zero.

        return supply == 0 ? assets : mulDivDown(assets, debtSupply, totalDebt);
    }

    function borrow(uint256 amount, address referrer, address owner) public lock {
        uint _lastAccrued = accrueInterest();
        require(core.onPoolBorrow(owner, amount), "beforePoolBorrow");
        if (msg.sender != owner) {
            uint256 allowed = borrowAllowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) borrowAllowance[owner][msg.sender] = allowed - amount;
        }
        uint debtShares;
        require((debtShares = previewBorrow(amount)) != 0, "zeroShares");
        if(borrowerReferrers[owner] != address(0)) {
            updateReferrer(borrowerReferrers[owner]);
            referrerShares[borrowerReferrers[owner]] -= debtSharesOf[owner];
            totalReferrerShares -= debtSharesOf[owner];
        }
        debtSharesOf[owner] += debtShares;
        if(referrer != address(0)) {
            updateReferrer(referrer);
            referrerShares[referrer] += debtSharesOf[owner];
            totalReferrerShares += debtSharesOf[owner];
        }
        borrowerReferrers[owner] = referrer;
        debtSupply += debtShares;
        totalDebt += amount;
        asset.safeTransfer(msg.sender, amount);
        lastBalance = asset.balanceOf(address(this));
        emit Borrow(owner, amount, debtShares);
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        updateBorrowRate(_lastAccrued);
    }

    function borrow(uint256 amount, address referrer) public {
        borrow(amount, referrer, msg.sender);
    }

    function borrow(uint256 amount) public {
        borrow(amount, borrowerReferrers[msg.sender], msg.sender);
    }

    function borrowETH(uint256 amount, address referrer, address owner) public lock onlyWETH {
        uint _lastAccrued = accrueInterest();
        require(core.onPoolBorrow(owner, amount), "beforePoolBorrow");
        if (msg.sender != owner) {
            uint256 allowed = borrowAllowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) borrowAllowance[owner][msg.sender] = allowed - amount;
        }
        uint debtShares;
        require((debtShares = previewBorrow(amount)) != 0, "zeroShares");
        if(borrowerReferrers[owner] != address(0)) {
            updateReferrer(borrowerReferrers[owner]);
            referrerShares[borrowerReferrers[owner]] -= debtSharesOf[owner];
            totalReferrerShares -= debtSharesOf[owner];
        }
        debtSharesOf[owner] += debtShares;
        if(referrer != address(0)) {
            updateReferrer(referrer);
            referrerShares[referrer] += debtSharesOf[owner];
            totalReferrerShares += debtSharesOf[owner];
        }
        borrowerReferrers[owner] = referrer;
        debtSupply += debtShares;
        totalDebt += amount;
        IWETH(address(asset)).withdraw(amount);
        lastBalance = asset.balanceOf(address(this));
        emit Borrow(owner, amount, debtShares);
        require(lastBalance >= MINIMUM_BALANCE, "minimumBalance");
        updateBorrowRate(_lastAccrued);
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "ETH transfer failed");
    }

    function borrowETH(uint256 amount, address referrer) public {
        borrowETH(amount, referrer, msg.sender);
    }

    function borrowETH(uint256 amount) public {
        borrowETH(amount, borrowerReferrers[msg.sender], msg.sender);
    }

    function previewRepay(uint256 assets) public view returns (uint256) {
        uint256 supply = debtSupply; // Saves an extra SLOAD if debtSupply is non-zero.

        return supply == 0 ? assets : mulDivUp(assets, debtSupply, totalDebt);
    }

    function repay(address to, uint amount) public lock {
        uint _lastAccrued = accrueInterest();
        if(amount == type(uint256).max) amount = getDebtOf(to);
        require(core.onPoolRepay(to, amount), "beforePoolRepay");
        uint debtShares;
        require((debtShares = previewRepay(amount)) != 0, "zeroShares");
        if(borrowerReferrers[to] != address(0)) {
            updateReferrer(borrowerReferrers[to]);
            referrerShares[borrowerReferrers[to]] -= debtShares;
            totalReferrerShares -= debtShares;
        }
        debtSharesOf[to] -= debtShares;
        debtSupply -= debtShares;
        totalDebt -= amount;
        asset.safeTransferFrom(msg.sender, address(this), amount);
        lastBalance = asset.balanceOf(address(this));
        emit Repay(to, amount, debtShares);
        updateBorrowRate(_lastAccrued);
    }

    function repay(uint amount) public {
        repay(msg.sender, amount);
    }

    function repayETH(address to) public payable lock onlyWETH {
        uint _lastAccrued = accrueInterest();
        uint amount = msg.value;
        uint debt = getDebtOf(to);
        uint refund;
        if(amount > debt) {
            refund = amount - debt;
            amount = debt;
        }
        require(core.onPoolRepay(to, amount), "beforePoolRepay");
        uint debtShares;
        require((debtShares = previewRepay(amount)) != 0, "zeroShares");
        if(borrowerReferrers[to] != address(0)) {
            updateReferrer(borrowerReferrers[to]);
            referrerShares[borrowerReferrers[to]] -= debtShares;
            totalReferrerShares -= debtShares;
        }
        debtSharesOf[to] -= debtShares;
        debtSupply -= debtShares;
        totalDebt -= amount;
        IWETH(address(asset)).deposit{value: amount}();
        lastBalance = asset.balanceOf(address(this));
        emit Repay(to, amount, debtShares);
        updateBorrowRate(_lastAccrued);
        if(refund > 0) {
            (bool success,) = msg.sender.call{value: refund}("");
            require(success, "ETH transfer failed");
        }
    }

    function repayETH() public payable {
        repayETH(msg.sender);
    }

    function writeOff(address account) public lock {
        uint _lastAccrued = accrueInterest();
        require(msg.sender == address(core), "onlyCore");
        uint debtShares = debtSharesOf[account];
        uint debt = convertToDebtAssets(debtShares);
        if(borrowerReferrers[account] != address(0)) {
            updateReferrer(borrowerReferrers[account]);
            referrerShares[borrowerReferrers[account]] -= debtShares;
            totalReferrerShares -= debtShares;
        }
        debtSharesOf[account] -= debtShares;
        debtSupply -= debtShares;
        totalDebt -= debt;
        emit WriteOff(account, debt, debtShares);
        updateBorrowRate(_lastAccrued);
    }

    function claimReferralRewards(address user) external {
        accrueInterest();
        updateReferrer(user);
        uint amount = accruedReferrerRewards[user];
        accruedReferrerRewards[user] = 0;
        IERC20(address(this)).transfer(user, amount);
    }

    function getAssetsOf(address account) public view returns (uint) {
        return convertToAssets(balanceOf[account]);
    }

    function convertToDebtAssets(uint256 debtShares) public view returns (uint256) {
        uint256 supply = debtSupply; // Saves an extra SLOAD if debtSupply is non-zero.

        return supply == 0 ? debtShares : mulDivDown(debtShares, totalDebt, debtSupply);
    }

    function convertToDebtShares(uint256 debtAssets) public view returns (uint256) {
        uint256 supply = debtSupply; // Saves an extra SLOAD if debtSupply is non-zero.

        return supply == 0 ? debtAssets : mulDivUp(debtAssets, debtSupply, totalDebt);
    }

    function getDebtOf(address account) public view returns (uint) {
        // accrue interest to the current block, same as accrueInterest()
        if(debtSupply == 0) return 0;
        uint256 timeElapsed = block.timestamp - lastAccrued;
        // if timeElapsed is 0, it means that the interest has already been accrued for the current block
        if(timeElapsed == 0) return convertToDebtAssets(debtSharesOf[account]);
        // lastBorrowRate is in basis points, timeElapsed is in seconds
        uint256 interest = totalDebt * lastBorrowRate * timeElapsed / 10000 / 365 days;
        uint shares = convertToDebtShares(interest);
        // if shares is 0, it means that the interest is too small to be accrued
        if(shares == 0) return convertToDebtAssets(debtSharesOf[account]);
        // we use mulDivUp to round down the debt shares
        return mulDivDown(debtSharesOf[account], totalDebt + interest, debtSupply);
    }

    function pull(address _stuckToken, address dst, uint amount) external {
        require(msg.sender == address(core), "onlyCore");
        require(_stuckToken != address(asset), "cannotPullUnderlying");
        require(_stuckToken != address(this), "cannotPullSelf");
        IERC20(_stuckToken).safeTransfer(dst, amount);
    }

    function invalidateNonce() external {
        nonces[msg.sender]++;
    }

    event Borrow(address indexed borrower, uint amount, uint debtShares);
    event Repay(address indexed borrower, uint amount, uint debtShares);
    event WriteOff(address indexed borrower, uint amount, uint debtShares);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BorrowApproval(address indexed owner, address indexed spender, uint256 value);
    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);
    event Withdraw(
        address indexed caller,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );
}

// File: lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.20;

import {IERC20} from "../IERC20.sol";
import {IERC20Permit} from "../extensions/IERC20Permit.sol";
import {Address} from "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev An operation with an ERC20 token failed.
     */
    error SafeERC20FailedOperation(address token);

    /**
     * @dev Indicates a failed `decreaseAllowance` request.
     */
    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);

    /**
     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
    }

    /**
     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
    }

    /**
     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        forceApprove(token, spender, oldAllowance + value);
    }

    /**
     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
     * value, non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
        unchecked {
            uint256 currentAllowance = token.allowance(address(this), spender);
            if (currentAllowance < requestedDecrease) {
                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
            }
            forceApprove(token, spender, currentAllowance - requestedDecrease);
        }
    }

    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data);
        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
            revert SafeERC20FailedOperation(address(token));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
    }
}


// File: lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)

pragma solidity ^0.8.20;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS
    }

    /**
     * @dev The signature derives the `address(0)`.
     */
    error ECDSAInvalidSignature();

    /**
     * @dev The signature has an invalid length.
     */
    error ECDSAInvalidSignatureLength(uint256 length);

    /**
     * @dev The signature has an S value that is in the upper half order.
     */
    error ECDSAInvalidSignatureS(bytes32 s);

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not
     * return address(0) without also returning an error description. Errors are documented using an enum (error type)
     * and a bytes32 providing additional information about the error.
     *
     * If no error is returned, then the address can be used for verification purposes.
     *
     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
     *
     * Documentation for signature generation:
     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
     */
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            /// @solidity memory-safe-assembly
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     *
     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
     */
    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {
        unchecked {
            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
            // We do not check for an overflow here since the shift operation results in 0 or 1.
            uint8 v = uint8((uint256(vs) >> 255) + 27);
            return tryRecover(hash, v, r, s);
        }
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
     */
    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError, bytes32) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS, s);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature, bytes32(0));
        }

        return (signer, RecoverError.NoError, bytes32(0));
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);
        _throwError(error, errorArg);
        return recovered;
    }

    /**
     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.
     */
    function _throwError(RecoverError error, bytes32 errorArg) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert ECDSAInvalidSignature();
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert ECDSAInvalidSignatureLength(uint256(errorArg));
        } else if (error == RecoverError.InvalidSignatureS) {
            revert ECDSAInvalidSignatureS(errorArg);
        }
    }
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the value of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the value of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves a `value` amount of tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 value) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
     * caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 value) external returns (bool);

    /**
     * @dev Moves a `value` amount of tokens from `from` to `to` using the
     * allowance mechanism. `value` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 *
 * ==== Security Considerations
 *
 * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 * generally recommended is:
 *
 * ```solidity
 * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 *     doThing(..., value);
 * }
 *
 * function doThing(..., uint256 value) public {
 *     token.safeTransferFrom(msg.sender, address(this), value);
 *     ...
 * }
 * ```
 *
 * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 * {SafeERC20-safeTransferFrom}).
 *
 * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 * contracts should have entry points that don't rely on permit.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     *
     * CAUTION: See Security Considerations above.
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: lib/openzeppelin-contracts/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)

pragma solidity ^0.8.20;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev The ETH balance of the account is not enough to perform the operation.
     */
    error AddressInsufficientBalance(address account);

    /**
     * @dev There's no code at `target` (it is not a contract).
     */
    error AddressEmptyCode(address target);

    /**
     * @dev A call to an address target failed. The target may have reverted.
     */
    error FailedInnerCall();

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        if (address(this).balance < amount) {
            revert AddressInsufficientBalance(address(this));
        }

        (bool success, ) = recipient.call{value: amount}("");
        if (!success) {
            revert FailedInnerCall();
        }
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason or custom error, it is bubbled
     * up by this function (like regular Solidity function calls). However, if
     * the call reverted with no returned reason, this function reverts with a
     * {FailedInnerCall} error.
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        if (address(this).balance < value) {
            revert AddressInsufficientBalance(address(this));
        }
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
     * unsuccessful call.
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata
    ) internal view returns (bytes memory) {
        if (!success) {
            _revert(returndata);
        } else {
            // only check if target is a contract if the call was successful and the return data is empty
            // otherwise we already know that it was a contract
            if (returndata.length == 0 && target.code.length == 0) {
                revert AddressEmptyCode(target);
            }
            return returndata;
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
     * revert reason or with a default {FailedInnerCall} error.
     */
    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
        if (!success) {
            _revert(returndata);
        } else {
            return returndata;
        }
    }

    /**
     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
     */
    function _revert(bytes memory returndata) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert FailedInnerCall();
        }
    }
}

