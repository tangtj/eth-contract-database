
// File: src/portfolios/TPlusNPortfolio.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity 0.8.13;

import {EntityBaseTokenTransferor} from "../EntityBaseTokenTransferor.sol";
import {TPlusNAsset} from "./TPlusNAsset.sol";
import {Registry} from "../Registry.sol";
import {Entity} from "../Entity.sol";
import {Portfolio} from "../Portfolio.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {Math} from "../lib/Math.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

/// ENUMS
enum ConsolidationOperation {
    Deposit,
    Redeem
}

/// STRUCTS
/**
 * @notice Arguments for constructor. Using a struct to avoid stack too deep error.
 * @param _registry Endaoment registry.
 * @param _receiptAsset Address of the receipt asset. Should normally be a `TPlusNAsset` contract.
 * @param _shareTokenName Name of ERC20 portfolio share token.
 * @param _shareTokenSymbol Symbol of ERC20 portfolio share token.
 * @param _ebtt Address of the EBTT contract.
 * @param _processor Address to automatically route deposit base token to.
 * @param _minDeposit Minimum base token amount allowed for a valid deposit.
 * @param _cap Maximum amount of assets this portfolio can hold.
 * @param _feeTreasury Address of treasury that should receive fees.
 * @param _depositFee Percentage fee as ZOC that should go to treasury on deposit. (100 = 1%).
 * @param _redemptionFee Percentage fee as ZOC that should go to treasury on redemption. (100 = 1%).
 * @param _aumRate Percentage fee per second (as WAD) that should accrue to treasury as AUM fee. (1e16 = 1%).
 */
struct ConstructorArgs {
    Registry registry;
    address receiptAsset;
    string shareTokenName;
    string shareTokenSymbol;
    EntityBaseTokenTransferor ebtt;
    address processor;
    uint256 minDeposit;
    uint256 cap;
    address feeTreasury;
    uint256 depositFee;
    uint256 redemptionFee;
    uint256 aumRate;
}

/**
 * @notice Struct representing a single consolidation for a deposit/purchase or redeem/sale operation.
 * @param operation The type of consolidation operation - deposit/purchase or redeem/sale.
 * @param entity The entity whose pending balance should be consolidated.
 * @param amountBaseToken The amount of base token to consolidate. For purchases, this is the amount of base token used. For sales, this is the amount of base token received.
 * @param amountAssets The amount of assets to consolidate. For purchases, this is the amount of assets purchased. For sales, this is the amount of assets sold.
 */
struct Consolidation {
    ConsolidationOperation operation;
    Entity entity;
    uint256 amountBaseToken;
    uint256 amountAssets;
}

contract TPlusNPortfolio is Portfolio {
    using SafeTransferLib for ERC20;
    using Math for uint256;

    /// STATE

    /// @notice The EBTT contract.
    EntityBaseTokenTransferor public immutable ebtt;
    /// @notice The address to automatically route base tokens from and to on deposits and sales.
    address public processor;
    /// @notice Minimum base token amount that can be deposited.
    uint256 public minDeposit;
    /// @notice Maintenance flag to pause functionality.
    bool public underMaintenance;
    /// @notice Pending purchase balance of base tokens per address.
    mapping(Entity => uint256) public pendingPurchaseBalance;
    /// @notice Pending sale assets per address.
    mapping(Entity => uint256) public pendingSaleAssets;

    /// ERRORS

    /// @notice Emitted when deposit is below minimum.
    error MinDeposit();
    /// @notice Emitted when called under maintenance.
    error UnderMaintenance();
    /// @notice Emitted when informed entity parameter is bad (e.g. missing information, duplicated entities).
    error BadEntityInput();
    /// @notice Emitted when insufficient balances on consolidation.
    error InsufficientBalance();

    /// EVENTS

    /// @notice Emitted when processor is set.
    event ProcessorSet(address newProcessor);
    /// @notice Emitted when minDeposit is set.
    event MinDepositSet(uint256 newMinDeposit);
    /// @notice Emitted when underMaintenance is set.
    event UnderMaintenanceSet(bool newUnderMaintenance);
    /// @notice Emitted when a deposit/purchase consolidation is made.
    event DepositConsolidated(
        Entity indexed entity, uint256 amountBaseToken, uint256 amountAssets, uint256 amountShares
    );
    /// @notice Emitted when a correction mint is made.
    event CorrectionShareMinted(Entity indexed entity, uint256 amountShares);
    /// @notice Emitted when a correction burn is made.
    event CorrectionShareBurned(Entity indexed entity, uint256 amountShares);
    /// @notice Emitted when a redemption/sale consolidation is made.
    event RedeemConsolidated(Entity indexed entity, uint256 amountBaseToken, uint256 amountAssets, uint256 fee);

    /**
     * @param _args Constructor arguments struct.
     * @dev Args are passed in a struct to avoid stack too deep errors.
     * @dev The `true` parameter is to set this portfolio as `async` in the parent `Portfolio` contract. Async portfolios handle share lifecycle differently.
     * @dev EBTT is required to properly process payments back to entites on sale consolidations.
     * @dev While `cap` is not enforced in contract, its value can be utilized by UI to implement the behavior.
     */
    constructor(ConstructorArgs memory _args)
        Portfolio(
            _args.registry,
            _args.receiptAsset,
            _args.shareTokenName,
            _args.shareTokenSymbol,
            true, // Async portfolio, hence setting `_async` to true
            _args.cap,
            _args.feeTreasury,
            _args.depositFee,
            _args.redemptionFee,
            _args.aumRate
        )
    {
        // Approve EBTT to transfer this portfolio's balance for sale consolidations
        ebtt = _args.ebtt;
        baseToken.safeApprove(address(ebtt), type(uint256).max);

        processor = _args.processor;
        emit ProcessorSet(processor);

        minDeposit = _args.minDeposit;
        emit MinDepositSet(minDeposit);
    }

    /**
     * @inheritdoc Portfolio
     */
    function _getAsset(address _receiptAsset) internal pure override returns (address) {
        return _receiptAsset;
    }

    /**
     * @inheritdoc Portfolio
     */
    function convertReceiptAssetsToAssets(uint256 _receiptAssets) public pure override returns (uint256) {
        return _receiptAssets;
    }

    /**
     * @inheritdoc Portfolio
     * @notice T+N portfolios do not enforce cap onchain.
     * @dev Cap is not enforced because async portfolios do not have direct access to the spot price of the asset, hence not being able to determine a cap syncronously to deposits.
     * @dev While `cap` is not enforced in contract, it is settable in the constructor so external logic can read and utilize it.
     */
    function _checkCap() internal pure override {}

    /**
     * @inheritdoc Portfolio
     * @dev As an `async` portfolio, T+N portfolio do not mint shares on `deposit`, rather handling it on consolidations.
     * @dev Deposits smaller than `minDeposit` revert.
     */
    function _deposit(uint256 _amountBaseToken, bytes calldata /* _data */ )
        internal
        override
        returns (uint256, /* shares */ uint256, /* assets */ uint256 /* fee */ )
    {
        // Check if deposit is above minimum
        if (_amountBaseToken < minDeposit) revert MinDeposit();
        // Check if under maintenance
        if (underMaintenance) revert UnderMaintenance();

        // Calculate fee and net amount to be deposited and used for purchase
        // TODO: move deposit fee logic to `Portfolio`, for all portfolios
        (uint256 _amountIn, uint256 _amountFee) = _calculateFee(_amountBaseToken, depositFee);

        // Transfer amount from entity to `processor`
        baseToken.safeTransferFrom(msg.sender, processor, _amountIn);

        // Transfer fee to treasury
        baseToken.safeTransferFrom(msg.sender, feeTreasury, _amountFee);

        // Update pending balance
        unchecked {
            // Unchecked: no realistic amount of base token will overflow
            pendingPurchaseBalance[Entity(payable(msg.sender))] += _amountIn;
        }

        // No acquired shares or assets, and base token fee amount
        return (0, 0, _amountFee);
    }

    /**
     * @inheritdoc Portfolio
     * @notice Returns (0, 0) to signal that no asset and base token are produced on reddem for T+N.
     */
    function _redeem(uint256 _amountShares, bytes calldata /* _data */ )
        internal
        override
        returns (uint256, /* assetsOut */ uint256 /* baseTokenOut */ )
    {
        // Check if under maintenance
        if (underMaintenance) revert UnderMaintenance();

        // Verify how many assets this amount of shares is worth
        // This assumes `takeAUMFees` was already called in the wrapping `Portfolio.redeem` call
        uint256 _amountAssets = convertToAssets(_amountShares);

        // Update pending asset amount to sell
        unchecked {
            // Unchecked: asset total supply is capped at type(uint256).max, so an individual balance will also never overflow
            pendingSaleAssets[Entity(payable(msg.sender))] += _amountAssets;
        }

        // Burn asset to maintain correct supply in portfolio's balance
        // This is important so AUM fees are charged proportional to the asset balance that still
        // belongs to the portfolio. This also implies that once an entity performs a redeem,
        // we won't charge/be entitled to any AUM fees on that portion of the assets.
        TPlusNAsset(receiptAsset).burn(_amountAssets);

        // Return the amount of assets out and 0 base token for a T+N redemption
        return (_amountAssets, 0);
    }

    /**
     * @notice Consolidates pending purchase balances into shares, based on the amount of assets effectively purchased.
     * @param _entity The entity whose pending balance should be consolidated.
     * @param _amountBaseToken The amount of base token to consolidate.
     * @param _amountAssets The amount of assets this amount of base token was capable of purchasing.
     * @dev The value of _amountAssets must be chosen carefully to avoid rounding errors e.g. 1 ether = 1 "real world" asset is a good choice.
     */
    function _consolidateDeposit(Entity _entity, uint256 _amountBaseToken, uint256 _amountAssets) private {
        // Decrease pending balance
        // Checked: we want to revert on underflow
        pendingPurchaseBalance[_entity] -= _amountBaseToken;

        // Mint shares proportional to the amount of assets produced
        // ⚠️ Share calculation must happen before all mints to avoid wrong values
        uint256 _amountShares = convertToShares(_amountAssets);
        _mint(address(_entity), _amountShares);

        // Mint the receipt asset equal to the amount of asset produced, since the portfolio
        // controls the supply of the receipt asset
        TPlusNAsset(receiptAsset).mint(address(this), _amountAssets);

        // Emit
        emit DepositConsolidated(_entity, _amountBaseToken, _amountAssets, _amountShares);
    }

    /**
     * @notice Consolidate pending sale/redeemed assets into base token, based on the amount of assets effectively sold. Transfers base token to entity.
     * @param _entity The entity whose pending asset balance should be consolidated.
     * @param _amountBaseToken The amount of base token the sale of the asset amount was capable of selling for.
     * @param _amountAssets The amount of assets that effectively got sold.
     * @dev Method will revert if portfolio does not have enough base token in its balance to transfer to entity and treasury.
     */
    function _consolidateRedeem(Entity _entity, uint256 _amountBaseToken, uint256 _amountAssets) private {
        // Checked: Desired underflow if larger
        pendingSaleAssets[_entity] -= _amountAssets;

        // Get net and fee values
        (uint256 _amountOut, uint256 _amountFee) = _calculateFee(_amountBaseToken, redemptionFee);

        // Transfer sale-produced base token amount to entity
        // Uses EBTT contract to circumvent any fee or events being triggered incorrectly
        ebtt.transferFromPortfolio(_entity, _amountOut);

        // Transfer fee to treasury
        baseToken.safeTransfer(feeTreasury, _amountFee);

        // Emit
        emit RedeemConsolidated(_entity, _amountOut, _amountAssets, _amountFee);
    }

    /**
     * @notice Consolidate pending balances into shares or base token, based on the amount of assets effectively purchased or sold.
     * @param _consolidations Array of `Consolidation` structs to process.
     */
    function _consolidate(Consolidation[] calldata _consolidations) private {
        for (uint256 i = 0; i < _consolidations.length; ++i) {
            if (_consolidations[i].operation == ConsolidationOperation.Deposit) {
                _consolidateDeposit(
                    _consolidations[i].entity, _consolidations[i].amountBaseToken, _consolidations[i].amountAssets
                );
            } else {
                _consolidateRedeem(
                    _consolidations[i].entity, _consolidations[i].amountBaseToken, _consolidations[i].amountAssets
                );
            }
        }
    }

    /**
     * @notice Perform consolidation while skipping any accrual operations.
     * @param _consolidations Array of `Consolidation` structs to process.
     * @dev Reverts if the contract does not have enough base token to transfer to the entity and treasury on a redeem consolidation.
     */
    function consolidateNoAccrual(Consolidation[] calldata _consolidations) external requiresAuth {
        // AUM fees must be taken whenever the balance of assets changes
        takeAumFees();
        // Consolidate
        _consolidate(_consolidations);
    }

    /**
     * @notice Endaoment role authed method to consolidate pending purchases and sales while distributing accrued assets.
     * @param _consolidations Array of `Consolidation` structs to process.
     * @param _accruedAssets Amount of assets accrued since last consolidation.
     * @dev Reverts if the contract does not have enough base token to transfer to the entity and treasury on a redeem consolidation.
     */
    function consolidateWithAccrual(Consolidation[] calldata _consolidations, uint256 _accruedAssets)
        external
        requiresAuth
    {
        // AUM fees must be taken whenever the balance of assets changes
        takeAumFees();

        // Given how the operational flow of how T+N works, accruals are simply the minting of the underlying asset
        // This *must* be done before any consolidation, to properly reflect the contribution of each existing entity's
        // position to produce the accrued assets
        TPlusNAsset(receiptAsset).mint(address(this), _accruedAssets);

        // Consolidate
        _consolidate(_consolidations);
    }

    /**
     * @notice Endaoment role authed method to mint shares to an entity. Used solely for correcting share balances in case of errors.
     * @param _entity The entity to mint shares to.
     * @param _amount The amount of shares to mint.
     * @dev This method is only callable by Endaoment roles, and used only in case of error corrections.
     */
    function correctionMint(Entity _entity, uint256 _amount) external requiresAuth {
        _mint(address(_entity), _amount);

        emit CorrectionShareMinted(_entity, _amount);
    }

    /**
     * @notice Endaoment role authed method to burn shares from an entity. Used solely for correcting share balances in case of errors.
     * @param _entity The entity to burn shares from.
     * @param _amount The amount of shares to burn.
     * @dev This method is only callable by Endaoment roles, and used only in case of error corrections.
     */
    function correctionBurn(Entity _entity, uint256 _amount) external requiresAuth {
        _burn(address(_entity), _amount);

        emit CorrectionShareBurned(_entity, _amount);
    }

    // @inheritdoc Portfolio
    function _exit(
        uint256,
        /* _amount */
        bytes calldata /* _data */
    ) internal pure override returns (uint256, /* actualAssetsOut */ uint256 /* baseTokenOut */ ) {
        // Noop
        return (0, 0);
    }

    /**
     * @notice Endaoment role authed method to set the processor address.
     * @param _processor Address to automatically route deposit base token to.
     */
    function setProcessor(address _processor) external requiresAuth {
        processor = _processor;
        emit ProcessorSet(_processor);
    }

    /**
     * @notice Role authed method to set the minimum base token amount allowed for a valid deposit.
     * @param _min Minimum base token amount allowed for a valid deposit.
     */
    function setMinDeposit(uint256 _min) external requiresAuth {
        minDeposit = _min;
        emit MinDepositSet(_min);
    }

    /**
     * @notice Role authed method to set the maintenance flag.
     * @param _underMaintenance Maintenance flag to pause functionality.
     */
    function setUnderMaintenance(bool _underMaintenance) external requiresAuth {
        underMaintenance = _underMaintenance;
        emit UnderMaintenanceSet(_underMaintenance);
    }
}


// File: src/EntityBaseTokenTransferor.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity >=0.8.0;

import {EndaomentAuth} from "./lib/auth/EndaomentAuth.sol";
import {Registry} from "./Registry.sol";
import {Entity} from "./Entity.sol";
import {Portfolio} from "./Portfolio.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import "solmate/utils/SafeTransferLib.sol";

/**
 * @notice An Endaoment ecosystem contract capabale of transfering base tokens to Endaoment entities, updating their balances without triggering fees or emitting misleading events.
 * @dev This is due to this contract being enabled as a valid entity on the `Registry` and capable of calling `receiveTransfer` on entities.
 */
contract EntityBaseTokenTransferor is EndaomentAuth {
    using SafeTransferLib for ERC20;

    /// STRUCTS
    struct EntityTransfer {
        Entity entity;
        uint256 amount;
    }

    /// STATE
    /// @notice The Endaoment registry contract
    Registry public immutable registry;

    /// ERRORS
    /// @notice Error when the transfer destination isn't a valid and enabled Endaoment entity.
    error InvalidEntity();
    /// @notice Error when the transfer source isn't a valid and enabled Endaoment portfolio.
    error InvalidPortfolio();
    /// @notice Error when a call to another contract fails.
    error CallFailed(bytes response);

    /// EVENTS
    /// @notice Emitted when a transfer is made to an Endaoment entity.
    event TransferredToEntity(address indexed from, Entity indexed entity, uint256 amount);

    /**
     * @param _registry The Endaoment registry contract
     */
    constructor(Registry _registry) {
        __initEndaomentAuth(_registry, "");
        registry = _registry;
    }

    /**
     * Modifier to only allow valid and active Endaoment entities as transfer destinations.
     * @param _entity The attempted entity
     */
    modifier isActiveEntity(Entity _entity) {
        _checkEntity(_entity);
        _;
    }

    /**
     * Modifier to only allow valid and active Endaoment portfolios as callers.
     */
    modifier isActivePortfolioCaller() {
        if (!registry.isActivePortfolio(Portfolio(msg.sender))) revert InvalidPortfolio();
        _;
    }

    /**
     * Check if an entity is valid and active
     * @param _entity The entity to check
     */
    function _checkEntity(Entity _entity) private view {
        if (!registry.isActiveEntity(_entity)) revert InvalidEntity();
    }

    /**
     * Transfer base token from caller and consolidate balance of the Endaoment entity.
     * @param _entity The entity to transfer to.
     * @param _amount The amount to transfer.
     * @notice This functions exists so Endaoment admins can transfer arbitrary amounts of base tokens to entities without triggering fees.
     * @dev Caller must pre `approve` this contract to transfer the desired amount.
     */
    function transferFromCaller(Entity _entity, uint256 _amount) external requiresAuth isActiveEntity(_entity) {
        _transferToEntity(msg.sender, _entity, _amount);
    }

    /**
     * Batch transfer base token from caller and consolidate balance of the receiving Endaoment entities.
     * @param _entityTransfers The entity transfers to make.
     * @notice This functions exists so Endaoment admins can transfer arbitrary amounts of base tokens to entities without triggering fees.
     * @dev Caller must pre `approve` this contract to transfer the desired amount.
     */
    function batchTransferFromCaller(EntityTransfer[] calldata _entityTransfers) external requiresAuth {
        for (uint256 i = 0; i < _entityTransfers.length; ++i) {
            EntityTransfer memory _transfer = _entityTransfers[i];
            _checkEntity(_transfer.entity);
            _transferToEntity(msg.sender, _transfer.entity, _transfer.amount);
        }
    }

    /**
     * Transfer base token from an Endaoment portfolio to an Endaoment entity.
     * @param _entity The entity to transfer to.
     * @param _amount The amount to transfer.
     * @notice This functions exists so Endaoment portfolios can transfer arbitrary amounts of base tokens to entities without triggering fees.
     * An example of this use case is for T+N portfolios and their async nature of transferring base tokens back to entities on sale consolidation.
     * @dev This function is only callable by active Endaoment portfolios.
     * @dev Portfolio caller must pre `approve` this contract to transfer the desired amount.
     */
    function transferFromPortfolio(Entity _entity, uint256 _amount)
        external
        isActivePortfolioCaller
        isActiveEntity(_entity)
    {
        _transferToEntity(msg.sender, _entity, _amount);
    }

    /**
     * Batch transfer base token from an Endaoment portfolio to Endaoment entities.
     * @param _entityTransfers The entity transfers to make.
     * @notice This functions exists so Endaoment portfolios can transfer arbitrary amounts of base tokens to entities without triggering fees.
     * @dev This function is only callable by active Endaoment portfolios.
     * @dev Portfolio caller must pre `approve` this contract to transfer the desired amount.
     */
    function batchTransferFromPortfolio(EntityTransfer[] calldata _entityTransfers) external isActivePortfolioCaller {
        for (uint256 i = 0; i < _entityTransfers.length; ++i) {
            EntityTransfer memory _transfer = _entityTransfers[i];
            _checkEntity(_transfer.entity);
            _transferToEntity(msg.sender, _transfer.entity, _transfer.amount);
        }
    }

    /**
     * Transfer base token to an Endaoment entity.
     * @param _from The address to transfer from.
     * @param _entity The entity to transfer to.
     * @param _amount The amount to transfer.
     */
    function _transferToEntity(address _from, Entity _entity, uint256 _amount) private {
        // Emit event
        emit TransferredToEntity(_from, _entity, _amount);

        // Update entity balance through receiving
        _entity.receiveTransfer(_amount);

        // Transfer to entity, transferring from approved balance from the caller
        registry.baseToken().safeTransferFrom(_from, address(_entity), _amount);
    }

    /**
     * Make arbitrary calls to other contracts as this contract.
     * @param _target The target contract.
     * @param _value The ETH value to send.
     * @param _data The calldata.
     * @return _response The response from the call.
     * @notice This function exists so Endaoment admins can make arbitrary calls to other contracts as this contract, specially if to unlock incorrectly sent assets.
     */
    function callAsContract(address _target, uint256 _value, bytes memory _data)
        external
        payable
        requiresAuth
        returns (bytes memory)
    {
        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);
        if (!_success) revert CallFailed(_response);
        return _response;
    }
}


// File: src/portfolios/TPlusNAsset.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity 0.8.13;

import {ERC20} from "solmate/tokens/ERC20.sol";

/// @title TPlusNAsset
/// @notice An ERC20 contract used by TPlusNPortfolio contracts to represent their underlying asset
contract TPlusNAsset is ERC20 {
    /// STATE

    /// @notice Address of the Endaoment Portfolio / Minter.
    address public portfolio;

    /// EVENTS
    event PortfolioSet(address indexed newPortfolio);

    /// ERRORS

    /// @notice Emitted when bad caller on portfolio-only calls.
    error OnlyPortfolio();

    constructor(string memory _name, string memory _symbol, address _portfolio) ERC20(_name, _symbol, 18) {
        portfolio = _portfolio;
        emit PortfolioSet(_portfolio);
    }

    /// MODIFIERS

    /**
     * @notice Make function only callable by the owning portfolio.
     */
    modifier onlyPortfolio() {
        _onlyPortfolio();
        _;
    }

    /**
     * @notice Internal function to check that the caller is the owning portfolio.
     * @dev Added for gas savings.
     */
    function _onlyPortfolio() private view {
        if (msg.sender != portfolio) revert OnlyPortfolio();
    }

    /**
     * @notice Mint assets for a given address.
     * @param _to The address to mint to.
     * @param _amount The amount to mint.
     * @dev Only callable by the owning portfolio.
     */
    function mint(address _to, uint256 _amount) external onlyPortfolio {
        _mint(_to, _amount);
    }

    /**
     * @notice Burn assets from a given address.
     * @param _from The address to burn from.
     * @param _amount The amount to burn.
     * @dev Only callable by the owning portfolio.
     */
    function burn(address _from, uint256 _amount) external onlyPortfolio {
        _burn(_from, _amount);
    }

    /**
     * @notice Burn assets from the caller.
     * @param _amount The amount to burn.
     * @dev Callable by anyone since it burns from the caller's balance.
     */
    function burn(uint256 _amount) external {
        _burn(msg.sender, _amount);
    }

    /**
     * @notice Update the owning portfolio
     * @param _newPortfolio The new portfolio address
     * @notice Should be rarely used but can be in case of a portfolio migration, to be able to use the same asset contract
     * @dev Only callable by the current portfolio
     */
    function setPortfolio(address _newPortfolio) external onlyPortfolio {
        portfolio = _newPortfolio;
        emit PortfolioSet(_newPortfolio);
    }
}


// File: src/Registry.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity 0.8.13;

import {Math} from "./lib/Math.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {Auth, Authority} from "./lib/auth/Auth.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

import {RegistryAuth} from "./RegistryAuth.sol";
import {Entity} from "./Entity.sol";
import {ISwapWrapper} from "./interfaces/ISwapWrapper.sol";
import {Portfolio} from "./Portfolio.sol";

// --- Errors ---
error Unauthorized();
error UnsupportedSwapper();

/**
 * @notice Registry entity - manages Factory and Entity state info.
 */
contract Registry is RegistryAuth {
    // --- Storage ---

    /// @notice Treasury address can receives fees.
    address public treasury;

    /// @notice Base Token address is the stable coin contract used throughout the system.
    ERC20 public immutable baseToken;

    /// @notice Mapping of approved factory contracts that are allowed to register new Entities.
    mapping(address => bool) public isApprovedFactory;
    /// @notice Mapping of active status of entities.
    mapping(Entity => bool) public isActiveEntity;

    /// @notice Maps entity type to donation fee percentage stored as a zoc, where type(uint32).max represents 0.
    mapping(uint8 => uint32) defaultDonationFee;
    /// @notice Maps specific entity receiver to donation fee percentage stored as a zoc.
    mapping(Entity => uint32) donationFeeReceiverOverride;

    /// @notice Maps entity type to payout fee percentage stored as a zoc, where type(uint32).max represents 0.
    mapping(uint8 => uint32) defaultPayoutFee;
    /// @notice Maps specific entity sender to payout fee percentage stored as a zoc.
    mapping(Entity => uint32) payoutFeeOverride;

    /// @notice Maps sender entity type to receiver entity type to fee percentage as a zoc.
    mapping(uint8 => mapping(uint8 => uint32)) defaultTransferFee;
    /// @notice Maps specific entity sender to receiver entity type to fee percentage as a zoc.
    mapping(Entity => mapping(uint8 => uint32)) transferFeeSenderOverride;
    /// @notice Maps sender entity type to specific entity receiver to fee percentage as a zoc.
    mapping(uint8 => mapping(Entity => uint32)) transferFeeReceiverOverride;
    /// @notice Maps swap wrappers to their enabled/disabled status.

    mapping(ISwapWrapper => bool) public isSwapperSupported;
    /// @notice Maps portfolios to their enabled/disabled status.
    mapping(Portfolio => bool) public isActivePortfolio;

    // --- Events ---

    /// @notice The event emitted when a factory is approved (whitelisted) or has it's approval removed.
    event FactoryApprovalSet(address indexed factory, bool isApproved);

    /// @notice The event emitted when an entity is set active or inactive.
    event EntityStatusSet(address indexed entity, bool isActive);

    /// @notice The event emitted when a swap wrapper is set active or inactive.
    event SwapWrapperStatusSet(address indexed swapWrapper, bool isSupported);

    /// @notice The event emitted when a portfolio is set active or inactive.
    event PortfolioStatusSet(address indexed portfolio, bool isActive);

    /// @notice Emitted when a default donation fee is set for an entity type.
    event DefaultDonationFeeSet(uint8 indexed entityType, uint32 fee);

    /// @notice Emitted when a donation fee override is set for a specific receiving entity.
    event DonationFeeReceiverOverrideSet(address indexed entity, uint32 fee);

    /// @notice Emitted when a default payout fee is set for an entity type.
    event DefaultPayoutFeeSet(uint8 indexed entityType, uint32 fee);

    /// @notice Emitted when a payout fee override is set for a specific sender entity.
    event PayoutFeeOverrideSet(address indexed entity, uint32 fee);

    /// @notice Emitted when a default transfer fee is set for transfers between entity types.
    event DefaultTransferFeeSet(uint8 indexed fromEntityType, uint8 indexed toEntityType, uint32 fee);

    /// @notice Emitted when a transfer fee override is set for transfers from an entity to a specific entityType.
    event TransferFeeSenderOverrideSet(address indexed fromEntity, uint8 indexed toEntityType, uint32 fee);

    /// @notice Emitted when a transfer fee override is set for transfers from an entityType to an entity.
    event TransferFeeReceiverOverrideSet(uint8 indexed fromEntityType, address indexed toEntity, uint32 fee);

    /// @notice Emitted when the registry treasury contract is changed
    event TreasuryChanged(address oldTreasury, address indexed newTreasury);

    /**
     * @notice Modifier for methods that require auth and that the manager cannot access.
     * @dev Overridden from Auth.sol. Reason: use custom error.
     */
    modifier requiresAuth() override {
        if (!isAuthorized(msg.sender, msg.sig)) revert Unauthorized();

        _;
    }

    // --- Constructor ---
    constructor(address _admin, address _treasury, ERC20 _baseToken) RegistryAuth(_admin, Authority(address(this))) {
        treasury = _treasury;
        emit TreasuryChanged(address(0), _treasury);
        baseToken = _baseToken;
    }

    // --- Internal fns ---

    /**
     * @notice Fee parsing to convert the special "type(uint32).max" value to zero, and zero to the "max".
     * @dev After converting, "type(uint32).max" will cause overflow/revert when used as a fee percentage multiplier and zero will mean no fee.
     * @param _value The value to be converted.
     * @return The parsed fee to use.
     */
    function _parseFeeWithFlip(uint32 _value) private pure returns (uint32) {
        if (_value == 0) {
            return type(uint32).max;
        } else if (_value == type(uint32).max) {
            return 0;
        } else {
            return _value;
        }
    }

    // --- External fns ---

    /**
     * @notice Sets a new Endaoment treasury address.
     * @param _newTreasury The new treasury.
     */
    function setTreasury(address _newTreasury) external requiresAuth {
        emit TreasuryChanged(treasury, _newTreasury);
        treasury = _newTreasury;
    }

    /**
     * @notice Sets the approval state of a factory. Grants the factory permissions to set entity status.
     * @param _factory The factory whose approval state is to be updated.
     * @param _isApproved True if the factory should be approved, false otherwise.
     */
    function setFactoryApproval(address _factory, bool _isApproved) external requiresAuth {
        isApprovedFactory[_factory] = _isApproved;
        emit FactoryApprovalSet(address(_factory), _isApproved);
    }

    /**
     * @notice Sets the enable/disable state of an Entity.
     * @param _entity The entity whose active state is to be updated.
     * @param _isActive True if the entity should be active, false otherwise.
     */
    function setEntityStatus(Entity _entity, bool _isActive) external requiresAuth {
        isActiveEntity[_entity] = _isActive;
        emit EntityStatusSet(address(_entity), _isActive);
    }

    /**
     * @notice Sets Entity as active. This is a special method to be called only by approved factories.
     * Other callers should use `setEntityStatus` instead.
     * @param _entity The entity.
     */
    function setEntityActive(Entity _entity) external {
        if (!isApprovedFactory[msg.sender]) revert Unauthorized();
        isActiveEntity[_entity] = true;
        emit EntityStatusSet(address(_entity), true);
    }

    /**
     * @notice Sets the enable/disable state of a Portfolio.
     * @param _portfolio Portfolio.
     * @param _isActive True if setting portfolio to active, false otherwise.
     */
    function setPortfolioStatus(Portfolio _portfolio, bool _isActive) external requiresAuth {
        isActivePortfolio[_portfolio] = _isActive;
        emit PortfolioStatusSet(address(_portfolio), _isActive);
    }

    /**
     * @notice Gets default donation fee pct (as a zoc) for an Entity.
     * @param _entity The receiving entity of the donation for which the fee is being fetched.
     * @return uint32 The default donation fee for the entity's type.
     * @dev Makes use of _parseFeeWithFlip, so if no default exists, "max" will be returned.
     */
    function getDonationFee(Entity _entity) external view returns (uint32) {
        return _parseFeeWithFlip(defaultDonationFee[_entity.entityType()]);
    }

    /**
     * @notice Gets lowest possible donation fee pct (as a zoc) for an Entity, among default and override.
     * @param _entity The receiving entity of the donation for which the fee is being fetched.
     * @return uint32 The minimum of the default donation fee and the receiver's fee override.
     * @dev Makes use of _parseFeeWithFlip, so if no default or override exists, "max" will be returned.
     */
    function getDonationFeeWithOverrides(Entity _entity) external view returns (uint32) {
        uint32 _default = _parseFeeWithFlip(defaultDonationFee[_entity.entityType()]);
        uint32 _receiverOverride = _parseFeeWithFlip(donationFeeReceiverOverride[_entity]);
        return _receiverOverride < _default ? _receiverOverride : _default;
    }

    /**
     * @notice Gets default payout fee pct (as a zoc) for an Entity.
     * @param _entity The sender entity of the payout for which the fee is being fetched.
     * @return uint32 The default payout fee for the entity's type.
     * @dev Makes use of _parseFeeWithFlip, so if no default exists, "max" will be returned.
     */
    function getPayoutFee(Entity _entity) external view returns (uint32) {
        return _parseFeeWithFlip(defaultPayoutFee[_entity.entityType()]);
    }

    /**
     * @notice Gets lowest possible payout fee pct (as a zoc) for an Entity, among default and override.
     * @param _entity The sender entity of the payout for which the fee is being fetched.
     * @return uint32 The minimum of the default payout fee and the sender's fee override.
     * @dev Makes use of _parseFeeWithFlip, so if no default or override exists, "max" will be returned.
     */
    function getPayoutFeeWithOverrides(Entity _entity) external view returns (uint32) {
        uint32 _default = _parseFeeWithFlip(defaultPayoutFee[_entity.entityType()]);
        uint32 _senderOverride = _parseFeeWithFlip(payoutFeeOverride[_entity]);
        return _senderOverride < _default ? _senderOverride : _default;
    }

    /**
     * @notice Gets default transfer fee pct (as a zoc) between sender & receiver Entities.
     * @param _sender The sending entity of the transfer for which the fee is being fetched.
     * @param _receiver The receiving entity of the transfer for which the fee is being fetched.
     * @return uint32 The default transfer fee.
     * @dev Makes use of _parseFeeWithFlip, so if no default exists, "type(uint32).max" will be returned.
     */
    function getTransferFee(Entity _sender, Entity _receiver) external view returns (uint32) {
        return _parseFeeWithFlip(defaultTransferFee[_sender.entityType()][_receiver.entityType()]);
    }

    /**
     * @notice Gets lowest possible transfer fee pct (as a zoc) between sender & receiver Entities, among default and overrides.
     * @param _sender The sending entity of the transfer for which the fee is being fetched.
     * @param _receiver The receiving entity of the transfer for which the fee is being fetched.
     * @return uint32 The minimum of the default transfer fee, and sender and receiver overrides.
     * @dev Makes use of _parseFeeWithFlip, so if no default or overrides exist, "type(uint32).max" will be returned.
     */
    function getTransferFeeWithOverrides(Entity _sender, Entity _receiver) external view returns (uint32) {
        uint32 _default = _parseFeeWithFlip(defaultTransferFee[_sender.entityType()][_receiver.entityType()]);
        uint32 _senderOverride = _parseFeeWithFlip(transferFeeSenderOverride[_sender][_receiver.entityType()]);
        uint32 _receiverOverride = _parseFeeWithFlip(transferFeeReceiverOverride[_sender.entityType()][_receiver]);

        uint32 _lowestFee = _default;
        _lowestFee = _senderOverride < _lowestFee ? _senderOverride : _lowestFee;
        _lowestFee = _receiverOverride < _lowestFee ? _receiverOverride : _lowestFee;
        return _lowestFee;
    }

    /**
     * @notice Sets the default donation fee for an entity type.
     * @param _entityType Entity type.
     * @param _fee The fee percentage to be set (a zoc).
     */
    function setDefaultDonationFee(uint8 _entityType, uint32 _fee) external requiresAuth {
        defaultDonationFee[_entityType] = _parseFeeWithFlip(_fee);
        emit DefaultDonationFeeSet(_entityType, _fee);
    }

    /**
     * @notice Sets the donation fee receiver override for a specific entity.
     * @param _entity Entity.
     * @param _fee The overriding fee (a zoc).
     */
    function setDonationFeeReceiverOverride(Entity _entity, uint32 _fee) external requiresAuth {
        donationFeeReceiverOverride[_entity] = _parseFeeWithFlip(_fee);
        emit DonationFeeReceiverOverrideSet(address(_entity), _fee);
    }

    /**
     * @notice Sets the default payout fee for an entity type.
     * @param _entityType Entity type.
     * @param _fee The fee percentage to be set (a zoc).
     */
    function setDefaultPayoutFee(uint8 _entityType, uint32 _fee) external requiresAuth {
        defaultPayoutFee[_entityType] = _parseFeeWithFlip(_fee);
        emit DefaultPayoutFeeSet(_entityType, _fee);
    }

    /**
     * @notice Sets the payout fee override for a specific entity.
     * @param _entity Entity.
     * @param _fee The overriding fee (a zoc).
     */
    function setPayoutFeeOverride(Entity _entity, uint32 _fee) external requiresAuth {
        payoutFeeOverride[_entity] = _parseFeeWithFlip(_fee);
        emit PayoutFeeOverrideSet(address(_entity), _fee);
    }

    /**
     * @notice Sets the default transfer fee for transfers from one specific entity type to another.
     * @param _fromEntityType The entityType making the transfer.
     * @param _toEntityType The receiving entityType.
     * @param _fee The transfer fee percentage (a zoc).
     */
    function setDefaultTransferFee(uint8 _fromEntityType, uint8 _toEntityType, uint32 _fee) external requiresAuth {
        defaultTransferFee[_fromEntityType][_toEntityType] = _parseFeeWithFlip(_fee);
        emit DefaultTransferFeeSet(_fromEntityType, _toEntityType, _fee);
    }

    /**
     * @notice Sets the transfer fee override for transfers from one specific entity to entities of a given type.
     * @param _fromEntity The entity making the transfer.
     * @param _toEntityType The receiving entityType.
     * @param _fee The overriding fee percentage (a zoc).
     */
    function setTransferFeeSenderOverride(Entity _fromEntity, uint8 _toEntityType, uint32 _fee) external requiresAuth {
        transferFeeSenderOverride[_fromEntity][_toEntityType] = _parseFeeWithFlip(_fee);
        emit TransferFeeSenderOverrideSet(address(_fromEntity), _toEntityType, _fee);
    }

    /**
     * @notice Sets the transfer fee override for transfers from entities of a given type to a specific entity.
     * @param _fromEntityType The entityType making the transfer.
     * @param _toEntity The receiving entity.
     * @param _fee The overriding fee percentage (a zoc).
     */
    function setTransferFeeReceiverOverride(uint8 _fromEntityType, Entity _toEntity, uint32 _fee)
        external
        requiresAuth
    {
        transferFeeReceiverOverride[_fromEntityType][_toEntity] = _parseFeeWithFlip(_fee);
        emit TransferFeeReceiverOverrideSet(_fromEntityType, address(_toEntity), _fee);
    }

    /**
     * @notice Sets the enable/disable state of a SwapWrapper. System owners must ensure meticulous review of SwapWrappers before approving them.
     * @param _swapWrapper A contract that implements ISwapWrapper.
     * @param _supported `true` if supported, `false` if unsupported.
     */
    function setSwapWrapperStatus(ISwapWrapper _swapWrapper, bool _supported) external requiresAuth {
        isSwapperSupported[_swapWrapper] = _supported;
        emit SwapWrapperStatusSet(address(_swapWrapper), _supported);
    }
}


// File: src/Entity.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity >=0.8.0;

import "solmate/tokens/ERC20.sol";
import "solmate/utils/SafeTransferLib.sol";
import "./lib/ReentrancyGuard.sol";

import {Registry} from "./Registry.sol";
import {ISwapWrapper} from "./interfaces/ISwapWrapper.sol";
import {EndaomentAuth} from "./lib/auth/EndaomentAuth.sol";
import {Portfolio} from "./Portfolio.sol";
import {Math} from "./lib/Math.sol";

error EntityInactive();
error PortfolioInactive();
error InsufficientFunds();
error InvalidAction();
error BalanceMismatch();
error CallFailed(bytes response);

/**
 * @notice Entity contract inherited by Org and Fund contracts (and all future kinds of Entities).
 */
abstract contract Entity is EndaomentAuth, ReentrancyGuard {
    using Math for uint256;
    using SafeTransferLib for ERC20;

    /// @notice The base registry to which the entity is connected.
    Registry public registry;

    /// @notice The entity's manager.
    address public manager;

    // @notice The base token used for tracking the entity's fund balance.
    ERC20 public baseToken;

    /// @notice The current balance for the entity, denominated in the base token's units.
    uint256 public balance;

    /// @notice Placeholder address used in swapping method to denote usage of ETH instead of a token.
    address public constant ETH_PLACEHOLDER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @notice Emitted when manager is set.
    event EntityManagerSet(address indexed oldManager, address indexed newManager);

    /// @notice Emitted when a donation is made.
    event EntityDonationReceived(
        address indexed from,
        address indexed to,
        address indexed tokenIn,
        uint256 amountIn,
        uint256 amountReceived,
        uint256 amountFee
    );

    /// @notice Emitted when a payout is made from an entity.
    event EntityValuePaidOut(address indexed from, address indexed to, uint256 amountSent, uint256 amountFee);

    /// @notice Emitted when a transfer is made between entities.
    event EntityValueTransferred(address indexed from, address indexed to, uint256 amountReceived, uint256 amountFee);

    /// @notice Emitted when a base token reconciliation completes
    event EntityBalanceReconciled(address indexed entity, uint256 amountReceived, uint256 amountFee);

    /// @notice Emitted when a base token balance is used to correct the internal contract balance.
    event EntityBalanceCorrected(address indexed entity, uint256 newBalance);

    /// @notice Emitted when a portfolio deposit is made.
    event EntityDeposit(address indexed portfolio, uint256 baseTokenDeposited, uint256 sharesReceived);

    /// @notice Emitted when a portfolio share redemption is made.
    event EntityRedeem(address indexed portfolio, uint256 sharesRedeemed, uint256 baseTokenReceived);

    /// @notice Emitted when ether is received.
    event EntityEthReceived(address indexed sender, uint256 amount);

    /**
     * @notice Modifier for methods that require auth and that the manager can access.
     * @dev Uses the same condition as `requiresAuth` but with added manager access.
     */
    modifier requiresManager() {
        if (msg.sender != manager && !isAuthorized(msg.sender, msg.sig)) revert Unauthorized();
        _;
    }

    /// @notice Each entity will implement this function to allow a caller to interrogate what kind of entity it is.
    function entityType() public pure virtual returns (uint8);

    /**
     * @notice One time method to be called at deployment to configure the contract. Required so Entity
     * contracts can be deployed as minimal proxies (clones).
     * @param _registry The registry to host the Entity.
     * @param _manager The address of the Entity's manager.
     */
    function __initEntity(Registry _registry, address _manager) internal {
        // Call to EndaomentAuth's initialize function ensures that this can't be called again
        __initEndaomentAuth(_registry, bytes20(bytes.concat("entity", bytes1(entityType()))));
        __initReentrancyGuard();
        registry = _registry;
        manager = _manager;
        baseToken = _registry.baseToken();
    }

    /**
     * @notice Set a new manager for this entity.
     * @param _manager Address of new manager.
     * @dev Callable by current manager or permissioned role.
     */
    function setManager(address _manager) external virtual requiresManager {
        emit EntityManagerSet(manager, _manager);
        manager = _manager;
    }

    /**
     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers default fee to treasury.
     * @param _amount Amount donated in base token.
     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function donate(uint256 _amount) external virtual {
        uint32 _feeMultiplier = registry.getDonationFee(this);
        _donateWithFeeMultiplier(_amount, _feeMultiplier);
    }

    /**
     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers default or overridden fee to treasury.
     * @param _amount Amount donated in base token.
     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function donateWithOverrides(uint256 _amount) external virtual {
        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);
        _donateWithFeeMultiplier(_amount, _feeMultiplier);
    }

    /**
     * @notice Receives a donated amount of base tokens to be added to the entity's balance.
     * This method can be called by permissioned actors to make a donation with a manually specified fee.
     * @param _amount Amount donated in base token.
     * @param _feeOverride Fee percentage as zoc.
     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.
     */
    function donateWithAdminOverrides(uint256 _amount, uint32 _feeOverride) external virtual requiresAuth {
        _donateWithFeeMultiplier(_amount, _feeOverride);
    }

    /**
     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers fee calculated by fee multiplier to treasury.
     * @param _amount Amount donated in base token.
     * @param _feeMultiplier Value indicating the percentage of the Endaoment donation fee to go to the Endaoment treasury.
     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function _donateWithFeeMultiplier(uint256 _amount, uint32 _feeMultiplier) internal virtual {
        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);
        baseToken.safeTransferFrom(msg.sender, registry.treasury(), _fee);
        baseToken.safeTransferFrom(msg.sender, address(this), _netAmount);

        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            balance += _netAmount;
        }
        emit EntityDonationReceived(msg.sender, address(this), address(baseToken), _amount, _amount, _fee);
    }

    /**
     * @notice Receive a donated amount of ETH or ERC20 tokens, swaps them to base tokens, and adds the output to the
     * entity's balance. Fee calculated using default rate and sent to treasury.
     * @param _swapWrapper The swap wrapper to use for the donation. Must be whitelisted on the Registry.
     * @param _tokenIn The address of the ERC20 token to swap and donate, or ETH_PLACEHOLDER if donating ETH.
     * @param _amountIn The amount of tokens or ETH being swapped and donated.
     * @param _data Additional call data required by the ISwapWrapper being used.
     */
    function swapAndDonate(ISwapWrapper _swapWrapper, address _tokenIn, uint256 _amountIn, bytes calldata _data)
        external
        payable
        virtual
    {
        uint32 _feeMultiplier = registry.getDonationFee(this);
        _swapAndDonateWithFeeMultiplier(_swapWrapper, _tokenIn, _amountIn, _data, _feeMultiplier);
    }

    /**
     * @notice Receive a donated amount of ETH or ERC20 tokens, swaps them to base tokens, and adds the output to the
     * entity's balance. Fee calculated using override rate and sent to treasury.
     * @param _swapWrapper The swap wrapper to use for the donation. Must be whitelisted on the Registry.
     * @param _tokenIn The address of the ERC20 token to swap and donate, or ETH_PLACEHOLDER if donating ETH.
     * @param _amountIn The amount of tokens or ETH being swapped and donated.
     * @param _data Additional call data required by the ISwapWrapper being used.
     */
    function swapAndDonateWithOverrides(
        ISwapWrapper _swapWrapper,
        address _tokenIn,
        uint256 _amountIn,
        bytes calldata _data
    ) external payable virtual {
        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);
        _swapAndDonateWithFeeMultiplier(_swapWrapper, _tokenIn, _amountIn, _data, _feeMultiplier);
    }

    /// @dev Internal helper implementing swap and donate functionality for any fee multiplier provided.
    function _swapAndDonateWithFeeMultiplier(
        ISwapWrapper _swapWrapper,
        address _tokenIn,
        uint256 _amountIn,
        bytes calldata _data,
        uint32 _feeMultiplier
    ) internal virtual nonReentrant {
        if (!registry.isSwapperSupported(_swapWrapper)) revert InvalidAction();

        // THINK: do we need a re-entrancy guard on this method?
        if (_tokenIn != ETH_PLACEHOLDER) {
            ERC20(_tokenIn).safeTransferFrom(msg.sender, address(this), _amountIn);
            ERC20(_tokenIn).safeApprove(address(_swapWrapper), 0);
            ERC20(_tokenIn).safeApprove(address(_swapWrapper), _amountIn);
        }

        uint256 _amountOut =
            _swapWrapper.swap{value: msg.value}(_tokenIn, address(baseToken), address(this), _amountIn, _data);

        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amountOut, _feeMultiplier);

        baseToken.safeTransfer(registry.treasury(), _fee);

        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            balance += _netAmount;
        }

        if (balance > baseToken.balanceOf(address(this))) revert BalanceMismatch();

        emit EntityDonationReceived(msg.sender, address(this), _tokenIn, _amountIn, _amountOut, _fee);
    }

    /**
     * @notice Transfers an amount of base tokens from one entity to another. Transfers default fee to treasury.
     * @param _to The entity to receive the tokens.
     * @param _amount Contains the amount being donated (denominated in the base token's units).
     * @dev Reverts if the entity is inactive or if the token transfer fails.
     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.
     * @dev Renamed from `transfer` to distinguish from ERC20 transfer in 3rd party tools.
     */
    function transferToEntity(Entity _to, uint256 _amount) external virtual requiresManager {
        uint32 _feeMultiplier = registry.getTransferFee(this, _to);
        _transferWithFeeMultiplier(_to, _amount, _feeMultiplier);
    }

    /**
     * @notice Transfers an amount of base tokens from one entity to another. Transfers default or overridden fee to treasury.
     * @param _to The entity to receive the tokens.
     * @param _amount Contains the amount being donated (denominated in the base token's units).
     * @dev Reverts if the entity is inactive or if the token transfer fails.
     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.
     */
    function transferToEntityWithOverrides(Entity _to, uint256 _amount) external virtual requiresManager {
        uint32 _feeMultiplier = registry.getTransferFeeWithOverrides(this, _to);
        _transferWithFeeMultiplier(_to, _amount, _feeMultiplier);
    }

    /**
     * @notice Transfers an amount of base tokens from one entity to another. Transfers fee specified by a privileged role.
     * @param _to The entity to receive the tokens.
     * @param _amount Contains the amount being donated (denominated in the base token's units).
     * @param _feeOverride Admin override configured by an Admin
     * @dev Reverts if the entity is inactive or if the token transfer fails.
     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.
     */
    function transferToEntityWithAdminOverrides(Entity _to, uint256 _amount, uint32 _feeOverride)
        external
        virtual
        requiresAuth
    {
        _transferWithFeeMultiplier(_to, _amount, _feeOverride);
    }

    /**
     * @notice Transfers an amount of base tokens from one entity to another. Transfers fee calculated by fee multiplier to treasury.
     * @param _to The entity to receive the tokens.
     * @param _amount Contains the amount being donated (denominated in the base token's units).
     * @param _feeMultiplier Value indicating the percentage of the Endaoment donation fee to go to the Endaoment treasury.
     * @dev Reverts with 'Inactive' if the entity sending the transfer or the entity receiving the transfer is inactive.
     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.
     * @dev Reverts if the token transfer fails.
     */
    function _transferWithFeeMultiplier(Entity _to, uint256 _amount, uint32 _feeMultiplier) internal virtual {
        if (!registry.isActiveEntity(this) || !registry.isActiveEntity(_to)) revert EntityInactive();
        if (balance < _amount) revert InsufficientFunds();

        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);
        baseToken.safeTransfer(registry.treasury(), _fee);
        baseToken.safeTransfer(address(_to), _netAmount);

        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            balance -= _amount;
            _to.receiveTransfer(_netAmount);
        }
        emit EntityValueTransferred(address(this), address(_to), _amount, _fee);
    }

    /**
     * @notice Updates the receiving entity balance on a transfer.
     * @param _transferAmount The amount being received on the transfer.
     * @dev This function is external, but is restricted such that it can only be called by other entities.
     */
    function receiveTransfer(uint256 _transferAmount) external virtual {
        if (!registry.isActiveEntity(Entity(payable(msg.sender)))) revert EntityInactive();
        unchecked {
            // Cannot overflow with realistic balances.
            balance += _transferAmount;
        }
    }

    /**
     * @notice Deposits an amount of Entity's `baseToken` into an Endaoment-approved Portfolio.
     * @param _portfolio An Endaoment-approved portfolio.
     * @param _amount Amount of `baseToken` to deposit into the portfolio.
     * @param _data Data required by a portfolio to deposit.
     * @return _shares Amount of portfolio share tokens Entity received as a result of this deposit.
     */
    function portfolioDeposit(Portfolio _portfolio, uint256 _amount, bytes calldata _data)
        external
        virtual
        requiresManager
        returns (uint256)
    {
        if (!registry.isActivePortfolio(_portfolio)) revert PortfolioInactive();
        balance -= _amount;
        baseToken.safeApprove(address(_portfolio), _amount);
        uint256 _shares = _portfolio.deposit(_amount, _data);
        emit EntityDeposit(address(_portfolio), _amount, _shares);
        return _shares;
    }

    /**
     * @notice Redeems an amount of Entity's portfolio shares for an amount of `baseToken`.
     * @param _portfolio An Endaoment-approved portfolio.
     * @param _shares Amount of share tokens to redeem.
     * @param _data Data required by a portfolio to redeem.
     * @return _received Amount of `baseToken` Entity received as a result of this redemption.
     */
    function portfolioRedeem(Portfolio _portfolio, uint256 _shares, bytes calldata _data)
        external
        virtual
        requiresManager
        returns (uint256)
    {
        if (!registry.isActivePortfolio(_portfolio)) revert PortfolioInactive();
        uint256 _received = _portfolio.redeem(_shares, _data);
        // unchecked: a realistic balance can never overflow a uint256
        unchecked {
            balance += _received;
        }
        emit EntityRedeem(address(_portfolio), _shares, _received);
        return _received;
    }

    /**
     * @notice This method should be called to reconcile the Entity's internal baseToken accounting with the baseToken contract's accounting.
     * There are a 2 situations where calling this method is appropriate:
     * 1. To process amounts of baseToken that arrived at this Entity through methods besides Entity:donate or Entity:transfer. For example,
     * if this Entity receives a normal ERC20 transfer of baseToken, the amount received will be unavailable for Entity use until this method
     * is called to adjust the balance and process fees. OrgFundFactory.sol:_donate makes use of this method to do this as well.
     * 2. Unusually, the Entity's perspective of balance could be lower than `baseToken.balanceOf(this)`. This could happen if
     * Entity:callAsEntity is used to transfer baseToken. In this case, this method provides a way of correcting the Entity's internal balance.
     */
    function reconcileBalance() external virtual {
        uint256 _tokenBalance = baseToken.balanceOf(address(this));

        if (_tokenBalance >= balance) {
            uint256 _sweepAmount = _tokenBalance - balance;
            uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);
            (uint256 _netAmount, uint256 _fee) = _calculateFee(_sweepAmount, _feeMultiplier);

            baseToken.safeTransfer(registry.treasury(), _fee);
            unchecked {
                balance += _netAmount;
            }
            emit EntityBalanceReconciled(address(this), _sweepAmount, _fee);
        } else {
            // Handle abnormal scenario where _tokenBalance < balance (see method docs)
            balance = _tokenBalance;
            emit EntityBalanceCorrected(address(this), _tokenBalance);
        }
    }

    /**
     * @notice Takes stray tokens or ETH sent directly to this Entity, swaps them for base token, then adds them to the
     * Entity's balance after paying the appropriate fee to the treasury.
     * @param _swapWrapper The swap wrapper to use to convert the assets. Must be whitelisted on the Registry.
     * @param _tokenIn The address of the ERC20 token to swap, or ETH_PLACEHOLDER if ETH.
     * @param _amountIn The amount of tokens or ETH being swapped and added to the balance.
     * @param _data Additional call data required by the ISwapWrapper being used.
     */
    function swapAndReconcileBalance(
        ISwapWrapper _swapWrapper,
        address _tokenIn,
        uint256 _amountIn,
        bytes calldata _data
    ) external virtual nonReentrant requiresManager {
        if (!registry.isSwapperSupported(_swapWrapper)) revert InvalidAction();

        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);

        if (_tokenIn != ETH_PLACEHOLDER) {
            ERC20(_tokenIn).safeApprove(address(_swapWrapper), 0);
            ERC20(_tokenIn).safeApprove(address(_swapWrapper), _amountIn);
        }

        // Send value only if token in is ETH
        uint256 _value = _tokenIn == ETH_PLACEHOLDER ? _amountIn : 0;

        uint256 _amountOut =
            _swapWrapper.swap{value: _value}(_tokenIn, address(baseToken), address(this), _amountIn, _data);

        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amountOut, _feeMultiplier);
        baseToken.safeTransfer(registry.treasury(), _fee);

        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            balance += _netAmount;
        }

        if (balance > baseToken.balanceOf(address(this))) revert BalanceMismatch();

        emit EntityBalanceReconciled(address(this), _amountOut, _fee);
    }

    /**
     * @notice Permissioned method that allows Endaoment admin to make arbitrary calls acting as this Entity.
     * @param _target The address to which the call will be made.
     * @param _value The ETH value that should be forwarded with the call.
     * @param _data The calldata that will be sent with the call.
     * @return _return The data returned by the call.
     */
    function callAsEntity(address _target, uint256 _value, bytes memory _data)
        external
        payable
        virtual
        requiresAuth
        returns (bytes memory)
    {
        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);
        if (!_success) revert CallFailed(_response);
        return _response;
    }

    /**
     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by the
     * default fee multiplier to the treasury.
     * @param _to The address to receive the tokens.
     * @param _amount Amount donated in base token.
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.
     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function payout(address _to, uint256 _amount) external virtual requiresAuth {
        uint32 _feeMultiplier = registry.getPayoutFee(this);
        _payoutWithFeeMultiplier(_to, _amount, _feeMultiplier);
    }

    /**
     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by the
     * default fee multiplier to the treasury.
     * @param _amount Amount donated in base token.
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.
     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function payoutWithOverrides(address _to, uint256 _amount) external virtual requiresAuth {
        uint32 _feeMultiplier = registry.getPayoutFeeWithOverrides(this);
        _payoutWithFeeMultiplier(_to, _amount, _feeMultiplier);
    }

    /**
     * @notice Pays out an amount of base tokens from the entity to an address. Transfers fee specified by a privileged role.
     * @param _amount Amount donated in base token.
     * @param _feeOverride Payout override configured by an Admin
     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.
     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     * @dev Reverts if the token transfer fails.
     */
    function payoutWithAdminOverrides(address _to, uint256 _amount, uint32 _feeOverride)
        external
        virtual
        requiresAuth
    {
        _payoutWithFeeMultiplier(_to, _amount, _feeOverride);
    }

    /**
     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by fee multiplier to the treasury.
     * @param _to The address to receive the tokens.
     * @param _amount Contains the amount being paid out (denominated in the base token's units).
     * @param _feeMultiplier Value indicating the percentage of the Endaoment fee to go to the Endaoment treasury.
     * @dev Reverts if the token transfer fails.
     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).
     */
    function _payoutWithFeeMultiplier(address _to, uint256 _amount, uint32 _feeMultiplier) internal virtual {
        if (balance < _amount) revert InsufficientFunds();

        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);
        baseToken.safeTransfer(registry.treasury(), _fee);
        baseToken.safeTransfer(address(_to), _netAmount);

        unchecked {
            // unchecked because we've already validated that amount is less than or equal to the balance
            balance -= _amount;
        }
        emit EntityValuePaidOut(address(this), _to, _amount, _fee);
    }

    /// @dev Internal helper method to calculate the fee on a base token amount for a given fee multiplier.
    function _calculateFee(uint256 _amount, uint256 _feeMultiplier)
        internal
        pure
        virtual
        returns (uint256 _netAmount, uint256 _fee)
    {
        if (_feeMultiplier > Math.ZOC) revert InvalidAction();
        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            _fee = _amount.zocmul(_feeMultiplier);
            // unchecked as the _feeMultiplier check with revert above protects against overflow
            _netAmount = _amount - _fee;
        }
    }

    receive() external payable virtual {
        emit EntityEthReceived(msg.sender, msg.value);
    }
}


// File: src/Portfolio.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity >=0.8.0;

import {ReentrancyGuard} from "solmate/utils/ReentrancyGuard.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
import {Registry} from "./Registry.sol";
import {Entity} from "./Entity.sol";
import {EndaomentAuth} from "./lib/auth/EndaomentAuth.sol";
import {Math} from "./lib/Math.sol";

abstract contract Portfolio is ERC20, EndaomentAuth, ReentrancyGuard {
    using Math for uint256;
    using SafeTransferLib for ERC20;

    Registry public immutable registry;
    bool public immutable async;
    uint256 public cap;
    address public feeTreasury;
    uint256 public depositFee;
    uint256 public redemptionFee;
    address public immutable asset;
    address public immutable receiptAsset;
    ERC20 public immutable baseToken;
    bool public didShutdown;
    uint256 public timestampAumFeesTaken;
    uint256 public aumRate;
    uint256 internal constant MAX_AUM_RATE = 3168808782;

    error InvalidSwapper();
    error InvalidRate();
    error TransferDisallowed();
    error DepositAfterShutdown();
    error DidShutdown();
    error NotEntity();
    error BadCheckCapImplementation();
    error ExceedsCap();
    error PercentageOver100();
    error RoundsToZero();
    error Slippage();
    error CallFailed(bytes response);

    /// @notice `sender` has exchanged `assets` (after fees) for `shares`, and transferred those `shares` to `receiver`.
    /// The sender paid a total of `depositAmount` and was charged `fee` for the transaction.
    event Deposit(
        address indexed sender,
        address indexed receiver,
        uint256 assets,
        uint256 shares,
        uint256 depositAmount,
        uint256 fee
    );

    /// @notice `sender` has exchanged `shares` for `assets`, and transferred those `assets` to `receiver`.
    /// The sender received a net of `redeemedAmount` after the conversion of `assets` into base tokens
    /// and was charged `fee` for the transaction.
    event Redeem(
        address indexed sender,
        address indexed receiver,
        uint256 assets,
        uint256 shares,
        uint256 redeemedAmount,
        uint256 fee
    );

    /// @notice Event emitted when `cap` is set.
    event CapSet(uint256 cap);

    /// @notice Event emitted when `depositFee` is set.
    event DepositFeeSet(uint256 fee);

    /// @notice Event emitted when `redemptionFee` is set.
    event RedemptionFeeSet(uint256 fee);

    /// @notice Event emitted when `feeTreasury` is set.
    event FeeTreasurySet(address feeTreasury);

    /// @notice Event emitted when management takes fees.
    event FeesTaken(uint256 amount);

    /// @notice Event emitted when AUM fees are taken.
    event AumFeesTaken(uint256 feeAmount, uint256 timeDelta);

    /// @notice Event emitted when `aumRate` is set.
    event AumRateSet(uint256 rate);

    /// @notice Event emitted when admin forcefully swaps portfolio asset balance for baseToken.
    event Shutdown(uint256 assetAmount, uint256 baseTokenOut);

    /**
     * @param _registry Endaoment registry.
     * @param _receiptAsset Address of token that the portfolio receives from a deposit.
     * @param _name Name of the ERC20 Portfolio share tokens.
     * @param _async Whether the portfolio is async for deposits and redeems. Typically used for T+N portfolios
     * @param _symbol Symbol of the ERC20 Portfolio share tokens.
     * @param _cap Amount in baseToken that value of totalAssets should not exceed.
     * @param _depositFee Percentage fee as ZOC that will go to treasury on asset deposit.
     * @param _redemptionFee Percentage fee as ZOC that will go to treasury on share redemption.
     * @param _aumRate Percentage fee per second (as WAD) that should accrue to treasury as AUM fee. (1e16 = 1%).
     */
    constructor(
        Registry _registry,
        address _receiptAsset,
        string memory _name,
        string memory _symbol,
        bool _async,
        uint256 _cap,
        address _feeTreasury,
        uint256 _depositFee,
        uint256 _redemptionFee,
        uint256 _aumRate
    ) ERC20(_name, _symbol, ERC20(_getAsset(_receiptAsset)).decimals()) {
        __initEndaomentAuth(_registry, "portfolio");
        registry = _registry;

        async = _async;

        feeTreasury = _feeTreasury;
        emit FeeTreasurySet(_feeTreasury);

        if (_redemptionFee > Math.ZOC) revert PercentageOver100();
        redemptionFee = _redemptionFee;
        emit RedemptionFeeSet(_redemptionFee);

        if (_depositFee > Math.ZOC) revert PercentageOver100();
        depositFee = _depositFee;
        emit DepositFeeSet(_depositFee);

        cap = _cap;
        emit CapSet(_cap);

        receiptAsset = _receiptAsset;
        asset = _getAsset(_receiptAsset);
        baseToken = registry.baseToken();

        if (_aumRate > MAX_AUM_RATE) revert InvalidRate();
        aumRate = _aumRate;
        emit AumRateSet(_aumRate);

        timestampAumFeesTaken = block.timestamp;
    }

    /**
     * @notice Returns the underlying asset for the `receiptAsset`.
     * @param _receiptAsset Address of token that the portfolio receives from a deposit.
     * @return Address of the underlying asset.
     */
    function _getAsset(address _receiptAsset) internal view virtual returns (address);

    /**
     * @notice Function used to determine whether an Entity is active on the registry.
     * @param _entity The Entity.
     */
    function _isEntity(Entity _entity) internal view returns (bool) {
        return registry.isActiveEntity(_entity);
    }

    /**
     * @notice Set the Portfolio cap.
     * @param _amount Amount, denominated in baseToken.
     */
    function setCap(uint256 _amount) external requiresAuth {
        cap = _amount;
        emit CapSet(_amount);
    }

    /**
     * @notice Set deposit fee.
     * @param _pct Percentage as ZOC (e.g. 1000 = 10%).
     */
    function setDepositFee(uint256 _pct) external requiresAuth {
        if (_pct > Math.ZOC) revert PercentageOver100();
        depositFee = _pct;
        emit DepositFeeSet(_pct);
    }

    /**
     * @notice Set redemption fee.
     * @param _pct Percentage as ZOC (e.g. 1000 = 10%).
     */
    function setRedemptionFee(uint256 _pct) external requiresAuth {
        if (_pct > Math.ZOC) revert PercentageOver100();
        redemptionFee = _pct;
        emit RedemptionFeeSet(_pct);
    }

    /**
     * @notice Set fee treasury.
     * @param _feeTreasury Address of the treasury that should receive fees.
     *
     */
    function setFeeTreasury(address _feeTreasury) external requiresAuth {
        feeTreasury = _feeTreasury;
        emit FeeTreasurySet(_feeTreasury);
    }

    /**
     * @notice Set AUM rate.
     * @param _pct Percentage *per second* as WAD (e.g. .01e18 / 365.25 days = 1% per year).
     */
    function setAumRate(uint256 _pct) external requiresAuth {
        // check to make sure _pct isn't above 10% over a year (.1e18 / 365.25 days = 3168808782 per second)
        if (_pct > MAX_AUM_RATE) revert InvalidRate();
        takeAumFees();
        aumRate = _pct;
        emit AumRateSet(_pct);
    }

    /**
     * @notice Total amount of the underlying asset that is managed by the Portfolio.
     * @return Total amount of the underlying asset.
     */
    function totalAssets() public view returns (uint256) {
        return convertReceiptAssetsToAssets(totalReceiptAssets());
    }

    /**
     * @notice Total amount of the receipt asset that is managed by the Portfolio.
     * @return Total amount of the receipt asset.
     */
    function totalReceiptAssets() public view returns (uint256) {
        return ERC20(receiptAsset).balanceOf(address(this));
    }

    /**
     * @notice Calculates the equivalent amount of assets for the given amount of receipt assets.
     * @param _receiptAssets Amount of receipt assets to convert.
     * @return Amount of assets.
     */
    function convertReceiptAssetsToAssets(uint256 _receiptAssets) public view virtual returns (uint256);

    /**
     * @notice Takes some amount of receipt assets from this portfolio as management fee.
     * @param _amountReceiptAssets Amount of receipt assets to take.
     */
    function takeFees(uint256 _amountReceiptAssets) external requiresAuth {
        ERC20(receiptAsset).safeTransfer(feeTreasury, _amountReceiptAssets);
        emit FeesTaken(_amountReceiptAssets);
    }

    /**
     * @notice Takes accrued percentage of assets from this portfolio as AUM fee.
     */
    function takeAumFees() public {
        if (didShutdown) return _takeAumFeesShutdown();
        uint256 _totalReceiptAssets = totalReceiptAssets();
        uint256 _period = block.timestamp - timestampAumFeesTaken;
        uint256 _feeAmount = _calculateAumFee(_totalReceiptAssets, _period);
        if (_feeAmount > _totalReceiptAssets) _feeAmount = _totalReceiptAssets;
        if (_feeAmount > 0 || totalSupply == 0) {
            // in either case, we want to set `timestampAumFeesTaken`...
            timestampAumFeesTaken = block.timestamp;
            // but we only want to transfer/emit on non-zero amount
            if (_feeAmount > 0) {
                ERC20(receiptAsset).safeTransfer(feeTreasury, _feeAmount);
                emit AumFeesTaken(_feeAmount, _period);
            }
        }
    }

    /**
     * @notice Takes accrued percentage of post-shutdown baseToken from this portfolio as AUM fee.
     */
    function _takeAumFeesShutdown() internal {
        uint256 _totalAssets = baseToken.balanceOf(address(this));
        uint256 _period = block.timestamp - timestampAumFeesTaken;
        uint256 _feeAmount = _calculateAumFee(_totalAssets, _period);
        if (_feeAmount > _totalAssets) _feeAmount = _totalAssets;
        // in `takeAumFees`, the following conditional checks totalSupply as well, solving a first deposit corner case.
        // In this case, we don't need to check, because deposits aren't allowed after shutdown.
        if (_feeAmount > 0) {
            timestampAumFeesTaken = block.timestamp;
            baseToken.safeTransfer(feeTreasury, _feeAmount);
            emit AumFeesTaken(_feeAmount, _period);
        }
    }

    /**
     * @notice Exchange `_amountBaseToken` for some amount of Portfolio shares.
     * @param _amountBaseToken The amount of the Entity's baseToken to deposit.
     * @param _data Data that the portfolio needs to make the deposit. In some cases, this will be swap parameters.
     * The first 32 bytes of this data should be the ABI-encoded `minSharesOut`.
     * @return shares The amount of shares that this deposit yields to the Entity.
     * @dev If the portfolio is `async`, shares will not be minted on deposit. Instead, each async
     * portfolio will have a unique implementation that will handle the minting of those shares
     * elsewhere e.g. T+N portfolios perform minting in consolidations.
     */
    function deposit(uint256 _amountBaseToken, bytes calldata _data) external nonReentrant returns (uint256) {
        // All portfolios should revert on deposit after shutdown
        if (didShutdown) revert DepositAfterShutdown();

        // All portfolios should revert on a deposit from a non-entity (or inactive one)
        if (!_isEntity(Entity(payable(msg.sender)))) revert NotEntity();

        // All portfolios should take AUM fees
        takeAumFees();

        // All portfolios should make a deposit
        // All transferring of baseToken and share calculation should occur inside _deposit
        // TODO: move fee taking logic here instead of `_deposit` for all portfolios and update tests
        (uint256 _shares, uint256 _assets, uint256 _fee) = _deposit(_amountBaseToken, _data);

        // Only sync portfolios require minting and share amount checking on deposit
        if (!async) {
            if (_shares < abi.decode(_data, (uint256))) revert Slippage();
            if (_shares == 0) revert RoundsToZero();

            // mint shares
            _mint(msg.sender, _shares);
        }

        // And check cap
        _checkCap();

        // And emit an event
        emit Deposit(msg.sender, msg.sender, _assets, _shares, _amountBaseToken, _fee);

        return _shares;
    }

    /**
     * @notice Check to make sure the cap has not been exceeded.
     * @dev Most portfolios have the same asset and baseToken, so the _checkCap implementation here is written to accomodate
     * that situation. For portfolios where that is not the case, this method needs to be overwritten to ensure the cap
     * (denominated in baseToken) is properly compared to the number of assets.
     */
    function _checkCap() internal virtual {
        if (asset != address(baseToken)) revert BadCheckCapImplementation();
        if (totalAssets() > cap) revert ExceedsCap();
    }

    /**
     * @notice Exchange `_amountIn` for some amount of Portfolio shares.
     * @dev Should include the transferring of baseToken and conversion to shares.
     * @param _amountIn The amount of the Entity's baseToken to deposit.
     * @param _data Data that the portfolio needs to make the deposit. In some cases, this will be swap parameters.
     * @return shares The amount of shares that this deposit yields to the Entity.
     * @return assets The amount of assets that this deposit yields to the portfolio.
     * @return fee The baseToken fee that this deposit yields to the treasury.
     */
    function _deposit(uint256 _amountIn, bytes calldata _data)
        internal
        virtual
        returns (uint256 shares, uint256 assets, uint256 fee);

    /**
     * @notice Exchange `_amountShares` for some amount of baseToken.
     * @param _amountShares The amount of the Entity's portfolio shares to exchange.
     * @param _data Data that the portfolio needs to make the redemption. In some cases, this will be swap parameters.
     * @return baseTokenOut The amount of baseToken that this redemption yields to the Entity.
     */
    function redeem(uint256 _amountShares, bytes calldata _data)
        external
        nonReentrant
        returns (uint256 /* baseTokenOut */ )
    {
        // All redeems should take AUM fees
        takeAumFees();

        // All portfolios should handle redemption after shutdown
        if (didShutdown) return _redeemShutdown(_amountShares);

        // All portfolios should handle the actual redeem of shares
        (uint256 _assetsOut, uint256 _baseTokenOut) = _redeem(_amountShares, _data);

        // All portfolios should burn the redeemed shares from the caller
        _burn(msg.sender, _amountShares);

        // Portfolios must signal amount of assets being redeemed, which must be non-zero
        if (_assetsOut == 0) revert RoundsToZero();

        // Any portfolio that outputs base token should transfer to caller and charge fee for treasury
        uint256 _netAmount;
        uint256 _fee;
        if (_baseTokenOut > 0) {
            (_netAmount, _fee) = _calculateFee(_baseTokenOut, redemptionFee);
            baseToken.safeTransfer(feeTreasury, _fee);
            baseToken.safeTransfer(msg.sender, _netAmount);
        }

        // And emit an event
        emit Redeem(msg.sender, msg.sender, _assetsOut, _amountShares, _netAmount, _fee);

        return _netAmount;
    }

    /**
     * @notice Exchange `_amountShares` for some amount of Portfolio assets.
     * @param _amountShares The amount of portfolio shares to exchange.
     * @param _data Data that the portfolio needs to redeem the assets. In some cases, this will be swap parameters.
     * @return assetsOut The amount of assets that this redemption yielded (and then converted to baseToken).
     * @return baseTokenOut Amount in baseToken to which these assets were converted.
     */
    function _redeem(uint256 _amountShares, bytes calldata _data)
        internal
        virtual
        returns (uint256 assetsOut, uint256 baseTokenOut);

    /**
     * @notice Handles redemption after shutdown, exchanging shares for baseToken.
     * @param _amountShares Shares being redeemed.
     * @return Amount of baseToken received.
     */
    function _redeemShutdown(uint256 _amountShares) internal returns (uint256) {
        uint256 _baseTokenOut = convertToAssetsShutdown(_amountShares);
        _burn(msg.sender, _amountShares);
        (uint256 _netAmount, uint256 _fee) = _calculateFee(_baseTokenOut, redemptionFee);
        baseToken.safeTransfer(feeTreasury, _fee);
        baseToken.safeTransfer(msg.sender, _netAmount);
        emit Redeem(msg.sender, msg.sender, _baseTokenOut, _amountShares, _netAmount, _fee);
        return _netAmount;
    }

    /**
     * @notice Calculates the amount of shares that the Portfolio should exchange for the amount of assets provided.
     * @param _assets Amount of assets.
     * @return Amount of shares.
     */
    function convertToShares(uint256 _assets) public view returns (uint256) {
        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
        return _supply == 0 ? _assets : _assets.mulDivDown(_supply, totalAssets());
    }

    /**
     * @notice Calculates the amount of assets that the Portfolio should exchange for the amount of shares provided.
     * @param _shares Amount of shares.
     * @return Amount of assets.
     */
    function convertToAssets(uint256 _shares) public view returns (uint256) {
        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
        return _supply == 0 ? _shares : _shares.mulDivDown(totalAssets(), _supply);
    }

    /**
     * @notice Calculates the amount of baseToken that the Portfolio should exchange for the amount of shares provided.
     * Used only if the Portfolio has shut down.
     * @dev Rounding down here favors the portfolio, so the user gets slightly less and the portfolio gets slightly more,
     * that way it prevents a situation where the user is owed x but the vault only has x - epsilon, where epsilon is
     * some tiny number due to rounding error.
     * @param _shares Amount of shares.
     * @return Amount of baseToken.
     */
    function convertToAssetsShutdown(uint256 _shares) public view returns (uint256) {
        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.
        return _supply == 0 ? _shares : _shares.mulDivDown(baseToken.balanceOf(address(this)), _supply);
    }

    /**
     * @notice Exit out all assets of portfolio for baseToken. Must persist a mechanism for entities to redeem their shares for baseToken.
     * @param _data Data that the portfolio needs to exit from asset.  Consult the portfolio's `_exit` method to determine
     * the correct format for this data.
     * @return baseTokenOut The amount of baseToken that this exit yielded.
     */
    function shutdown(bytes calldata _data) external requiresAuth returns (uint256 baseTokenOut) {
        if (didShutdown) revert DidShutdown();
        didShutdown = true;
        uint256 _assetsOut = totalAssets();
        // In most cases, _actualAssetsOut will equal _assetsOut, but in SingleTokenPortfolio, it may be less.
        (uint256 _actualAssetsOut, uint256 _baseTokenOut) = _exit(_assetsOut, _data);
        emit Shutdown(_actualAssetsOut, _baseTokenOut);
        return _baseTokenOut;
    }

    /**
     * @notice Convert some amount of asset into baseToken, either partially or fully exiting the portfolio asset.
     * @dev This method is used in `redeem` and `shutdown` calls.
     * @param _amount The amount of the Entity's portfolio asset to exchange.
     * @param _data Data that the portfolio needs to exit from asset. In some cases, this will be swap parameters. Consult the portfolio's
     * `_exit` method to determine the correct format for this data.
     * @return actualAssetsOut The amount of assets that were exited. In most cases, this will be equal to `_amount`, but may differ
     * by some errorMarginPct in SingleTokenPortfolio.
     * @return baseTokenOut The amount of baseToken that this exit yielded.
     */
    function _exit(uint256 _amount, bytes calldata _data)
        internal
        virtual
        returns (uint256 actualAssetsOut, uint256 baseTokenOut);

    /// @notice `transfer` disabled on Portfolio tokens.
    function transfer(
        address, // to
        uint256 // amount
    ) public pure override returns (bool) {
        revert TransferDisallowed();
    }

    /// @notice `transferFrom` disabled on Portfolio tokens.
    function transferFrom(
        address,
        /* from */
        address,
        /* to */
        uint256 /* amount */
    ) public pure override returns (bool) {
        revert TransferDisallowed();
    }

    /// @notice `approve` disabled on Portfolio tokens.
    function approve(
        address,
        /* to */
        uint256 /* amount */
    ) public pure override returns (bool) {
        revert TransferDisallowed();
    }

    /// @notice `permit` disabled on Portfolio tokens.
    function permit(
        address, /* owner */
        address, /* spender */
        uint256, /* value */
        uint256, /* deadline */
        uint8, /* v */
        bytes32, /* r */
        bytes32 /* s */
    ) public pure override {
        revert TransferDisallowed();
    }

    /**
     * @notice Permissioned method that allows Endaoment admin to make arbitrary calls acting as this Portfolio.
     * @param _target The address to which the call will be made.
     * @param _value The ETH value that should be forwarded with the call.
     * @param _data The calldata that will be sent with the call.
     * @return _return The data returned by the call.
     */
    function callAsPortfolio(address _target, uint256 _value, bytes memory _data)
        external
        payable
        requiresAuth
        returns (bytes memory)
    {
        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);
        if (!_success) revert CallFailed(_response);
        return _response;
    }

    /**
     * @notice Internal helper method to calculate the fee on a base token amount for a given fee multiplier.
     * @param _amount Amount of baseToken.
     * @param _feeMultiplier Multiplier (as zoc) to apply to the amount.
     * @return _netAmount The amount of baseToken after the fee is applied.
     * @return _fee The amount of baseToken to be taken as a fee.
     */
    function _calculateFee(uint256 _amount, uint256 _feeMultiplier)
        internal
        pure
        returns (uint256 _netAmount, uint256 _fee)
    {
        if (_feeMultiplier > Math.ZOC) revert PercentageOver100();
        unchecked {
            // unchecked as no possibility of overflow with baseToken precision
            _fee = _amount.zocmul(_feeMultiplier);
            // unchecked as the _feeMultiplier check with revert above protects against overflow
            _netAmount = _amount - _fee;
        }
    }

    /**
     * @notice Helper method to calculate AUM fee based on assets and time elapsed.
     * @param _totalAssets Assets over which to calculate AUM fee.
     * @param _period Seconds elapsed since AUM fee was last taken.
     * @dev We chose to calculate using simple interest rather than compound interest because the error was small and
     * simple interest is easier to calculate, reason about, and test.
     * @return _aumFee The amount of baseToken to be taken as AUM fee.
     */
    function _calculateAumFee(uint256 _totalAssets, uint256 _period) internal view returns (uint256) {
        if (_totalAssets == 0 || aumRate == 0 || _period == 0) return 0;
        // _period * aumRate is safe; max expected aum rate * 10 years of seconds is just over 1 WAD
        return _totalAssets.mulWadDown(_period * aumRate);
    }
}


// File: lib/solmate/src/tokens/ERC20.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
abstract contract ERC20 {
    /*///////////////////////////////////////////////////////////////
                                  EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /*///////////////////////////////////////////////////////////////
                             METADATA STORAGE
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    uint8 public immutable decimals;

    /*///////////////////////////////////////////////////////////////
                              ERC20 STORAGE
    //////////////////////////////////////////////////////////////*/

    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;

    /*///////////////////////////////////////////////////////////////
                             EIP-2612 STORAGE
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

    uint256 internal immutable INITIAL_CHAIN_ID;

    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;

    mapping(address => uint256) public nonces;

    /*///////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;

        INITIAL_CHAIN_ID = block.chainid;
        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    }

    /*///////////////////////////////////////////////////////////////
                              ERC20 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        allowance[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        balanceOf[msg.sender] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(msg.sender, to, amount);

        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.

        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;

        balanceOf[from] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);

        return true;
    }

    /*///////////////////////////////////////////////////////////////
                              EIP-2612 LOGIC
    //////////////////////////////////////////////////////////////*/

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");

        // Unchecked because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            bytes32 digest = keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    DOMAIN_SEPARATOR(),
                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
                )
            );

            address recoveredAddress = ecrecover(digest, v, r, s);

            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }

    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
    }

    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                    keccak256(bytes(name)),
                    keccak256("1"),
                    block.chainid,
                    address(this)
                )
            );
    }

    /*///////////////////////////////////////////////////////////////
                       INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal virtual {
        balanceOf[from] -= amount;

        // Cannot underflow because a user's balance
        // will never be larger than the total supply.
        unchecked {
            totalSupply -= amount;
        }

        emit Transfer(from, address(0), amount);
    }
}


// File: src/lib/Math.sol
// SPDX-License-Identifier: BSD 3-Clause
pragma solidity 0.8.13;

library Math {
    uint256 internal constant ZOC = 1e4;

    /**
     * @dev Multiply 2 numbers where at least one is a zoc, return product in original units of the other number.
     */
    function zocmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x * y;
        unchecked {
            z /= ZOC;
        }
    }

    // Below is WAD math from solmate's FixedPointMathLib.
    // https://github.com/Rari-Capital/solmate/blob/c8278b3cb948cffda3f1de5a401858035f262060/src/utils/FixedPointMathLib.sol

    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.

    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
    }

    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
    }

    // For tokens with 6 decimals like USDC, these scale by 1e6 (one million).
    function mulMilDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, y, 1e6); // Equivalent to (x * y) / 1e6 rounded down.
    }

    function divMilDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, 1e6, y); // Equivalent to (x * 1e6) / y rounded down.
    }

    /*//////////////////////////////////////////////////////////////
                    LOW LEVEL FIXED POINT OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {
        assembly {
            // Store x * y in z for now.
            z := mul(x, y)

            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))
            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) { revert(0, 0) }

            // Divide z by the denominator.
            z := div(z, denominator)
        }
    }
}


// File: lib/solmate/src/utils/SafeTransferLib.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {ERC20} from "../tokens/ERC20.sol";

/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)
/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.
library SafeTransferLib {
    /*///////////////////////////////////////////////////////////////
                            ETH OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function safeTransferETH(address to, uint256 amount) internal {
        bool callStatus;

        assembly {
            // Transfer the ETH and store if it succeeded or not.
            callStatus := call(gas(), to, amount, 0, 0, 0, 0)
        }

        require(callStatus, "ETH_TRANSFER_FAILED");
    }

    /*///////////////////////////////////////////////////////////////
                           ERC20 OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function safeTransferFrom(
        ERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        bool callStatus;

        assembly {
            // Get a pointer to some free memory.
            let freeMemoryPointer := mload(0x40)

            // Write the abi-encoded calldata to memory piece by piece:
            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.
            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the "from" argument.
            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the "to" argument.
            mstore(add(freeMemoryPointer, 68), amount) // Finally append the "amount" argument. No mask as it's a full 32 byte value.

            // Call the token and store if it succeeded or not.
            // We use 100 because the calldata length is 4 + 32 * 3.
            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)
        }

        require(didLastOptionalReturnCallSucceed(callStatus), "TRANSFER_FROM_FAILED");
    }

    function safeTransfer(
        ERC20 token,
        address to,
        uint256 amount
    ) internal {
        bool callStatus;

        assembly {
            // Get a pointer to some free memory.
            let freeMemoryPointer := mload(0x40)

            // Write the abi-encoded calldata to memory piece by piece:
            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.
            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the "to" argument.
            mstore(add(freeMemoryPointer, 36), amount) // Finally append the "amount" argument. No mask as it's a full 32 byte value.

            // Call the token and store if it succeeded or not.
            // We use 68 because the calldata length is 4 + 32 * 2.
            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)
        }

        require(didLastOptionalReturnCallSucceed(callStatus), "TRANSFER_FAILED");
    }

    function safeApprove(
        ERC20 token,
        address to,
        uint256 amount
    ) internal {
        bool callStatus;

        assembly {
            // Get a pointer to some free memory.
            let freeMemoryPointer := mload(0x40)

            // Write the abi-encoded calldata to memory piece by piece:
            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.
            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the "to" argument.
            mstore(add(freeMemoryPointer, 36), amount) // Finally append the "amount" argument. No mask as it's a full 32 byte value.

            // Call the token and store if it succeeded or not.
            // We use 68 because the calldata length is 4 + 32 * 2.
            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)
        }

        require(didLastOptionalReturnCallSucceed(callStatus), "APPROVE_FAILED");
    }

    /*///////////////////////////////////////////////////////////////
                         INTERNAL HELPER LOGIC
    //////////////////////////////////////////////////////////////*/

    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {
        assembly {
            // Get how many bytes the call returned.
            let returnDataSize := returndatasize()

            // If the call reverted:
            if iszero(callStatus) {
                // Copy the revert message into memory.
                returndatacopy(0, 0, returnDataSize)

                // Revert with the same message.
                revert(0, returnDataSize)
            }

            switch returnDataSize
            case 32 {
                // Copy the return data into memory.
                returndatacopy(0, 0, returnDataSize)

                // Set success to whether it returned true.
                success := iszero(iszero(mload(0)))
            }
            case 0 {
                // There was no return data.
                success := 1
            }
            default {
                // It returned some malformed input.
                success := 0
            }
        }
    }
}


// File: src/lib/auth/EndaomentAuth.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {RolesAuthority} from "./authorities/RolesAuthority.sol";

/**
 * @notice An abstract Auth that contracts in the Endaoment ecosystem can inherit from. It is based on
 * the `Auth.sol` contract from Solmate, but does not inherit from it. Most of the functionality
 * is either slightly different, or not needed. In particular:
 * - EndaomentAuth uses an initializer such that it can be deployed with minimal proxies.
 * - EndaomentAuth contracts reference a RolesAuthority, not just an Authority, when looking up permissions.
 *   In the Endaoment ecosystem, this is assumed to be the Registry.
 * - EndaomentAuth contracts do not have an owner, but instead grant ubiquitous permission to its RoleAuthority's
 *   owner. In the Endaoment ecosystem, this is assumed to be the board of directors multi-sig.
 * - EndaomentAuth contracts can optionally declare themselves a "special target" at deploy time. Instead of passing
 *   their address to the authority when looking up their permissions, they'll instead pass the special target bytes.
 *   See documentation on `specialTarget` for more information.
 *
 */
abstract contract EndaomentAuth {
    /// @notice Thrown when an account without proper permissions calls a privileged method.
    error Unauthorized();

    /// @notice Thrown if there is an attempt to deploy with address 0 as the authority.
    error InvalidAuthority();

    /// @notice Thrown if there is a second call to initialize.
    error AlreadyInitialized();

    /// @notice The contract used to source permissions for accounts targeting this contract.
    RolesAuthority public authority;

    /**
     * @notice If set to a non-zero value, this contract will pass these byes as the target contract
     * to the RolesAuthority's `canCall` method, rather than its own contract. This allows a single
     * RolesAuthority permission to manage permissions simultaneously for a group of contracts that
     * identify themselves as a certain type. For example: set a permission for all "entity" contracts.
     */
    bytes20 public specialTarget;

    /**
     * @notice One time method to be called at deployment to configure the contract. Required so EndaomentAuth
     * contracts can be deployed as minimal proxies (clones).
     * @param _authority Contract that will be used to source permissions for accounts targeting this contract.
     * @param _specialTarget The bytes that this contract will pass as the "target" when looking up permissions
     * from the authority. If set to empty bytes, this contract will pass its own address instead.
     */
    function __initEndaomentAuth(RolesAuthority _authority, bytes20 _specialTarget) internal virtual {
        if (address(_authority) == address(0)) revert InvalidAuthority();
        if (address(authority) != address(0)) revert AlreadyInitialized();
        authority = _authority;
        specialTarget = _specialTarget;
    }

    /**
     * @notice Modifier for methods that require authorization to execute.
     */
    modifier requiresAuth() virtual {
        if (!isAuthorized(msg.sender, msg.sig)) revert Unauthorized();
        _;
    }

    /**
     * @notice Internal method that asks the authority whether the caller has permission to execute a method.
     * @param user The account attempting to call a permissioned method on this contract
     * @param functionSig The signature hash of the permissioned method being invoked.
     */
    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
        RolesAuthority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.
        address _target = specialTarget == "" ? address(this) : address(specialTarget);

        // The caller has permission on authority, or the caller is the RolesAuthority owner
        return auth.canCall(user, _target, functionSig) || user == auth.owner();
    }
}


// File: src/lib/auth/Auth.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

// This contract is modified from Solmate only to make requiresAuth virtual on line 26

/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)
/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
abstract contract Auth {
    event OwnerUpdated(address indexed user, address indexed newOwner);

    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);

    address public owner;

    Authority public authority;

    constructor(address _owner, Authority _authority) {
        owner = _owner;
        authority = _authority;

        emit OwnerUpdated(msg.sender, _owner);
        emit AuthorityUpdated(msg.sender, _authority);
    }

    modifier requiresAuth() virtual {
        require(isAuthorized(msg.sender, msg.sig), "UNAUTHORIZED");

        _;
    }

    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.

        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be
        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.
        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;
    }

    function setAuthority(Authority newAuthority) public virtual {
        // We check if the caller is the owner first because we want to ensure they can
        // always swap out the authority even if it's reverting or using up a lot of gas.
        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));

        authority = newAuthority;

        emit AuthorityUpdated(msg.sender, newAuthority);
    }

    function setOwner(address newOwner) public virtual requiresAuth {
        owner = newOwner;

        emit OwnerUpdated(msg.sender, newOwner);
    }
}

/// @notice A generic interface for a contract which provides authorization data to an Auth instance.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)
/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
interface Authority {
    function canCall(address user, address target, bytes4 functionSig) external view returns (bool);
}


// File: src/RegistryAuth.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity 0.8.13;

import {Auth, Authority} from "./lib/auth/Auth.sol";
import {RolesAuthority} from "./lib/auth/authorities/RolesAuthority.sol";

// --- Errors ---
error OwnershipInvalid();

/**
 * @notice RegistryAuth - contract to control ownership of the Registry.
 */
contract RegistryAuth is RolesAuthority {
    /// @notice Emitted when the first step of an ownership transfer (proposal) is done.
    event OwnershipTransferProposed(address indexed user, address indexed newOwner);

    /// @notice Emitted when the second step of an ownership transfer (claim) is done.
    event OwnershipChanged(address indexed owner, address indexed newOwner);

    // --- Storage ---
    /// @notice Pending owner for 2 step ownership transfer
    address public pendingOwner;

    // --- Constructor ---
    constructor(address _owner, Authority _authority) RolesAuthority(_owner, _authority) {}

    /**
     * @notice Starts the 2 step process of transferring registry authorization to a new owner.
     * @param _newOwner Proposed new owner of registry authorization.
     */
    function transferOwnership(address _newOwner) external requiresAuth {
        pendingOwner = _newOwner;

        emit OwnershipTransferProposed(msg.sender, _newOwner);
    }

    /**
     * @notice Completes the 2 step process of transferring registry authorization to a new owner.
     * This function must be called by the proposed new owner.
     */
    function claimOwnership() external {
        if (msg.sender != pendingOwner) revert OwnershipInvalid();
        emit OwnershipChanged(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = address(0);
    }

    /**
     * @notice Old approach of setting a new owner in a single step.
     * @dev This function throws an error to force use of the new 2-step approach.
     */
    function setOwner(address /*newOwner*/ ) public view override requiresAuth {
        revert OwnershipInvalid();
    }
}


// File: src/interfaces/ISwapWrapper.sol
//SPDX-License-Identifier: BSD 3-Clause
pragma solidity >=0.8.0;

error ETHAmountInMismatch();

/**
 * @notice ISwapWrapper is the interface that all swap wrappers should implement.
 * This will be used to support swap protocols like Uniswap V2 and V3, Sushiswap, 1inch, etc.
 */
interface ISwapWrapper {
    /// @notice Event emitted after a successful swap.
    event WrapperSwapExecuted(
        address indexed tokenIn,
        address indexed tokenOut,
        address sender,
        address indexed recipient,
        uint256 amountIn,
        uint256 amountOut
    );

    /// @notice Name of swap wrapper for UX readability.
    function name() external returns (string memory);

    /**
     * @notice Swap function. Generally we expect the implementer to call some exactAmountIn-like swap method, and so the documentation
     * is written with this in mind. However, the method signature is general enough to support exactAmountOut swaps as well.
     * @param _tokenIn Token to be swapped (or 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for ETH).
     * @param _tokenOut Token to receive (or 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for ETH).
     * @param _recipient Receiver of `_tokenOut`.
     * @param _amount Amount of `_tokenIn` that should be swapped.
     * @param _data Additional data that the swap wrapper may require to execute the swap.
     * @return Amount of _tokenOut received.
     */
    function swap(address _tokenIn, address _tokenOut, address _recipient, uint256 _amount, bytes calldata _data)
        external
        payable
        returns (uint256);
}


// File: src/lib/ReentrancyGuard.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Gas optimized reentrancy protection for smart contracts.
/// @author Modified Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
abstract contract ReentrancyGuard {
    uint256 private reentrancyStatus;

    error Reentrancy();

    function __initReentrancyGuard() internal {
        if (reentrancyStatus != 0) revert Reentrancy();
        reentrancyStatus = 1;
    }

    modifier nonReentrant() {
        if (reentrancyStatus != 1) revert Reentrancy();

        reentrancyStatus = 2;

        _;

        reentrancyStatus = 1;
    }
}


// File: lib/solmate/src/utils/ReentrancyGuard.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Gas optimized reentrancy protection for smart contracts.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
abstract contract ReentrancyGuard {
    uint256 private reentrancyStatus = 1;

    modifier nonReentrant() {
        require(reentrancyStatus == 1, "REENTRANCY");

        reentrancyStatus = 2;

        _;

        reentrancyStatus = 1;
    }
}


// File: src/lib/auth/authorities/RolesAuthority.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

// This contract is modified from Solmate only to import modified Auth.sol on line 5
import {Auth, Authority} from "../Auth.sol";

/// @notice Role based Authority that supports up to 256 roles.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)
/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)
contract RolesAuthority is Auth, Authority {
    /*///////////////////////////////////////////////////////////////
                                  EVENTS
    //////////////////////////////////////////////////////////////*/

    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);

    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);

    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);

    /*///////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*///////////////////////////////////////////////////////////////
                            ROLE/USER STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(address => bytes32) public getUserRoles;

    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;

    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;

    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {
        return (uint256(getUserRoles[user]) >> role) & 1 != 0;
    }

    function doesRoleHaveCapability(uint8 role, address target, bytes4 functionSig)
        public
        view
        virtual
        returns (bool)
    {
        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;
    }

    /*///////////////////////////////////////////////////////////////
                          AUTHORIZATION LOGIC
    //////////////////////////////////////////////////////////////*/

    function canCall(address user, address target, bytes4 functionSig) public view virtual override returns (bool) {
        return isCapabilityPublic[target][functionSig]
            || bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];
    }

    /*///////////////////////////////////////////////////////////////
                  ROLE CAPABILITY CONFIGURATION LOGIC
    //////////////////////////////////////////////////////////////*/

    function setPublicCapability(address target, bytes4 functionSig, bool enabled) public virtual requiresAuth {
        isCapabilityPublic[target][functionSig] = enabled;

        emit PublicCapabilityUpdated(target, functionSig, enabled);
    }

    function setRoleCapability(uint8 role, address target, bytes4 functionSig, bool enabled)
        public
        virtual
        requiresAuth
    {
        if (enabled) {
            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);
        } else {
            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);
        }

        emit RoleCapabilityUpdated(role, target, functionSig, enabled);
    }

    /*///////////////////////////////////////////////////////////////
                      USER ROLE ASSIGNMENT LOGIC
    //////////////////////////////////////////////////////////////*/

    function setUserRole(address user, uint8 role, bool enabled) public virtual requiresAuth {
        if (enabled) {
            getUserRoles[user] |= bytes32(1 << role);
        } else {
            getUserRoles[user] &= ~bytes32(1 << role);
        }

        emit UserRoleUpdated(user, role, enabled);
    }
}

