
// File: @openzeppelin/contracts/access/AccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)

pragma solidity ^0.8.20;

import {IAccessControl} from "./IAccessControl.sol";
import {Context} from "../utils/Context.sol";
import {ERC165} from "../utils/introspection/ERC165.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```solidity
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```solidity
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
 * to enforce additional security measures for this role.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address account => bool) hasRole;
        bytes32 adminRole;
    }

    mapping(bytes32 role => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with an {AccessControlUnauthorizedAccount} error including the required role.
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view virtual returns (bool) {
        return _roles[role].hasRole[account];
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
     * is missing `role`.
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert AccessControlUnauthorizedAccount(account, role);
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address callerConfirmation) public virtual {
        if (callerConfirmation != _msgSender()) {
            revert AccessControlBadConfirmation();
        }

        _revokeRole(role, callerConfirmation);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
        if (!hasRole(role, account)) {
            _roles[role].hasRole[account] = true;
            emit RoleGranted(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
        if (hasRole(role, account)) {
            _roles[role].hasRole[account] = false;
            emit RoleRevoked(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }
}


// File: @openzeppelin/contracts/access/IAccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)

pragma solidity ^0.8.20;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev The `account` is missing a role.
     */
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);

    /**
     * @dev The caller of a function is not the expected one.
     *
     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
     */
    error AccessControlBadConfirmation();

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     */
    function renounceRole(bytes32 role, address callerConfirmation) external;
}


// File: @openzeppelin/contracts/proxy/Clones.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)

pragma solidity ^0.8.20;

/**
 * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
 * deploying minimal proxy contracts, also known as "clones".
 *
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 *
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 * deterministic method.
 */
library Clones {
    /**
     * @dev A clone instance deployment failed.
     */
    error ERC1167FailedCreateClone();

    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create opcode, which should never revert.
     */
    function clone(address implementation) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create(0, 0x09, 0x37)
        }
        if (instance == address(0)) {
            revert ERC1167FailedCreateClone();
        }
    }

    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create2 opcode and a `salt` to deterministically deploy
     * the clone. Using the same `implementation` and `salt` multiple time will revert, since
     * the clones cannot be deployed twice at the same address.
     */
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create2(0, 0x09, 0x37, salt)
        }
        if (instance == address(0)) {
            revert ERC1167FailedCreateClone();
        }
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt,
        address deployer
    ) internal pure returns (address predicted) {
        /// @solidity memory-safe-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(add(ptr, 0x38), deployer)
            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
            mstore(add(ptr, 0x14), implementation)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
            mstore(add(ptr, 0x58), salt)
            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
            predicted := keccak256(add(ptr, 0x43), 0x55)
        }
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt
    ) internal view returns (address predicted) {
        return predictDeterministicAddress(implementation, salt, address(this));
    }
}


// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.20;

import {IERC20} from "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the value of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the value of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves a `value` amount of tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 value) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
     * caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 value) external returns (bool);

    /**
     * @dev Moves a `value` amount of tokens from `from` to `to` using the
     * allowance mechanism. `value` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

pragma solidity ^0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    function _contextSuffixLength() internal view virtual returns (uint256) {
        return 0;
    }
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)

pragma solidity ^0.8.20;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: contracts/interfaces/IBurnWallet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.25;

interface IBurnWallet {
    function processTokens(
        address stable,
        address coldWallet,
        uint256 amount,
        uint256 fee
    ) external;

    function retrieveTokens(address stable, address to, uint256 amount) external;

    function initialize() external;

    function walletFactory() external view returns (address);
}


// File: contracts/interfaces/IDepositWallet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.25;

interface IDepositWallet {
    function processTokens(
        address stable,
        address coldWallet,
        uint256 amount,
        uint256 fee
    ) external;

    function initialize(address userAddress) external;

    function userAddress() external view returns (address);

    function walletFactory() external view returns (address);
}


// File: contracts/interfaces/IWalletFactory.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.25;

interface IWalletFactory {
    enum UserStatus {
        INACTIVE,
        PENDING,
        ACTIVE,
        REJECTED,
        BLOCKED
    }

    struct UserWallet {
        UserStatus status;
        bool partner;
        bool burner;
        bool minter;
        address depositAddress;
        bool business;
        uint256 minted;
        uint256 mintLimit;
        uint256 burned;
        uint256 burnLimit;
    }

    function processMintRequest(
        address user,
        address stable,
        uint256 amount
    ) external returns (UserWallet memory);

    function rejectMintRequest(address user, address stable, uint256 amount) external;

    function processBurnRequest(address user, uint256 amount) external returns (UserWallet memory);

    function register(bool partner, bool burner, bool minter, bool business) external;

    function acceptUser(address userAddress) external;

    function rejectUser(address userAddress) external;

    function createDepositWallet(address userAddress) external;

    function setUserCaps(address user, uint256 mintLimit, uint256 burnLimit) external;

    function setGlobalAccess(bool value) external;

    function setDepositWalletStatus(address[] calldata addresses, bool[] calldata values) external;

    function setUserStatus(address[] calldata addresses, UserStatus[] calldata values) external;

    function setColdWallets(address[] calldata addresses, bool[] calldata values) external;

    function setMultisigAddress(address multisigAddress) external;

    function setDepositWalletImplementation(address implementation) external;

    function setBurnWalletImplementation(address implementation) external;

    function setDepositAddress(address userAddress, address depositAddress) external;

    function setTokens(
        address[] calldata addresses,
        bool[] calldata values,
        uint256[] calldata cryptoHardcaps
    ) external;

    function setFeeAddress(address feeAddress) external;

    function setFee(uint256 mintFee, uint256 burnFee, uint256 transferFee) external;

    function setSoftCaps(
        uint256 minMintSoftcap,
        uint256 maxMintSoftcap,
        uint256 minBurnSoftcap,
        uint256 maxBurnSoftcap
    ) external;

    function setGlobalUserCaps(
        uint256 businessMinterCap,
        uint256 personalMinterCap,
        uint256 businessBurnerCap,
        uint256 personalBurnerCap
    ) external;

    function setCryptoHardcap(address stable, uint256 cryptoHardcap) external;

    function setFiatHardcap(uint256 fiatHardcap) external;

    function setThresholds(uint256 adminThreshold, uint256 multisigThreshold) external;

    function setDAO(address daoAddress) external;

    function setMinters(address[] calldata addresses, bool[] calldata values) external;

    function setSTBLAddress(address stblAddress) external;

    function setBurnWallet() external;

    function transferFee() external view returns (uint256);

    function mintFee() external view returns (uint256);

    function burnFee() external view returns (uint256);

    function globalAccess() external view returns (bool);

    function feeAddress() external view returns (address);

    function multisigAddress() external view returns (address);

    function daoAddress() external view returns (address);

    function userWallets(address user) external view returns (UserWallet memory);

    function depositWallets(address user) external view returns (bool);

    function stblAddress() external view returns (address);

    function minterAddresses(address) external view returns (bool);

    function allowedTokens(address token) external view returns (bool);

    function coldWallets(address wallet) external view returns (bool);

    function adminThreshold() external view returns (uint256);

    function multisigThreshold() external view returns (uint256);

    function getThresholds() external view returns (uint256, uint256);

    function fiatHardcap() external view returns (uint256);

    function fiatDeposited() external view returns (uint256);

    function cryptoDeposited(address stable) external view returns (uint256);

    function cryptoHardcap(address stable) external view returns (uint256);

    function minMintSoftcap() external view returns (uint256);

    function maxMintSoftcap() external view returns (uint256);

    function maxBurnSoftcap() external view returns (uint256);

    function minBurnSoftcap() external view returns (uint256);

    function personalMinterCap() external view returns (uint256);

    function businessMinterCap() external view returns (uint256);

    function personalBurnerCap() external view returns (uint256);

    function businessBurnerCap() external view returns (uint256);

    function depositWalletImplementation() external view returns (address);

    function burnWalletImplementation() external view returns (address);

    function burnWallet() external view returns (address);

    function getLimits()
        external
        view
        returns (uint256, uint256, uint256, uint256, uint256, uint256);

    // function getUserAmountsAvailable(
    //     address user,
    //     address stable,
    //     bool fiat
    // ) external view returns (uint256 mintAvailable, uint256 burningAvailable);
}


// File: contracts/utils/Errors.sol
pragma solidity =0.8.25;

error UserInactive(); // 0x3310e691
error InvalidToken(); // 0xc1ab6dc1
error ZeroAddress(); // 0xd92e233d
error DepositAddressBlocked(); // 0x24c07dff
error RoleControl(); // 0x38a097a3
error NotRejected(); // 0x954443dc
error NotMintable(); // 0x12a59152
error NotBurnable(); // 0xda38f010
error InvalidInput(); // 0xb4fa3fb3
error InternalError(); // 0xfe835e35
error CapReached(); // 0xd7e991d2
error AlreadyProcessed(); // 0x57eee766


// File: contracts/WalletFactory.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.25;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";
import "./interfaces/IWalletFactory.sol";
import "./interfaces/IDepositWallet.sol";
import "./interfaces/IBurnWallet.sol";
import "./utils/Errors.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

// import "hardhat/console.sol";

contract WalletFactory is IWalletFactory, AccessControl {
    bytes32 public constant SUPERADMIN_ROLE = keccak256("SUPERADMIN_ROLE");
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant BACKEND_ROLE = keccak256("BACKEND_ROLE");

    uint256 public constant HUNDRED_PERCENT = 10000;

    mapping(address => UserWallet) private _userWallets;
    mapping(address => bool) private _depositWallets;
    mapping(address => bool) private _coldWallets;
    mapping(address => bool) private _allowedTokens;
    mapping(address => bool) private _minterAddresses;

    // caps

    uint256 private _fiatHardcap = 100_000 * 10 ** 18;
    uint256 private _fiatDeposited;
    mapping(address => uint256) private _cryptoHardcap;
    mapping(address => uint256) private _cryptoDeposited;
    uint256 private _minMintSoftcap = 5 * 10 ** 18;
    uint256 private _maxMintSoftcap = 10_000 * 10 ** 18;
    uint256 private _minBurnSoftcap = 5 * 10 ** 18;
    uint256 private _maxBurnSoftcap = 10_000 * 10 ** 18;
    uint256 private _personalMinterCap = 25_000 * 10 ** 18;
    uint256 private _personalBurnerCap = 25_000 * 10 ** 18;
    uint256 private _businessMinterCap = 100_000 * 10 ** 18;
    uint256 private _businessBurnerCap = 100_000 * 10 ** 18;

    // pre-release
    bool private _globalAccess;

    // fees
    uint256 private _mintFee = 100;
    uint256 private _burnFee = 100;
    uint256 private _transferFee = 10;

    // minting and burning thresholds
    uint256 private _adminThreshold = 500 * 10 ** 18;
    uint256 private _multisigThreshold = 1000 * 10 ** 18;

    // addresses
    // address private _minterAddress;
    address private _depositWalletImplementation;
    address private _burnWalletImplementation;
    address private _feeAddress;
    address private _multisigAddress;
    address private _stblAddress;
    address private _daoAddress;
    address private _burnWallet;

    ///@dev emitted when registration is requested
    event RegistrationRequested(
        address user,
        bool partner,
        bool burner,
        bool minter,
        bool business
    );
    ///@dev emitted when registration is accepted
    event UserAccepted(address user);
    ///@dev emitted when registration is rejected
    event UserRejected(address user);
    ///@dev emitted when deposit wallet is created
    event DepositWalletCreated(address user, address wallet);
    ///@dev emitted when minter is set
    event MinterSet(address user, bool minter);
    ///@dev emitted when STBL address is set
    event STBLAddressSet(address stblAddress);
    ///@dev emitted when fee is set
    event FeeSet(uint256 mintFee, uint256 burnFee, uint256 transferFee);
    ///@dev emitted when fee address is set
    event FeeAddressSet(address feeAddress);
    ///@dev emitted when user limits are set
    event UserCapsSet(address user, uint256 mintLimit, uint256 burnLimit);
    ///@dev emitted when global access is set
    event GlobalAccessSet(bool value);
    ///@dev emitted when deposit wallet status is set
    event DepositWalletStatusSet(address wallet, bool status);
    ///@dev emitted when user status is set
    event UserStatusSet(address wallet, UserStatus status);
    ///@dev emitted when cold wallet is set
    event ColdWalletSet(address wallet, bool status);
    ///@dev emitted when multisig address is set
    event MultisigAddressSet(address multisigAddress);
    ///@dev emitted when deposit wallet implementation is set
    event DepositWalletImplementationSet(address implementation);
    ///@dev emitted when burn wallet implementation is set
    event BurnWalletImplementationSet(address implementation);
    ///@dev emitted when new burn wallet is deployed
    event BurnWalletCreated(address burnWallet);
    ///@dev emitted when deposit address is set for user
    event DepositAddressSet(address userAddress, address depositAddress);
    ///@dev emitted when token is set with hardcap
    event TokenSet(address token, bool status, uint256 hardcap);
    ///@dev emitted when thresholds are set
    event ThresholdSet(uint256 adminThreshold, uint256 multisigThreshold);
    ///@dev emitted when dao address is set
    event DAOAddressSet(address daoAddress);
    ///@dev emitted when fiat hardcap is set
    event FiatHardcapSet(uint256 fiatHardcap);
    ///@dev emitted when crypto hardcap is set
    event CryptoHardcapSet(address token, uint256 cryptoHardcap);
    ///@dev emitted when global user minting and burning caps are set
    event GlobalUserCapsSet(
        uint256 businessMinterCap,
        uint256 personalMinterCap,
        uint256 businessBurnerCap,
        uint256 personalBurnerCap
    );
    ///@dev emitted when softcaps are set
    event SoftCapsSet(
        uint256 minMintSoftcap,
        uint256 maxMintSoftcap,
        uint256 minBurnSoftcap,
        uint256 maxBurnSoftcap
    );

    ///@param feeAddress address of the fee wallet
    ///@param multisigAddress address of the multisig
    constructor(address feeAddress, address multisigAddress) {
        _grantRole(DEFAULT_ADMIN_ROLE, multisigAddress);
        _grantRole(SUPERADMIN_ROLE, multisigAddress);
        _grantRole(ADMIN_ROLE, multisigAddress);
        _grantRole(BACKEND_ROLE, multisigAddress);
        _setRoleAdmin(BACKEND_ROLE, SUPERADMIN_ROLE);
        _setRoleAdmin(ADMIN_ROLE, SUPERADMIN_ROLE);
        _feeAddress = feeAddress;
        _multisigAddress = multisigAddress;
    }

    ///@dev creates a registration request for a user
    ///@param partner allows user to transfer tokens during initial phase
    ///@param burner allows user to burn tokens
    ///@param minter allows user to mint tokens
    ///@param business sets user as a business account
    function register(bool partner, bool burner, bool minter, bool business) external override {
        if (!partner || (minter && !burner)) revert RoleControl();

        UserStatus currentStatus = _userWallets[msg.sender].status;
        if (currentStatus != UserStatus.INACTIVE && currentStatus != UserStatus.REJECTED)
            revert RoleControl();

        _userWallets[msg.sender] = UserWallet({
            status: UserStatus.PENDING,
            partner: partner,
            burner: burner,
            minter: minter,
            depositAddress: address(0),
            business: business,
            minted: 0,
            mintLimit: 0,
            burned: 0,
            burnLimit: 0
        });

        emit RegistrationRequested(msg.sender, partner, burner, minter, business);
    }

    ///@dev accepts registration request
    ///@param userAddress address of the user
    function acceptUser(address userAddress) external override onlyRole(ADMIN_ROLE) {
        if (_userWallets[userAddress].status != UserStatus.PENDING) revert RoleControl();
        _userWallets[userAddress].status = UserStatus.ACTIVE;

        bool isBusiness = _userWallets[userAddress].business;
        if (_userWallets[userAddress].minter) {
            createDepositWallet(userAddress);
            _userWallets[userAddress].mintLimit = isBusiness
                ? _businessMinterCap
                : _personalMinterCap;
        }

        if (_userWallets[userAddress].burner) {
            _userWallets[userAddress].burnLimit = isBusiness
                ? _businessBurnerCap
                : _personalBurnerCap;
        }
        emit UserAccepted(userAddress);
    }

    ///@dev rejects registration request
    ///@param userAddress address of the user
    function rejectUser(address userAddress) external override onlyRole(ADMIN_ROLE) {
        if (_userWallets[userAddress].status != UserStatus.PENDING) revert RoleControl();
        delete _userWallets[userAddress];
        _userWallets[userAddress].status = UserStatus.REJECTED;
        emit UserRejected(userAddress);
    }

    // function checkMintLimits(address user, address stable, uint256 amount, bool fiat) external {}

    ///@dev can be called only my minter contract, check all limits and returns user profile
    ///@param user address of the user
    ///@param stable address of the stable token
    ///@param amount amount of tokens
    function processMintRequest(
        address user,
        address stable,
        uint256 amount
    ) external override returns (UserWallet memory) {
        if (_minterAddresses[msg.sender] == false) {
            revert InternalError();
        }

        // calculate STBL amount
        uint256 fee = (amount * _mintFee) / HUNDRED_PERCENT; // in USDT
        uint256 stblAmount = ((amount - fee) * 10 ** IERC20Metadata(_stblAddress).decimals()) /
            10 ** IERC20Metadata(stable).decimals();

        // check fiat or crypto limits

        _cryptoDeposited[stable] += amount;
        if (_cryptoDeposited[stable] > _cryptoHardcap[stable]) {
            revert CapReached();
        }
        // //check softcaps
        if (stblAmount < _minMintSoftcap || stblAmount > _maxMintSoftcap) {
            revert CapReached();
        }

        // check personal caps
        UserWallet memory userWallet = _userWallets[user];
        // update user wallet
        _userWallets[user].minted += stblAmount;

        if (_userWallets[user].minted > _userWallets[user].mintLimit) {
            revert CapReached();
        }

        return userWallet;
    }

    ///@dev can be called only my minter contract, rejects mint request
    ///@param user address of the user
    ///@param stable address of the stable token
    ///@param amount amount of tokens
    function rejectMintRequest(address user, address stable, uint256 amount) external override {
        if (_minterAddresses[msg.sender] == false) {
            revert InternalError();
        }

        uint256 fee = (amount * _mintFee) / HUNDRED_PERCENT; // in USDT
        uint256 stblAmount = ((amount - fee) * 10 ** IERC20Metadata(_stblAddress).decimals()) /
            10 ** IERC20Metadata(stable).decimals();

        _cryptoDeposited[stable] -= amount;

        _userWallets[user].minted -= stblAmount;
    }

    ///@dev can be called only my minter contract, checks limits and returns user profile
    ///@param user address of the user
    ///@param amount amount of tokens
    function processBurnRequest(
        address user,
        uint256 amount
    ) external override returns (UserWallet memory) {
        if (_minterAddresses[msg.sender] == false) {
            revert InternalError();
        }
        //check softcaps
        if (amount < _minBurnSoftcap || amount > _maxBurnSoftcap) {
            revert CapReached();
        }

        // check personal caps
        UserWallet memory userWallet = _userWallets[user];
        // update user wallet
        _userWallets[user].burned += amount;

        if (_userWallets[user].burned > userWallet.burnLimit) {
            revert CapReached();
        }

        return userWallet;
    }

    //===============================================SETTERS===============================================
    ///@dev can only be called by multisig, sets minter addresses
    ///@param addresses array of addresses
    ///@param values array of values
    function setMinters(address[] calldata addresses, bool[] calldata values) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        for (uint256 i = 0; i < addresses.length; i++) {
            _minterAddresses[addresses[i]] = values[i];
            emit MinterSet(addresses[i], values[i]);
        }
    }

    function setFiatHardcap(uint256 fiatHardcap) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        _fiatHardcap = fiatHardcap;
        emit FiatHardcapSet(fiatHardcap);
    }

    function setCryptoHardcap(address stable, uint256 cryptoHardcap) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        _cryptoHardcap[stable] = cryptoHardcap;
        emit CryptoHardcapSet(stable, cryptoHardcap);
    }

    function setGlobalUserCaps(
        uint256 businessMinterCap,
        uint256 personalMinterCap,
        uint256 businessBurnerCap,
        uint256 personalBurnerCap
    ) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        _businessMinterCap = businessMinterCap;
        _personalMinterCap = personalMinterCap;
        _businessBurnerCap = businessBurnerCap;
        _personalBurnerCap = personalBurnerCap;
        emit GlobalUserCapsSet(
            businessMinterCap,
            personalMinterCap,
            businessBurnerCap,
            personalBurnerCap
        );
    }

    function setSoftCaps(
        uint256 minMintSoftcap,
        uint256 maxMintSoftcap,
        uint256 minBurnSoftcap,
        uint256 maxBurnSoftcap
    ) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        _minMintSoftcap = minMintSoftcap;
        _maxMintSoftcap = maxMintSoftcap;
        _minBurnSoftcap = minBurnSoftcap;
        _maxBurnSoftcap = maxBurnSoftcap;
        emit SoftCapsSet(minMintSoftcap, maxMintSoftcap, minBurnSoftcap, maxBurnSoftcap);
    }

    function setSTBLAddress(address stblAddress) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        _stblAddress = stblAddress;
        emit STBLAddressSet(stblAddress);
    }

    ///@dev can only be called by admin, sets mint and burn limits
    ///@param user address of the user
    ///@param mintLimit mint limit
    ///@param burnLimit burn limit
    function setUserCaps(
        address user,
        uint256 mintLimit,
        uint256 burnLimit
    ) external override onlyRole(ADMIN_ROLE) {
        _userWallets[user].mintLimit = mintLimit;
        _userWallets[user].burnLimit = burnLimit;
        emit UserCapsSet(user, mintLimit, burnLimit);
    }

    ///@dev can only be called by multisig, if false removes restriction to whitelist only
    ///@param value true if whitelist only
    function setGlobalAccess(bool value) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        _globalAccess = value;
        emit GlobalAccessSet(value);
    }

    ///@dev can only be called by multisig, allows to block or unblock deposit wallets
    ///@param addresses array of addresses
    ///@param values array of values
    function setDepositWalletStatus(
        address[] calldata addresses,
        bool[] calldata values
    ) external override {
        if (!hasRole(ADMIN_ROLE, msg.sender) && !hasRole(BACKEND_ROLE, msg.sender))
            revert RoleControl();
        for (uint256 i = 0; i < addresses.length; i++) {
            _depositWallets[addresses[i]] = values[i];
            emit DepositWalletStatusSet(addresses[i], values[i]);
        }
    }

    ///@dev can only be called by multisig, sets user status, can be used to block and unblock users
    ///@param addresses array of addresses
    ///@param values array of values
    function setUserStatus(
        address[] calldata addresses,
        UserStatus[] calldata values
    ) external override {
        if (!hasRole(ADMIN_ROLE, msg.sender)) revert RoleControl();
        for (uint256 i = 0; i < addresses.length; i++) {
            UserWallet memory userWallet = _userWallets[addresses[i]];
            if (userWallet.status == UserStatus.PENDING) {
                revert InvalidInput();
            }

            if (userWallet.status != UserStatus.BLOCKED && values[i] != UserStatus.BLOCKED) {
                revert InvalidInput();
            }

            if (userWallet.status == UserStatus.BLOCKED) {
                if (userWallet.partner && values[i] != UserStatus.ACTIVE) revert InvalidInput();
                if (!userWallet.partner && values[i] != UserStatus.INACTIVE) revert InvalidInput();
            }
            _userWallets[addresses[i]].status = values[i];
            emit UserStatusSet(addresses[i], values[i]);
        }
    }

    ///@dev can only be called by multisig, allows to add or remove allowed cold wallets
    ///@param addresses array of addresses
    ///@param values array of values
    function setColdWallets(
        address[] calldata addresses,
        bool[] calldata values
    ) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        for (uint256 i = 0; i < addresses.length; i++) {
            _coldWallets[addresses[i]] = values[i];
            emit ColdWalletSet(addresses[i], values[i]);
        }
    }

    ///@dev can only be called by multisig, sets new multisig address
    ///@param multisigAddress new multisig address
    function setMultisigAddress(address multisigAddress) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        _revokeRole(DEFAULT_ADMIN_ROLE, _multisigAddress);
        _revokeRole(BACKEND_ROLE, _multisigAddress);
        _revokeRole(SUPERADMIN_ROLE, _multisigAddress);
        _revokeRole(ADMIN_ROLE, _multisigAddress);

        _grantRole(DEFAULT_ADMIN_ROLE, multisigAddress);
        _grantRole(BACKEND_ROLE, multisigAddress);
        _grantRole(SUPERADMIN_ROLE, multisigAddress);
        _grantRole(ADMIN_ROLE, multisigAddress);

        _multisigAddress = multisigAddress;
        emit MultisigAddressSet(multisigAddress);
    }

    ///@dev can only be called by multisig, sets new implementation address for deposit wallets
    ///@param implementation new implementation address
    function setDepositWalletImplementation(address implementation) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        _depositWalletImplementation = implementation;
        emit DepositWalletImplementationSet(implementation);
    }

    ///@dev can only be called by multisig, sets new implementation address for burn wallet
    ///@param implementation new implementation address
    function setBurnWalletImplementation(address implementation) external override {
        if (msg.sender != _multisigAddress) revert RoleControl();
        _burnWalletImplementation = implementation;
        emit BurnWalletImplementationSet(implementation);
    }

    ///@dev can only be called by multisig, deploys clone of burn wallet
    function setBurnWallet() external override {
        if (!hasRole(SUPERADMIN_ROLE, msg.sender)) revert RoleControl();
        address burnWallet = Clones.clone(_burnWalletImplementation);

        IBurnWallet(burnWallet).initialize();
        _burnWallet = burnWallet;

        emit BurnWalletCreated(burnWallet);
    }

    ///@dev can only be called by multisig, sets deposit address for user
    ///@param userAddress user address
    ///@param depositAddress new deposit address
    function setDepositAddress(address userAddress, address depositAddress) external override {
        if (!hasRole(ADMIN_ROLE, msg.sender)) revert RoleControl();
        if (depositAddress == address(0)) revert InvalidInput();
        _userWallets[userAddress].depositAddress = depositAddress;
        emit DepositAddressSet(userAddress, depositAddress);
    }

    /// @dev can only be called by multisig, sets allowed stablecoins
    /// @param addresses array of addresses
    /// @param values array of values
    /// @param cryptoHardcaps array of crypto hardcaps
    function setTokens(
        address[] calldata addresses,
        bool[] calldata values,
        uint256[] calldata cryptoHardcaps
    ) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        for (uint256 i = 0; i < addresses.length; i++) {
            _allowedTokens[addresses[i]] = values[i];
            _cryptoHardcap[addresses[i]] = cryptoHardcaps[i];
            emit TokenSet(addresses[i], values[i], cryptoHardcaps[i]);
        }
    }

    function setFeeAddress(address feeAddress) external override {
        if ((msg.sender != _multisigAddress)) revert RoleControl();
        _feeAddress = feeAddress;
        emit FeeAddressSet(feeAddress);
    }

    /// @dev can only be called by multisig or dao address, sets new fee values
    /// @param mintFee mint fee, 100% = 10000
    /// @param burnFee burn fee, 100% = 10000
    /// @param transferFee transfer fee, 100% = 10000
    function setFee(uint256 mintFee, uint256 burnFee, uint256 transferFee) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        if (
            mintFee >= HUNDRED_PERCENT ||
            burnFee >= HUNDRED_PERCENT ||
            transferFee >= HUNDRED_PERCENT
        ) revert InvalidInput();
        _mintFee = mintFee;
        _burnFee = burnFee;
        _transferFee = transferFee;

        emit FeeSet(mintFee, burnFee, transferFee);
    }

    /// @dev can only be called by multisig or dao address, sets new threshold values
    /// @param adminThreshold admin threshold in STBL after fee
    /// @param multisigThreshold multisig threshold in STBL after fee
    function setThresholds(uint256 adminThreshold, uint256 multisigThreshold) external override {
        if ((msg.sender != _multisigAddress && msg.sender != _daoAddress)) revert RoleControl();
        _adminThreshold = adminThreshold;
        _multisigThreshold = multisigThreshold;
        emit ThresholdSet(_adminThreshold, _multisigThreshold);
    }

    /// @dev can only be called by multisig or dao address, sets new dao address
    /// @param daoAddress new dao address
    function setDAO(address daoAddress) external override {
        if (_daoAddress == address(0)) {
            if (msg.sender != _multisigAddress) revert RoleControl();
        } else {
            if (msg.sender != _daoAddress) revert RoleControl();
        }

        _daoAddress = daoAddress;

        emit DAOAddressSet(_daoAddress);
    }

    //=============================================== VIEWS ===============================================
    ///@dev returns trasfer fee
    function transferFee() external view override returns (uint256) {
        return _transferFee;
    }

    ///@dev returns mint fee
    function mintFee() external view override returns (uint256) {
        return _mintFee;
    }

    ///@dev returns burn fee
    function burnFee() external view override returns (uint256) {
        return _burnFee;
    }

    ///@dev returns fee address
    function feeAddress() external view override returns (address) {
        return _feeAddress;
    }

    ///@dev returns multisig address
    function multisigAddress() external view override returns (address) {
        return _multisigAddress;
    }

    ///@dev returns dao address
    function daoAddress() external view override returns (address) {
        return _daoAddress;
    }

    ///@dev returns whether the whitelist is turned off
    function globalAccess() external view override returns (bool) {
        return _globalAccess;
    }

    ///@dev returns user wallet
    ///@param user user address
    ///@return user wallet structure
    function userWallets(address user) external view override returns (UserWallet memory) {
        return _userWallets[user];
    }

    ///@dev returns deposit wallet
    ///@param wallet wallet address
    ///@return bool blocked status
    function depositWallets(address wallet) external view override returns (bool) {
        return _depositWallets[wallet];
    }

    ///@dev returns whether cold wallet if added
    ///@param wallet wallet address
    function coldWallets(address wallet) external view override returns (bool) {
        return _coldWallets[wallet];
    }

    ///@dev returns whether token is allowed
    ///@param token token address
    function allowedTokens(address token) external view override returns (bool) {
        return _allowedTokens[token];
    }

    ///@dev returns stbl address
    function stblAddress() external view override returns (address) {
        return _stblAddress;
    }

    ///@dev returns whether minted address is added
    function minterAddresses(address _minterAddress) external view override returns (bool) {
        return _minterAddresses[_minterAddress];
    }

    ///@dev returns admin threshold in STBL
    function adminThreshold() external view override returns (uint256) {
        return _adminThreshold;
    }

    ///@dev returns multisig threshold in STBL
    function multisigThreshold() external view override returns (uint256) {
        return _multisigThreshold;
    }

    ///@dev returns admin threshold and multisig threshold
    function getThresholds() external view override returns (uint256, uint256) {
        return (_adminThreshold, _multisigThreshold);
    }

    ///@dev returns fiat hardcap
    function fiatHardcap() external view override returns (uint256) {
        return _fiatHardcap;
    }

    ///@dev returns fiat deposited
    function fiatDeposited() external view override returns (uint256) {
        return _fiatDeposited;
    }

    ///@dev returns crypto deposited
    function cryptoDeposited(address stable) external view override returns (uint256) {
        return _cryptoDeposited[stable];
    }

    ///@dev returns crypto hardcap
    function cryptoHardcap(address stable) external view override returns (uint256) {
        return _cryptoHardcap[stable];
    }

    ///@dev returns mininal mint amount per tx
    function minMintSoftcap() external view override returns (uint256) {
        return _minMintSoftcap;
    }

    ///@dev returns max mint amount per tx
    function maxMintSoftcap() external view override returns (uint256) {
        return _maxMintSoftcap;
    }

    ///@dev returns max burn amount per tx
    function maxBurnSoftcap() external view override returns (uint256) {
        return _maxBurnSoftcap;
    }

    ///@dev returns min burn amount per tx
    function minBurnSoftcap() external view override returns (uint256) {
        return _minBurnSoftcap;
    }

    ///@dev returns default minter cap for personal accounts
    function personalMinterCap() external view override returns (uint256) {
        return _personalMinterCap;
    }

    ///@dev returns default minter cap for business accounts
    function businessMinterCap() external view override returns (uint256) {
        return _businessMinterCap;
    }

    ///@dev returns default burner cap for personal accounts
    function personalBurnerCap() external view override returns (uint256) {
        return _personalBurnerCap;
    }

    ///@dev returns default burner cap for business accounts
    function businessBurnerCap() external view override returns (uint256) {
        return _businessBurnerCap;
    }

    ///@dev returns deposit wallet implementation address
    function depositWalletImplementation() external view override returns (address) {
        return _depositWalletImplementation;
    }

    ///@dev returns burn wallet implementation address
    function burnWalletImplementation() external view override returns (address) {
        return _burnWalletImplementation;
    }

    ///@dev returns current burn wallet address
    function burnWallet() external view override returns (address) {
        return _burnWallet;
    }

    /// @dev returns all the limits
    /// @return minMintSoftcap
    /// @return maxMintSoftcap
    /// @return maxBurnSoftcap
    /// @return minBurnSoftcap
    /// @return adminThreshold
    /// @return multisigThreshold
    function getLimits()
        external
        view
        override
        returns (uint256, uint256, uint256, uint256, uint256, uint256)
    {
        return (
            _minMintSoftcap,
            _maxMintSoftcap,
            _minBurnSoftcap,
            _maxBurnSoftcap,
            _adminThreshold,
            _multisigThreshold
        );
    }

    ///@dev creates a new deposit wallet for a user and overrides the old one
    ///@param userAddress address of the user
    function createDepositWallet(address userAddress) public override onlyRole(ADMIN_ROLE) {
        address depositWallet = Clones.clone(_depositWalletImplementation);
        IDepositWallet(depositWallet).initialize(userAddress);
        _userWallets[userAddress].depositAddress = depositWallet;
        _depositWallets[depositWallet] = true;

        emit DepositWalletCreated(userAddress, depositWallet);
    }
}

