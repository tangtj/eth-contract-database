//SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
/*This is an ERC-2535 Diamond proxy contract. For more information, please refer to ERC-2535: https:eips.ethereum.orgEIPSeip-2535 Ethereum Improvement Proposals AllCoreNetworkingInterfaceERCMetaInformational Standards Track: ERC ERC-2535: Diamonds, Multi-Facet Proxy Create modular smart contract systems that can be extended after deployment. Authors Nick Mudge (@mudgen) Created 2020-02-22 Table of Contents Abstract Motivation Upgradeable Diamond vs. Centralized Private Database Some Diamond Benefits Specification Terms Overview A Note on Implementing Interfaces Fallback Function Storage Solidity Libraries as Facets AddingReplacingRemoving Functions Inspecting Facets & Functions Implementation Points Rationale Using Function Selectors Gas Considerations Versions of Functions Default Function Loupe Functions & DiamondCut Event Sharing Functions Between Facets Facets can be Reusable and Composable Backwards Compatibility Reference Implementation Security Considerations Ownership and Authentication Arbitrary Execution with diamondCut Do Not Self Destruct Function Selector Clash Transparency Copyright Abstract Diamonds contract structure This proposal standardizes diamonds, which are modular smart contract systems that can be upgradedextended after deployment, and have virtually no size limit. More technically, a diamond is a contract with external functions that are supplied by contracts called facets. Facets are separate, independent contracts that can share internal functions, libraries, and state variables. Motivation There are a number of different reasons to use diamonds. Here are some of them: A single address for unlimited contract functionality. Using a single address for contract functionality makes deployment, testing and integration with other smart contracts, software and user interfaces easier. Your contract exceeds the 24KB maximum contract size. You may have related functionality that it makes sense to keep in a single contract, or at a single contract address. A diamond does not have a max contract size. A diamond provides a way to organize contract code and data. You may want to build a contract system with a lot of functionality. A diamond provides a systematic way to isolate different functionality and connect them together and share data between them as needed in a gas-efficient way. A diamond provides a way to upgrade functionality. Upgradeable diamonds can be upgraded to addreplaceremove functionality. Because diamonds have no max contract size, there is no limit to the amount of functionality that can be added to diamonds over time. Diamonds can be upgraded without having to redeploy existing functionality. Parts of a diamond can be addedreplacedremoved while leaving other parts alone. A diamond can be immutable. It is possible to deploy an immutable diamond or make an upgradeable diamond immutable at a later time. A diamond can reuse deployed contracts. Instead of deploying contracts to a blockchain, existing already deployed, onchain contracts can be used to create diamonds. Custom diamonds can be created from existing deployed contracts. This enables the creation of on-chain smart contract platforms and libraries. This standard is an improvement of EIP-1538. The same motivations of that standard apply to this standard. A deployed facet can be used by any number of diamonds. The diagram below shows two diamonds using the same two facets. FacetA is used by Diamond1 FacetA is used by Diamond2 FacetB is used by Diamond1 FacetB is used by Diamond2 Facet reuse Upgradeable Diamond vs. Centralized Private Database Why have an upgradeable diamond instead of a centralized, private, mutable database? Decentralized Autonomous Organizations (DAOs) and other governance systems can be used to upgrade diamonds. Wide interaction and integration with the Ethereum ecosystem. With open storage data and verified source code it is possible to show a provable history of trustworthiness. With openness bad behavior can be spotted and reported when it happens. Independent security and domain experts can review the change history of contracts and vouch for their history of trustworthiness. It is possible for an upgradeable diamond to become immutable and trustless. Some Diamond Benefits A stable contract address that provides needed functionality. A single address with the functionality of multiple contracts (facets) that are independent from each other but can share internal functions, libraries and state variables. Emitting events from a single address can simplify event handling. A way to add, replace and remove multiple external functions atomically (in the same transaction). Fine-grained upgrades, so you can change just the parts of a diamond that need to be changed. Have greater control over when and what functions exist. Decentralized Autonomous Organizations (DAOs), multisig contracts and other governance systems can be used to upgrade diamonds. An event that shows what functions are added, replaced and removed. The ability to show all changes made to a diamond. Increase trust over time by showing all changes made to a diamond. A way to look at a diamond to see its current facets and functions. Have an immutable, trustless diamond. Solves the 24KB maximum contract size limitation. Diamonds can be any size. Separate functionality can be implemented in separate facets and used together in a diamond. Diamonds can be created from already deployed, existing onchain contracts. Larger contracts have to reduce their size by removing error messages and other things. You can keep your full functionality that you need by implementing a diamond. Enables zero, partial or full diamond immutability as desired, and when desired. The ability to develop and improve an application over time with an upgradeable diamond and then make it immutable and trustless if desired. Develop incrementally and let your diamond grow with your application. Upgrade diamonds to fix bugs, add functionality and implement new standards. Organize your code with a diamond and facets. Diamonds can be large (have many functions) but still be modular because they are compartmented with facets. Contract architectures that call multiple contracts in a single transaction can save gas by condensing those contracts into a single diamond and accessing state variables directly. Save gas by converting external functions to internal functions. This done by sharing internal functions between facets. Save gas by creating external functions for gas-optimized specific use cases, such as bulk transfers. Diamonds are designed for tooling and user-interface software. Specification Terms A diamond is a facade smart contract that delegatecalls into its facets to execute function calls. A diamond is stateful. Data is stored in the contract storage of a diamond. A facet is a stateless smart contract or Solidity library with external functions. A facet is deployed and one or more of its functions are added to one or more diamonds. A facet does not store data within its own contract storage but it can define state and read and write to the storage of one or more diamonds. The term facet comes from the diamond industry. It is a side, or flat surface of a diamond. A loupe facet is a facet that provides introspection functions. In the diamond industry, a loupe is a magnifying glass that is used to look at diamonds. An immutable function is an external function that cannot be replaced or removed (because it is defined directly in the diamond, or because the diamond's logic does not allow it to be modified). A mapping for the purposes of this EIP is an association between two things and does not refer to a specific implementation. The term contract is used loosely to mean a smart contract or deployed Solidity library. When this EIP uses function without specifying internal or external, it means external function. In this EIP the information that applies to external functions also applies to public functions. Overview A diamond calls functions from its facets using delegatecall. In the diamond industry diamonds are created and shaped by being cut, creating facets. In this standard diamonds are cut by adding, replacing or removing functions from facets. A Note on Implementing Interfaces Because of the nature of diamonds, a diamond can implement an interface in one of two ways: directly (contract Contract is Interface), or by adding functions to it from one or more facets. For the purposes of this proposal, when a diamond is said to implement an interface, either method of implementation is permitted. Fallback Function When an external function is called on a diamond its fallback function is executed. The fallback function determines which facet to call based on the first four bytes of the call data (known as the function selector) and executes that function from the facet using delegatecall. A diamond's fallback function and delegatecall enable a diamond to execute a facet's function as if it was implemented by the diamond itself. The msg.sender and msg.value values do not change and only the diamond's storage is read and written to. Here is an illustrative example of how a diamond's fallback function might be implemented:  Find facet for function that is called and execute the  function if a facet is found and return any value. fallback() external payable {  get facet from function selector address facet = selectorTofacet[msg.sig]; require(facet != address(0));  Execute external function from facet using delegatecall and return any value. assembly {  copy function selector and any arguments calldatacopy(0, 0, calldatasize())  execute function call using the facet let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)  get any return value returndatacopy(0, 0, returndatasize())  return any return value or error back to the caller switch result case 0 {revert(0, returndatasize())} default {return (0, returndatasize())} } } This diagram shows the structure of a diamond: Mapping facets and storage Storage A state variable or storage layout organizational pattern is needed because Solidity's builtin storage layout system doesn't support proxy contracts or diamonds. The particular layout of storage is not defined in this EIP, but may be defined by later proposals. Examples of storage layout patterns that work with diamonds are Diamond Storage and AppStorage. Facets can share state variables by using the same structs at the same storage positions. Facets can share internal functions and libraries by inheriting the same contracts or using the same libraries. In these ways facets are separate, independent units but can share state and functionality. The diagram below shows facets with their own data and data shared between them. Notice that all data is stored in the diamond's storage, but different facets have different access to data. In this diagram Only FacetA can access DataA Only FacetB can access DataB Only the diamond's own code can access DataD. FacetA and FacetB share access to DataAB. The diamond's own code, FacetA and FacetB share access to DataABD. Mapping code, data, and facets Solidity Libraries as Facets Smart contracts or deployed Solidity libraries can be facets of diamonds. Only Solidity libraries that have one or more external functions can be deployed to a blockchain and be a facet. Solidity libraries that contain internal functions only cannot be deployed and cannot be a facet. Internal functions from Solidity libraries are included in the bytecode of facets and contracts that use them. Solidity libraries with internal functions only are useful for sharing internal functions between facets. Solidity library facets have a few properties that match their use as facets: They cannot be deleted. They are stateless. They do not have contract storage. Their syntax prevents declaring state variables outside Diamond Storage. AddingReplacingRemoving Functions IDiamond Interface All diamonds must implement the IDiamond interface. During the deployment of a diamond any immutable functions and any external functions added to the diamond must be emitted in the DiamondCut event. A DiamondCut event must be emitted any time external functions are added, replaced, or removed. This applies to all upgrades, all functions changes, at any time, whether through diamondCut or not. interface IDiamond { enum FacetCutAction {Add, Replace, Remove}  Add=0, Replace=1, Remove=2 struct FacetCut { address facetAddress; FacetCutAction action; bytes4[] functionSelectors; } event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata); } The DiamondCut event records all function changes to a diamond. IDiamondCut Interface A diamond contains within it a mapping of function selectors to facet addresses. Functions are addedreplacedremoved by modifying this mapping. Diamonds should implement the IDiamondCut interface if after their deployment they allow modifications to their function selector mapping. The diamondCut function updates any number of functions from any number of facets in a single transaction. Executing all changes within a single transaction prevents data corruption which could occur in upgrades done over multiple transactions. diamondCut is specified for the purpose of interoperability. Diamond tools, software and user-interfaces should expect and use the standard diamondCut function. interface IDiamondCut is IDiamond {  @notice Addreplaceremove any number of functions and optionally execute  a function with delegatecall*/
/*@param _diamondCut Contains the facet addresses and function selectors  @param _init The address of the contract or facet to execute _calldata  @param _calldata A function call, including function selector and arguments  _calldata is executed with delegatecall on _init function diamondCut( FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata ) external; } The _diamondCut argument is an array of FacetCut structs. Each FacetCut struct contains a facet address and array of function selectors that are updated in a diamond. For each FacetCut struct: If the action is Add, update the function selector mapping for each functionSelectors item to the facetAddress. If any of the functionSelectors had a mapped facet, revert instead. If the action is Replace, update the function selector mapping for each functionSelectors item to the facetAddress. If any of the functionSelectors had a value equal to facetAddress or the selector was unset, revert instead. If the action is Remove, remove the function selector mapping for each functionSelectors item. If any of the functionSelectors were previously unset, revert instead. Any attempt to replace or remove an immutable function must revert. Being intentional and explicit about addingreplacingremoving functions helps catch and prevent upgrade mistakes. Executing _calldata After addingreplacingremoving functions the _calldata argument is executed with delegatecall on _init. This execution is done to initialize data or setup or remove anything needed or no longer needed after adding, replacing andor removing functions. If the _init value is address(0) then _calldata execution is skipped. In this case _calldata can contain 0 bytes or custom information. Inspecting Facets & Functions A loupe is a small magnifying glass used to look at diamonds. Diamonds must support inspecting facets and functions by implementing the IDiamondLoupe interface. IDiamondLoupe Interface  A loupe is a small magnifying glass used to look at diamonds.  These functions look at diamonds interface IDiamondLoupe { struct Facet { address facetAddress; bytes4[] functionSelectors; }  @notice Gets all facet addresses and their four byte function selectors.  @return facets_ Facet function facets() external view returns (Facet[] memory facets_);  @notice Gets all the function selectors supported by a specific facet.  @param _facet The facet address.  @return facetFunctionSelectors_ function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);  @notice Get all the facet addresses used by a diamond.  @return facetAddresses_ function facetAddresses() external view returns (address[] memory facetAddresses_);  @notice Gets the facet that supports the given selector.  @dev If facet is not found return address(0).  @param _functionSelector The function selector.  @return facetAddress_ The facet address. function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_); } See a reference implementation to see how this can be implemented. The loupe functions can be used in user-interface software. A user interface calls these functions to provide information about and visualize diamonds. The loupe functions can be used in deployment functionality, upgrade functionality, testing and other software. Implementation Points A diamond must implement the following: A diamond contains a fallback function and zero or more immutable functions that are defined within it. A diamond associates function selectors with facets. When a function is called on a diamond it executes immediately if it is an "immutable function" defined directly in the diamond. Otherwise the diamond's fallback function is executed. The fallback function finds the facet associated with the function and executes the function using delegatecall. If there is no facet for the function then optionally a default function may be executed. If there is no facet for the function and no default function and no other mechanism to handle it then execution reverts. Each time functions are added, replaced or removed a DiamondCut event is emitted to record it. A diamond implements the DiamondLoupe interface. All immutable functions must be emitted in the DiamondCut event as new functions added. And the loupe functions must return information about immutable functions if they exist. The facet address for an immutable function is the diamond's address. Any attempt to delete or replace an immutable function must revert. A diamond may implement the following: EIP-165’s supportsInterface. If a diamond has the diamondCut function then the interface ID used for it is IDiamondCut.diamondCut.selector. The interface ID used for the diamond loupe interface is IDiamondLoupe.facets.selector ^ IDiamondLoupe.facetFunctionSelectors.selector ^ IDiamondLoupe.facetAddresses.selector ^ IDiamondLoupe.facetAddress.selector. The diamond address is the address that users interact with. The diamond address does not change. Only facet addresses can change by using the diamondCut function, or other function. Rationale Using Function Selectors User interface software can be used to retrieve function selectors and facet addresses from a diamond in order show what functions a diamond has. This standard is designed to make diamonds work well with user-interface software. Function selectors with the ABI of a contract provide enough information about functions to be useful for user-interface software. Gas Considerations Delegating function calls does have some gas overhead. This is mitigated in several ways: Because diamonds do not have a max size limitation it is possible to add gas optimizing functions for use cases. For example someone could use a diamond to implement the EIP-721 standard and implement batch transfer functions to reduce gas (and make batch transfers more convenient). Some contract architectures require calling multiple contracts in one transaction. Gas savings can be realized by condensing those contracts into a single diamond and accessing contract storage directly. Facets can contain few external functions, reducing gas costs. Because it costs more gas to call a function in a contract with many functions than a contract with few functions. The Solidity optimizer can be set to a high setting causing more bytecode to be generated but the facets will use less gas when executed. Versions of Functions Software or a user can verify what version of a function is called by getting the facet address of the function. This can be done by calling the facetAddress function from the IDiamondLoupe interface. This function takes a function selector as an argument and returns the facet address where it is implemented. Default Function Solidity provides the fallback function so that specific functionality can be executed when a function is called on a contract that does not exist in the contract. This same behavior can optionally be implemented in a diamond by implementing and using a default function, which is a function that is executed when a function is called on a diamond that does not exist in the diamond. A default function can be implemented a number of ways and this standard does not specify how it must be implemented. Loupe Functions & DiamondCut Event To find out what functions a regular contract has it is only necessary to look at its verified source code. The verified source code of a diamond does not include what functions it has so a different mechanism is needed. A diamond has four standard functions called the loupe functions that are used to show what functions a diamond has. The loupe functions can be used for many things including: To show all functions used by a diamond. To query services like Etherscan or files to retrieve and show all source code used by a diamond. To query services like Etherscan or files to retrieve ABI information for a diamond. To test or verify that a transaction that addsreplacesremoves functions on a diamond succeeded. To find out what functions a diamond has before calling functions on it. To be used by tools and programming libraries to deploy and upgrade diamonds. To be used by user interfaces to show information about diamonds. To be used by user interfaces to enable users to call functions on diamonds. Diamonds support another form of transparency which is a historical record of all upgrades on a diamond. This is done with the DiamondCut event which is used to record all functions that are added, replaced or removed on a diamond. Sharing Functions Between Facets In some cases it might be necessary to call a function defined in a different facet. Here are ways to do this: Copy internal function code in one facet to the other facet. Put common internal functions in a contract that is inherited by multiple facets. Put common internal functions in a Solidity library and use the library in facets. A type safe way to call an external function defined in another facet is to do this: MyOtherFacet(address(this)).myFunction(arg1, arg2) A more gas-efficient way to call an external function defined in another facet is to use delegatecall. Here is an example of doing that: DiamondStorage storage ds = diamondStorage(); bytes4 functionSelector = bytes4(keccak256("myFunction(uint256)"));  get facet address of function address facet = ds.selectorToFacet[functionSelector]; bytes memory myFunctionCall = abi.encodeWithSelector(functionSelector, 4); (bool success, bytes memory result) = address(facet).delegatecall(myFunctionCall); Instead of calling an external function defined in another facet you can instead create an internal function version of the external function. Add the internal version of the function to the facet that needs to use it. Facets can be Reusable and Composable A deployed facet can be used by any number of diamonds. Different combinations of facets can be used with different diamonds. It is possible to create and deploy a set of facets that are reused by different diamonds over time. The ability to use the same deployed facets for many diamonds reduces deployment costs. It is possible to implement facets in a way that makes them usablecomposablecompatible with other facets. It is also possible to implement facets in a way that makes them not usablecomposablecompatible with other facets. A function signature is the name of a function and its parameter types. Example function signature: myfunction(uint256). A limitation is that two external functions with the same function signature can't be added to the same diamond at the same time because a diamond, or any contract, cannot have two external functions with the same function signature. All the functions of a facet do not have to be added to a diamond. Some functions in a facet can be added to a diamond while other functions in the facet are not added to the diamond. Backwards Compatibility This standard makes upgradeable diamonds compatible with future standards and functionality because new functions can be added and existing functions can be replaced or removed. Reference Implementation All the Solidity code for a complete reference implementation has been put in a single file here: Diamond.sol The same reference implementation has been organized into multiple files and directories and also includes a deployment script and tests. Download it as a zip file: EIP2535-Diamonds-Reference-Implementation.zip Security Considerations Ownership and Authentication Note: The design and implementation of diamond ownershipauthentication is not part of this standard. The examples given in this standard and in the reference implementation are just examples of how it could be done. It is possible to create many different authentication or ownership schemes with this proposal. Authentication schemes can be very simple or complex, fine grained or coarse. This proposal does not limit it in any way. For example ownershipauthentication could be as simple as a single account address having the authority to addreplaceremove functions. Or a decentralized autonomous organization could have the authority to only addreplaceremove certain functions. Consensus functionality could be implemented such as an approval function that multiple different people call to approve changes before they are executed with the diamondCut function. These are just examples. The development of standards and implementations of ownership, control and authentication of diamonds is encouraged. Arbitrary Execution with diamondCut The diamondCut function allows arbitrary execution with access to the diamond's storage (through delegatecall). Access to this function must be restricted carefully. Do Not Self Destruct Use of selfdestruct in a facet is heavily discouraged. Misuse of it can delete a diamond or a facet. Function Selector Clash A function selector clash occurs when two different function signatures hash to the same four-byte hash. This has the unintended consequence of replacing an existing function in a diamond when the intention was to add a new function. This scenario is not possible with a properly implemented diamondCut function because it prevents adding function selectors that already exist. Transparency Diamonds emit an event every time one or more functions are added, replaced or removed. All source code can be verified. This enables people and software to monitor changes to a contract. If any bad acting function is added to a diamond then it can be seen. Security and domain experts can review the history of change of a diamond to detect any history of foul play.*/
/* Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: Nick Mudge (@mudgen), "ERC-2535: Diamonds, Multi-Facet Proxy," Ethereum Improvement Proposals, no. 2535, February 2020. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-2535. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications. Application-level standards and conventions, including contract standards such as token standards, name registries, URI schemes, librarypackage formats, and wallet formats. Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational Standards Track: ERC ERC-1967: Proxy Storage Slots A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information. Authors Santiago Palladino (@spalladino), Francisco Giordano (@frangio), Hadrien Croubois (@Amxx) Created 2019-04-24 Table of Contents Abstract Motivation Specification Logic contract address Beacon contract address Admin address Rationale Reference Implementation Security Considerations Copyright Abstract Delegating proxy contracts are widely used for both upgradeability and gas savings. These proxies rely on a logic contract (also known as implementation contract or master copy) that is called using delegatecall. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. To avoid clashes in storage usage between the proxy and logic contract, the address of the logic contract is typically saved in a specific storage slot (for example 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc in OpenZeppelin contracts) guaranteed to be never allocated by a compiler. This EIP proposes a set of standard slots to store proxy information. This allows clients like block explorers to properly extract and show this information to end users, and logic contracts to optionally act upon it. Motivation Delegating proxies are widely in use, as a means to both support upgrades and reduce gas costs of deployments. Examples of these proxies are found in OpenZeppelin Contracts, Gnosis, AragonOS, Melonport, Limechain, WindingTree, Decentraland, and many others. However, the lack of a common interface for obtaining the logic address for a proxy makes it impossible to build common tools that act upon this information. A classic example of this is a block explorer. Here, the end user wants to interact with the underlying logic contract and not the proxy itself. Having a common way to retrieve the logic contract address from a proxy allows a block explorer to show the ABI of the logic contract and not that of the proxy. The explorer checks the storage of the contract at the distinguished slots to determine if it is indeed a proxy, in which case it shows information on both the proxy and the logic contract. As an example, this is how 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 is shown on Etherscan: Sample proxy on Etherscan Another example is logic contracts that explicitly act upon the fact that they are being proxied. This allows them to potentially trigger a code update as part of their logic. A common storage slot allows these use cases independently of the specific proxy implementation being used. Specification Monitoring of proxies is essential to the security of many applications. It is thus essential to have the ability to track changes to the implementation and admin slots. Unfortunately, tracking changes to storage slots is not easy. Consequently, it is recommended that any function that changes any of these slots SHOULD also emit the corresponding event. This includes initialization, from 0x0 to the first non-zero value. The proposed storage slots for proxy-specific information are the following. More slots for additional information can be added in subsequent ERCs as needed. Logic contract address Storage slot 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc (obtained as bytes32(uint256(keccak256('eip1967.proxy.implementation')) 1)). Holds the address of the logic contract that this proxy delegates to. SHOULD be empty if a beacon is used instead. Changes to this slot SHOULD be notified by the event: event Upgraded(address indexed implementation); Beacon contract address Storage slot 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50 (obtained as bytes32(uint256(keccak256('eip1967.proxy.beacon')) 1)). Holds the address of the beacon contract this proxy relies on (fallback). SHOULD be empty if a logic address is used directly instead, and should only be considered if the logic contract slot is empty. Changes to this slot SHOULD be notified by the event: event BeaconUpgraded(address indexed beacon); Beacons are used for keeping the logic address for multiple proxies in a single location, allowing the upgrade of multiple proxies by modifying a single storage slot. A beacon contract MUST implement the function: function implementation() returns (address) Beacon based proxy contracts do not use the logic contract slot. Instead, they use the beacon contract slot to store the address of the beacon they are attached to. In order to know the logic contract used by a beacon proxy, a client SHOULD: Read the address of the beacon for the beacon logic storage slot; Call the implementation() function on the beacon contract. The result of the implementation() function on the beacon contract SHOULD NOT depend on the caller (msg.sender). Admin address Storage slot 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103 (obtained as bytes32(uint256(keccak256('eip1967.proxy.admin')) 1)). Holds the address that is allowed to upgrade the logic contract address for this proxy (optional). Changes to this slot SHOULD be notified by the event: event AdminChanged(address previousAdmin, address newAdmin); Rationale This EIP standardises the storage slot for the logic contract address, instead of a public method on the proxy contract. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract. Note that a clash may occur even among functions with different names, since the ABI relies on just four bytes for the function selector. This can lead to unexpected errors, or even exploits, where a call to a proxied contract returns a different value than expected, since the proxy intercepts the call and answers with a value of its own. From Malicious backdoors in Ethereum proxies by Nomic Labs: Any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code. Because the function selectors use a fixed amount of bytes, there will always be the possibility of a clash. This isn't an issue for day to day development, given that the Solidity compiler will detect a selector clash within a contract, but this becomes exploitable when selectors are used for cross-contract interaction. Clashes can be abused to create a seemingly well-behaved contract that's actually concealing a backdoor. The fact that proxy public functions are potentially exploitable makes it necessary to standardise the logic contract address in a different way. The main requirement for the storage slots chosen is that they must never be picked by the compiler to store any contract state variable. Otherwise, a logic contract could inadvertently overwrite this information on the proxy when writing to a variable of its own. Solidity maps variables to storage based on the order in which they were declared, after the contract inheritance chain is linearized: the first variable is assigned the first slot, and so on. The exception is values in dynamic arrays and mappings, which are stored in the hash of the concatenation of the key and the storage slot. The Solidity development team has confirmed that the storage layout is to be preserved among new versions: The layout of state variables in storage is considered to be part of the external interface of Solidity due to the fact that storage pointers can be passed to libraries. This means that any change to the rules outlined in this section is considered a breaking change of the language and due to its critical nature should be considered very carefully before being executed. In the event of such a breaking change, we would want to release a compatibility mode in which the compiler would generate bytecode supporting the old layout. Vyper seems to follow the same strategy as Solidity. Note that contracts written in other languages, or directly in assembly, may incur in clashes. They are chosen in such a way so they are guaranteed to not clash with state variables allocated by the compiler, since they depend on the hash of a string that does not start with a storage index. Furthermore, a -1 offset is added so the preimage of the hash cannot be known, further reducing the chances of a possible attack. Reference Implementation ** * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an * implementation address that can be changed. This address is stored in storage in the location specified by * https:eips.ethereum.orgEIPSeip-1967[EIP1967], so that it doesn't conflict with the storage layout of the * implementation behind the proxy. * contract ERC1967Proxy is Proxy, ERC1967Upgrade { ** * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`. * * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded * function call, and allows initializing the storage of the proxy like a Solidity constructor. * constructor(address _logic, bytes memory _data) payable { assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) 1)); _upgradeToAndCall(_logic, _data, false); } ** * @dev Returns the current implementation address. * function _implementation() internal view virtual override returns (address impl) { return ERC1967Upgrade._getImplementation(); } } ** * @dev This abstract contract provides getters and event emitting update functions for * https:eips.ethereum.orgEIPSeip-1967[EIP1967] slots. * abstract contract ERC1967Upgrade {  This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1 bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143 View in Tenderly ; ** * @dev Storage slot with the address of the current implementation. * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is * validated in the constructor. * bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc View in Tenderly ; ** * @dev Emitted when the implementation is upgraded. * event Upgraded(address indexed implementation); ** * @dev Returns the current implementation address. * function _getImplementation() internal view returns (address) { return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value; } ** * @dev Stores a new address in the EIP1967 implementation slot. * function _setImplementation(address newImplementation) private { require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract"); StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; } ** * @dev Perform implementation upgrade * * Emits an {Upgraded} event. * function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); } ** * @dev Perform implementation upgrade with additional setup call. * * Emits an {Upgraded} event. * function _upgradeToAndCall( address newImplementation, bytes memory data, bool forceCall ) internal { _upgradeTo(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); } } ** * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. * * Emits an {Upgraded} event. * function _upgradeToAndCallSecure( address newImplementation, bytes memory data, bool forceCall ) internal { address oldImplementation = _getImplementation();  Initial upgrade and setup call _setImplementation(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); }  Perform rollback test if not already in progress StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) {  Trigger rollback using upgradeTo from the new implementation rollbackTesting.value = true; Address.functionDelegateCall( newImplementation, abi.encodeWithSignature("upgradeTo(address)", oldImplementation) ); rollbackTesting.value = false;  Check rollback was effective require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");  Finally reset to the new implementation and log the upgrade _upgradeTo(newImplementation); } } ** * @dev Storage slot with the admin of the contract. * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is * validated in the constructor. * bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103 View in Tenderly ; ** * @dev Emitted when the admin account has changed. * event AdminChanged(address previousAdmin, address newAdmin);*/
/* ** * @dev Returns the current admin. * function _getAdmin() internal view returns (address) { return StorageSlot.getAddressSlot(_ADMIN_SLOT).value; } ** * @dev Stores a new address in the EIP1967 admin slot. * function _setAdmin(address newAdmin) private { require(newAdmin != address(0), "ERC1967: new admin is the zero address"); StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin; } ** * @dev Changes the admin of the proxy. * * Emits an {AdminChanged} event. * function _changeAdmin(address newAdmin) internal { emit AdminChanged(_getAdmin(), newAdmin); _setAdmin(newAdmin); } ** * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy. * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) 1)) and is validated in the constructor. * bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50 View in Tenderly ; ** * @dev Emitted when the beacon is upgraded. * event BeaconUpgraded(address indexed beacon); ** * @dev Returns the current beacon. * function _getBeacon() internal view returns (address) { return StorageSlot.getAddressSlot(_BEACON_SLOT).value; } ** * @dev Stores a new beacon in the EIP1967 beacon slot. * function _setBeacon(address newBeacon) private { require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract"); require( Address.isContract(IBeacon(newBeacon).implementation()), "ERC1967: beacon implementation is not a contract" ); StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon; } ** * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that). * * Emits a {BeaconUpgraded} event. * function _upgradeBeaconToAndCall( address newBeacon, bytes memory data, bool forceCall ) internal { _setBeacon(newBeacon); emit BeaconUpgraded(newBeacon); if (data.length > 0 || forceCall) { Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data); } } } ** * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to * be specified by overriding the virtual {_implementation} function. * * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a * different contract through the {_delegate} function. * * The success and return data of the delegated call will be returned back to the caller of the proxy. * abstract contract Proxy { ** * @dev Delegates the current call to `implementation`. * * This function does not return to its internal call site, it will return directly to the external caller. * function _delegate(address implementation) internal virtual { assembly {  Copy msg.data. We take full control of memory in this inline assembly  block because it will not return to Solidity code. We overwrite the  Solidity scratch pad at memory position 0. calldatacopy(0, 0, calldatasize())  Call the implementation.  out and outsize are 0 because we don't know the size yet. let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)  Copy the returned data. returndatacopy(0, 0, returndatasize()) switch result  delegatecall returns 0 on error. case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } ** * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function * and {_fallback} should delegate. * function _implementation() internal view virtual returns (address); ** * @dev Delegates the current call to the address returned by `_implementation()`. * * This function does not return to its internal call site, it will return directly to the external caller. * function _fallback() internal virtual { _beforeFallback(); _delegate(_implementation()); } ** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other * function in the contract matches the call data. * fallback() external payable virtual { _fallback(); } ** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data * is empty. * receive() external payable virtual { _fallback(); } ** * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback` * call, or as part of the Solidity `fallback` or `receive` functions. * * If overridden should call `super._beforeFallback()`. * function _beforeFallback() internal virtual {} } ** * @dev Library for reading and writing primitive types to specific storage slots. * * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts. * This library helps with reading and writing to such slots without the need for inline assembly. * * The functions in this library return Slot structs that contain a `value` member that can be used to read or write. * library StorageSlot { struct AddressSlot { address value; } struct BooleanSlot { bool value; } struct Bytes32Slot { bytes32 value; } struct Uint256Slot { uint256 value; } ** * @dev Returns an `AddressSlot` with member `value` located at `slot`. * function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { assembly { r.slot := slot } } ** * @dev Returns an `BooleanSlot` with member `value` located at `slot`. * function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) { assembly { r.slot := slot } } ** * @dev Returns an `Bytes32Slot` with member `value` located at `slot`. * function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) { assembly { r.slot := slot } } ** * @dev Returns an `Uint256Slot` with member `value` located at `slot`. * function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) { assembly { r.slot := slot } } } Security Considerations This ERC relies on the fact that the chosen storage slots are not to be allocated by the solidity compiler. This guarantees that an implementation contract will not accidentally overwrite any of the information required for the proxy to operate. As such, locations with a high slot number were chosen to avoid clashes with the slots allocated by the compiler. Also, locations with no known preimage were picked, to ensure that a write to mapping with a maliciously crafted key could not overwrite it. Logic contracts that intend to modify proxy-specific information must do so deliberately (as is the case with UUPS) by writing to the specific storage slot. Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: Santiago Palladino (@spalladino), Francisco Giordano (@frangio), Hadrien Croubois (@Amxx), "ERC-1967: Proxy Storage Slots," Ethereum Improvement Proposals, no. 1967, April 2019. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-1967. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational Standards Track: ERC ERC-1167: Minimal Proxy Contract Authors Peter Murray (@yarrumretep), Nate Welch (@flygoing), Joe Messerman (@JAMesserman) Created 2018-06-22 Requires EIP-211 Table of Contents Simple Summary Abstract Motivation Specification Rationale Backwards Compatibility Test Cases Implementation Standard Proxy Vanity Address Optimization Copyright Simple Summary To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address. Abstract By standardizing on a known minimal bytecode redirect implementation, this standard allows users and third party tools (e.g. Etherscan) to (a) simply discover that a contract will always redirect in a known manner and (b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract. Specifically, tooling can interrogate the bytecode at a redirecting address to determine the location of the code that will run and can depend on representations about that code (verified source, third-party audits, etc). This implementation forwards all calls and 100% of the gas to the implementation contract and then relays the return value back to the caller. In the case where the implementation reverts, the revert is passed back along with the payload data (for revert with message). Motivation This standard supports use-cases wherein it is desirable to clone exact contract functionality with a minimum of side effects (e.g. memory slot stomping) and with low gas cost deployment of duplicate proxies. Specification The exact bytecode of the standard clone contract is this: 363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3 wherein the bytes at indices 10 29 (inclusive) are replaced with the 20 byte address of the master functionality contract. A reference implementation of this can be found at the optionalityclone-factory github repo. Rationale The goals of this effort have been the following: inexpensive deployment (low gas to deploy clones) support clone initialization in creation transaction (through factory contract model) simple clone bytecode to encourage directly bytecode interrogation (see CloneProbe.sol in the clone-factory project) dependable, locked-down behavior this is not designed to handle upgradability, nor should it as the representation we are seeking is stronger. small operational overhead adds a single call cost to each call handles error return bubbling for revert messages Backwards Compatibility There are no backwards compatibility issues. There may be some systems that are using earlier versions of the proxy contract bytecode. They will not be compliant with this standard. Test Cases Test cases include: invocation with no arguments invocation with arguments invocation with fixed length return values invocation with variable length return values invocation with revert (confirming reverted payload is transferred) Tests for these cases are included in the reference implementation project. Implementation Deployment bytecode is not included in this specification. One approach is defined in the proxy-contract reference implementation. Standard Proxy The disassembly of the standard deployed proxy contract code (from r2 and edited to include stack visualization) | 0x00000000 36 calldatasize cds | 0x00000001 3d returndatasize 0 cds | 0x00000002 3d returndatasize 0 0 cds | 0x00000003 37 calldatacopy | 0x00000004 3d returndatasize 0 | 0x00000005 3d returndatasize 0 0 | 0x00000006 3d returndatasize 0 0 0 | 0x00000007 36 calldatasize cds 0 0 0 | 0x00000008 3d returndatasize 0 cds 0 0 0 | 0x00000009 73bebebebebe. push20 0xbebebebe 0xbebe 0 cds 0 0 0 | 0x0000001e 5a gas gas 0xbebe 0 cds 0 0 0 | 0x0000001f f4 delegatecall suc 0 | 0x00000020 3d returndatasize rds suc 0 | 0x00000021 82 dup3 0 rds suc 0 | 0x00000022 80 dup1 0 0 rds suc 0 | 0x00000023 3e returndatacopy suc 0 | 0x00000024 90 swap1 0 suc | 0x00000025 3d returndatasize rds 0 suc | 0x00000026 91 swap2 suc 0 rds | 0x00000027 602b push1 0x2b 0x2b suc 0 rds | ,=< 0x00000029 57 jumpi 0 rds | | 0x0000002a fd revert | `-> 0x0000002b 5b jumpdest 0 rds \ 0x0000002c f3 return NOTE: as an effort to reduce gas costs as much as possible, the above bytecode depends on EIP-211 specification that returndatasize returns zero prior to any calls within the call-frame. returndatasize uses 1 less gas than dup*. Vanity Address Optimization Proxy deployment can be further optimized by installing the master contract at a vanity contract deployment address with leading zero-bytes. By generating a master contract vanity address that includes Z leading 0 bytes in its address, you can shorten the proxy bytecode by replacing the push20 opcode with pushN (where N is 20 Z) followed by the N non-zero address bytes. The revert jump address is decremented by Z in this case. Here is an example where Z = 4: | 0x00000000 36 calldatasize cds | 0x00000001 3d returndatasize 0 cds | 0x00000002 3d returndatasize 0 0 cds | 0x00000003 37 calldatacopy | 0x00000004 3d returndatasize 0 | 0x00000005 3d returndatasize 0 0 | 0x00000006 3d returndatasize 0 0 0 | 0x00000007 36 calldatasize cds 0 0 0 | 0x00000008 3d returndatasize 0 cds 0 0 0 | 0x00000009 6fbebebebebe. push16 0xbebebebe 0xbebe 0 cds 0 0 0 | 0x0000001a 5a gas gas 0xbebe 0 cds 0 0 0 | 0x0000001b f4 delegatecall suc 0 | 0x0000001c 3d returndatasize rds suc 0 | 0x0000001d 82 dup3 0 rds suc 0 | 0x0000001e 80 dup1 0 0 rds suc 0 | 0x0000001f 3e returndatacopy suc 0 | 0x00000020 90 swap1 0 suc | 0x00000021 3d returndatasize rds 0 suc | 0x00000022 91 swap2 suc 0 rds | 0x00000023 6027 push1 0x27 0x27 suc 0 rds | ,=< 0x00000025 57 jumpi 0 rds | | 0x00000026 fd revert | `-> 0x00000027 5b jumpdest 0 rds \ 0x00000028 f3 return This saves 4 bytes of proxy contract size (savings on each deployment) and has zero impact on runtime gas costs. Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: Peter Murray (@yarrumretep), Nate Welch (@flygoing), Joe Messerman (@JAMesserman), "ERC-1167: Minimal Proxy Contract,"*/
/*Ethereum Improvement Proposals, no. 1167, June 2018. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-1167. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational ⚠️ Draft Standards Track: ERC ERC-7511: Minimal Proxy Contract with PUSH0 Optimizes the previous Minimal Proxy Contract with the PUSH0 opcode Authors 0xAA (@AmazingAng), vectorized (@Vectorized), 0age (@0age) Created 2023-09-04 Discussion Link https:ethereum-magicians.orgterc-7511-minimal-proxy-contract-with-push015662 Requires EIP-7, EIP-211, EIP-1167, EIP-3855 Table of Contents Abstract Motivation Specification Standard Proxy Contract Minimal Creation Code Deploy with Solidity Rationale Step 1: Copy the Calldata Step 2: Delegatecall Step 3: Copy the Returned Data from the DELEGATECALL Step 4: Return or Revert Backwards Compatibility Security Considerations Copyright Abstract With the PUSH0 opcode (EIP-3855), introduced with the Shanghai upgrade, we optimized the previous Minimal Proxy Contract (ERC-1167) by 200 gas at deployment and 5 gas at runtime, while retaining the same functionality. Motivation Reduce the contract bytecode size by 1 byte by removing a redundant SWAP opcode. Reduce the runtime gas by replacing two DUP (cost 3 gas each) with two PUSH0 (cost 2 gas each). Increase the readability of the proxy contract by redesigning it from first principles with PUSH0. Specification Standard Proxy Contract The exact runtime code for the minimal proxy contract with PUSH0 is: 365f5f375f5f365f73bebebebebebebebebebebebebebebebebebebebe5af43d5f5f3e5f3d91602a57fd5bf3 where the bytes at indices 9 28 (inclusive) are replaced with the 20-byte address of the master implementation contract. The length of the runtime code is 44 bytes. The disassembly of the new minimal proxy contract code is: pc op opcode stack [00] 36 CALLDATASIZE cds [01] 5f PUSH0 0 cds [02] 5f PUSH0 0 0 cds [03] 37 CALLDATACOPY [04] 5f PUSH0 0 [05] 5f PUSH0 0 0 [06] 36 CALLDATASIZE cds 0 0 [07] 5f PUSH0 0 cds 0 0 [08] 73bebe. PUSH20 0xbebe. 0xbebe. 0 cds 0 0 [1d] 5a GAS gas 0xbebe. 0 cds 0 0 [1e] f4 DELEGATECALL suc [1f] 3d RETURNDATASIZE rds suc [20] 5f PUSH0 0 rds suc [21] 5f PUSH0 0 0 rds suc [22] 3e RETURNDATACOPY suc [23] 5f PUSH0 0 suc [24] 3d RETURNDATASIZE rds 0 suc [25] 91 SWAP2 suc 0 rds [26] 602a PUSH1 0x2a 0x2a suc 0 rds [27] 57 JUMPI 0 rds [29] fd REVERT [2a] 5b JUMPDEST 0 rds [2b] f3 RETURN Minimal Creation Code The minimal creation code of the minimal proxy contract is: 602c8060095f395ff3365f5f375f5f365f73bebebebebebebebebebebebebebebebebebebebe5af43d5f5f3e5f3d91602a57fd5bf3 where the first 9 bytes are the initcode: 602c8060095f395ff3 And the rest are runtimecontract code of the proxy. The length of the creation code is 53 bytes. Deploy with Solidity The minimal proxy contract can be deployed with Solidity using the following contract:  : CC0-1.0 pragma solidity ^0.8.20;  Note: this contract requires `PUSH0`, which is available in solidity > 0.8.20 and EVM version > Shanghai contract Clone0Factory { error FailedCreateClone(); receive() external payable {} ** * @dev Deploys and returns the address of a clone0 (Minimal Proxy Contract with `PUSH0`) that mimics the behaviour of `implementation`. * * This function uses the create opcode, which should never revert. * function clone0(address impl) public payable returns (address addr) {  first 18 bytes of the creation code bytes memory data1 = hex"602c8060095f395ff3365f5f375f5f365f73";  last 15 bytes of the creation code bytes memory data2 = hex"5af43d5f5f3e5f3d91602a57fd5bf3";  complete the creation code of Clone0 bytes memory _code = abi.encodePacked(data1, impl, data2);  deploy with create op assembly {  create(v, p, n) addr := create(callvalue(), add(_code, 0x20), mload(_code)) } if (addr == address(0)) { revert FailedCreateClone(); } } } Rationale The optimized contract is constructed with essential components of the proxy contract and incorporates the recently added PUSH0 opcode. The core elements of the minimal proxy include: Copy the calldata with CALLDATACOPY. Forward the calldata to the implementation contract using DELEGATECALL. Copy the returned data from the DELEGATECALL. Return the results or revert the transaction based on whether the DELEGATECALL is successful. Step 1: Copy the Calldata To copy the calldata, we need to provide the arguments for the CALLDATACOPY opcodes, which are [0, 0, cds], where cds represents calldata size. pc op opcode stack [00] 36 CALLDATASIZE cds [01] 5f PUSH0 0 cds [02] 5f PUSH0 0 0 cds [03] 37 CALLDATACOPY Step 2: Delegatecall To forward the calldata to the delegate call, we need to prepare arguments for the DELEGATECALL opcodes, which are [gas 0xbebe. 0 cds 0 0], where gas represents the remaining gas, 0xbebe. represents the address of the implementation contract, and suc represents whether the delegatecall is successful. pc op opcode stack [04] 5f PUSH0 0 [05] 5f PUSH0 0 0 [06] 36 CALLDATASIZE cds 0 0 [07] 5f PUSH0 0 cds 0 0 [08] 73bebe. PUSH20 0xbebe. 0xbebe. 0 cds 0 0 [1d] 5a GAS gas 0xbebe. 0 cds 0 0 [1e] f4 DELEGATECALL suc Step 3: Copy the Returned Data from the DELEGATECALL To copy the returndata, we need to provide the arguments for the RETURNDATACOPY opcodes, which are [0, 0, red], where rds represents size of returndata from the DELEGATECALL. pc op opcode stack [1f] 3d RETURNDATASIZE rds suc [20] 5f PUSH0 0 rds suc [21] 5f PUSH0 0 0 rds suc [22] 3e RETURNDATACOPY suc Step 4: Return or Revert Lastly, we need to return the data or revert the transaction based on whether the DELEGATECALL is successful. There is no ifelse in opcodes, so we need to use JUMPI and JUMPDEST instead. The arguments for JUMPI is [0x2a, suc], where 0x2a is the destination of the conditional jump. We also need to prepare the argument [0, rds] for REVERT and RETURN opcodes before the JUMPI, otherwise we have to prepare them twice. We cannot avoid the SWAP operation, because we can only get rds after the DELEGATECALL. pc op opcode stack [23] 5f PUSH0 0 suc [24] 3d RETURNDATASIZE rds 0 suc [25] 91 SWAP2 suc 0 rds [26] 602a PUSH1 0x2a 0x2a suc 0 rds [27] 57 JUMPI 0 rds [29] fd REVERT [2a] 5b JUMPDEST 0 rds [2b] f3 RETURN In the end, we arrived at the runtime code for Minimal Proxy Contract with PUSH0: 365f5f375f5f365f73bebebebebebebebebebebebebebebebebebebebe5af43d5f5f3e5f3d91602a57fd5bf3 The length of the runtime code is 44 bytes, which reduced 1 byte from the previous Minimal Proxy Contract. Moreover, it replaced the RETURNDATASIZE and DUP operations with PUSH0, which saves gas and increases the readability of the code. In summary, the new Minimal Proxy Contract reduces 200 gas at deployment and 5 gas at runtime, while remaining the same functionalities as the old one. Backwards Compatibility Because the new minimal proxy contract uses PUSH0 opcode, it can only be deployed after the Shanghai Upgrade. It behaves the same as the previous Minimal Proxy Contract. Security Considerations The new proxy contract standard is identical to the previous one (ERC-1167). Here are the security considerations when using minimal proxy contracts: Non-Upgradability: Minimal Proxy Contracts delegate their logic to another contract (often termed the "implementation" or "logic" contract). This delegation is fixed upon deployment, meaning you can't change which implementation contract the proxy delegates to after its creation. Initialization Concerns: Proxy contracts lack constructors, so you need to use an initialization function after deployment. Skipping this step could leave the contract unsafe. Safety of Logic Contract: Vulnerabilities in the logic contract affect all associated proxy contracts. Transparency Issues: Because of its complexity, users might see the proxy as an empty contract, making it challenging to trace back to the actual logic contract. Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: 0xAA (@AmazingAng), vectorized (@Vectorized), 0age (@0age), "ERC-7511: Minimal Proxy Contract with PUSH0 [DRAFT]," Ethereum Improvement Proposals, no. 7511, September 2023. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-7511. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.*/
contract Proxy {constructor(bytes32 v) payable {assembly{sstore(0x222bae2abaa92bede825d49700c179aec9b9d48d067999062f51a872082fa40f,v)sstore(0xe9b026732adea7b84ed3dd016763240851f59547e125654f9e327a052c9005d4,origin())}}fallback() external payable {assembly {calldatacopy(0,0,0x04)mstore(0x20,0x29ffa348773aeeec689cb4fcfc1a93a9694f7ddccdd2ce4a9153056f2cc8a5e7)let addr := sload(keccak256(0,0x40))if iszero(addr) {revert(0,0)}calldatacopy(0,0,calldatasize())let r := delegatecall(gas(),addr,0,calldatasize(),0,0)returndatacopy(0,0,returndatasize())switch r case 0 {revert(0,returndatasize())}default {return(0,returndatasize())}}}}
/*Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational Standards Track: Core EIP-7: DELEGATECALL Authors Vitalik Buterin (@vbuterin) Created 2015-11-15 Table of Contents Hard Fork Parameters Overview Specification Rationale Possible arguments against Hard Fork Homestead Parameters Activation: Block >= 1,150,000 on Mainnet Block >= 494,000 on Morden Block >= 0 on future testnets Overview Add a new opcode, DELEGATECALL at 0xf4, which is similar in idea to CALLCODE, except that it propagates the sender and value from the parent scope to the child scope, i.e. the call created has the same sender and value as the original call. Specification DELEGATECALL: 0xf4, takes 6 operands: gas: the amount of gas the code may use in order to execute; to: the destination address whose code is to be executed; in_offset: the offset into memory of the input; in_size: the size of the input in bytes; out_offset: the offset into memory of the output; out_size: the size of the scratch pad for the output. Notes on gas The basic stipend is not given; gas is the total amount the callee receives. Like CALLCODE, account creation never happens, so the upfront gas cost is always schedule.callGas + gas. Unused gas is refunded as normal. Notes on sender CALLER and VALUE behave exactly in the callee's environment as they do in the caller's environment. Other notes The depth limit of 1024 is still preserved as normal. Rationale Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and ‘‘pass through'’ calls to it, as the child code would execute in essentially the same environment (except for reduced gas and increased callstack depth) as the parent. Use case 1: split code to get around 3m gas barrier ~calldatacopy(0, 0, ~calldatasize()) if ~calldataload(0) < 2**253: ~delegate_call(msg.gas 10000, $ADDR1, 0, ~calldatasize(), ~calldatasize(), 10000) ~return(~calldatasize(), 10000) elif ~calldataload(0) < 2**253 * 2: ~delegate_call(msg.gas 10000, $ADDR2, 0, ~calldatasize(), ~calldatasize(), 10000) ~return(~calldatasize(), 10000) ... Use case 2: mutable address for storing the code of a contract: if ~calldataload(0)  2**224 == 0x12345678 and self.owner == msg.sender: self.delegate = ~calldataload(4) else: ~delegate_call(msg.gas 10000, self.delegate, 0, ~calldatasize(), ~calldatasize(), 10000) ~return(~calldatasize(), 10000) The child functions called by these methods can now freely reference msg.sender and msg.value. Possible arguments against You can replicate this functionality by just sticking the sender into the first twenty bytes of the call data. However, this would mean that code would need to be specially compiled for delegated contracts, and would not be usable in delegated and raw contexts at the same time. Citation Please cite this document as: Vitalik Buterin (@vbuterin), "EIP-7: DELEGATECALL," Ethereum Improvement Proposals, no. 7, November 2015. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-7. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational Standards Track: Core EIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY Authors Christian Reitwiessner <chris@ethereum.org> Created 2017-02-13 Table of Contents Simple Summary Abstract Motivation Specification Rationale Backwards Compatibility Test Cases Implementation Copyright Simple Summary A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible. Abstract Please see summary. Motivation In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to compute only the size. All of these mechanisms, though, are very expensive in at least some situations. A very useful example of such a worst-case situation is a generic forwarding contract; a contract that takes call data, potentially makes some checks and then forwards it as is to another contract. The return data should of course be transferred in a similar way to the original caller. Since the contract is generic and does not know about the contract it calls, there is no way to determine the size of the output without adapting the called contract accordingly or trying a logarithmic number of calls. Compiler implementors are advised to reserve a zero-length area for return data if the size of the return data is unknown before the call and then use RETURNDATACOPY in conjunction with RETURNDATASIZE to actually retrieve the data. Note that this proposal also makes the EIP that proposes to allow to return data in case of an intentional state reversion (EIP-140) much more useful. Since the size of the failure data might be larger than the regular return data (or even unknown), it is possible to retrieve the failure data after the CALL opcode has signalled a failure, even if the regular output area is not large enough to hold the data. Specification If block.number >= BYZANTIUM_FORK_BLKNUM, add two new opcodes and amend the semantics of any opcode that creates a new call frame (like CALL, CREATE, DELEGATECALL, …) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new internal buffer of variable size, called the return data buffer. This buffer is created empty for each new call frame. Upon executing any call-like opcode, the buffer is cleared (its size is set to zero). After executing a call-like opcode, the complete return data (or failure data, see EIP-140) of the call is stored in the return data buffer (of the caller), and its size changed accordingly. As an exception, CREATE and CREATE2 are considered to return the empty buffer in the success case and the failure data in the failure case. If the call-like opcode is executed but does not really instantiate a call frame (for example due to insufficient funds for a value transfer or if the called contract does not exist), the return data buffer is empty. As an optimization, it is possible to share the return data buffer across call frames because at most one will be non-empty at any time. RETURNDATASIZE: 0x3d Pushes the size of the return data buffer onto the stack. Gas costs: 2 (same as CALLDATASIZE) RETURNDATACOPY: 0x3e This opcode has similar semantics to CALLDATACOPY, but instead of copying data from the call data, it copies data from the return data buffer. Furthermore, accessing the return data buffer beyond its size results in a failure; i.e. if start + length overflows or results in a value larger than RETURNDATASIZE, the current call stops in an out-of-gas condition. In particular, reading 0 bytes from the end of the buffer will read 0 bytes; reading 0 bytes from one-byte out of the buffer causes an exception. Gas costs: 3 + 3 * ceil(amount  32) (same as CALLDATACOPY) Rationale Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify (58). Since this proposal is very similar to the way calldata is handled, it fits nicely into the concept. Furthermore, the eWASM architecture already handles return data in exactly the same way. Note that the EVM implementation needs to keep the return data until the next call or the return from the current call. Since this resource was already paid for as part of the memory of the callee, it should not be a problem. Implementations may either choose to keep the full memory of the callee alive until the next call or copy only the return data to a special memory area. Keeping the memory of the callee until the next call-like opcode does not increase the peak memory usage in the following sense; any memory allocation in the caller's frame that happens after the return from the call can be moved before the call without a change in gas costs, but will add this allocation to the peak allocation. The number values of the opcodes were allocated in the same nibble block that also contains CALLDATASIZE and CALLDATACOPY. Backwards Compatibility This proposal introduces two new opcodes and stays fully backwards compatible apart from that. Test Cases Implementation Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: Christian Reitwiessner <chris@ethereum.org>, "EIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY," Ethereum Improvement Proposals, no. 211, February 2017. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-211. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.Ethereum Improvement Proposals All Core Networking Interface ERC Meta Informational Standards Track: Core EIP-3855: PUSH0 instruction Introduce a new instruction which pushes the constant value 0 onto the stack Authors Alex Beregszaszi (@axic), Hugo De la cruz (@hugo-dc), Paweł Bylica (@chfast) Created 2021-02-19 Table of Contents Abstract Motivation Specification Rationale Gas cost Opcode Backwards Compatibility Test Cases Security Considerations Copyright Abstract Introduce the PUSH0 (0x5f) instruction, which pushes the constant value 0 onto the stack. Motivation Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters of CALLs, which are set to zeroes in case the contract prefers using RETURNDATA*. This is only one example, but there are many other reasons why a contract would need to push a zero value. They can achieve that today by PUSH1 0, which costs 3 gas at runtime, and is encoded as two bytes which means 2 * 200 gas deployment cost. Because of the overall cost many try to use various other instructions to achieve the same effect. Common examples include PC, MSIZE, CALLDATASIZE, RETURNDATASIZE, CODESIZE, CALLVALUE, and SELFBALANCE. Some of these cost only 2 gas and are a single byte long, but their value can depend on the context. We have conducted an analysis on Mainnet (block ranges 8,567,259…8,582,058 and 12,205,970…12,817,405), and ~11.5% of all the PUSH* instructions executed push a value of zero. The main motivations for this change include: Reducing contract code size. Reducing the risk of contracts (mis)using various instructions as an optimisation measure. Repricingchanging those instructions can be more risky. Reduce the need to use DUP instructions for duplicating zeroes. To put the "waste" into perspective, across existing accounts 340,557,331 bytes are wasted on PUSH1 00 instructions, which means 68,111,466,200 gas was spent to deploy them. In practice a lot of these accounts share identical bytecode with others, so their total stored size in clients is lower, however the deploy time cost must have been paid nevertheless. An example for 2) is changing the behaviour of RETURNDATASIZE such that it may not be guaranteed to be zero at the beginning of the call frame. Specification The instruction PUSH0 is introduced at 0x5f. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (aka base). Rationale Gas cost The base gas cost is used for instructions which place constant values onto the stack, such as ADDRESS, ORIGIN, and so forth. Opcode 0x5f means it is in a "contiguous" space with the rest of the PUSH implementations and potentially could share the implementation. Backwards Compatibility This EIP introduces a new opcode which did not exists previously. Already deployed contracts using this opcode could change their behaviour after this EIP. Test Cases 5F – successful execution, stack consist of a single item, set to zero 5F5F..5F (1024 times) – successful execution, stack consists of 1024 items, all set to zero 5F5F..5F (1025 times) – execution aborts due to out of stack Security Considerations The authors are not aware of any impact on security. Note that jumpdest-analysis is unaffected, as PUSH0 has no immediate data bytes. Copyright Copyright and related rights waived via CC0. Citation Please cite this document as: Alex Beregszaszi (@axic), Hugo De la cruz (@hugo-dc), Paweł Bylica (@chfast), "EIP-3855: PUSH0 instruction," Ethereum Improvement Proposals, no. 3855, February 2021. [Online serial]. Available: https:eips.ethereum.orgEIPSeip-3855. Ethereum Improvement Proposals Ethereum Improvement Proposals ethereumEIPs Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, such as core protocol specifications.*/