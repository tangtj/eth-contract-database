
// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/token/ERC721/ERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)

pragma solidity ^0.8.0;

import "./IERC721.sol";
import "./IERC721Receiver.sol";
import "./extensions/IERC721Metadata.sol";
import "../../utils/Address.sol";
import "../../utils/Context.sol";
import "../../utils/Strings.sol";
import "../../utils/introspection/ERC165.sol";

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(
        address owner
    ) public view virtual override returns (uint256) {
        require(
            owner != address(0),
            "ERC721: address zero is not a valid owner"
        );
        return _balances[owner];
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(
        uint256 tokenId
    ) public view virtual override returns (address) {
        address owner = _ownerOf(tokenId);
        require(owner != address(0), "ERC721: invalid token ID");
        return owner;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(
        uint256 tokenId
    ) public view virtual override returns (string memory) {
        _requireMinted(tokenId);

        string memory baseURI = _baseURI();
        return
            bytes(baseURI).length > 0
                ? string(abi.encodePacked(baseURI, tokenId.toString()))
                : "";
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not token owner or approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(
        uint256 tokenId
    ) public view virtual override returns (address) {
        _requireMinted(tokenId);

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(
        address operator,
        bool approved
    ) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(
        address owner,
        address operator
    ) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        //solhint-disable-next-line max-line-length
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "ERC721: caller is not token owner or approved"
        );

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public virtual override {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "ERC721: caller is not token owner or approved"
        );
        _safeTransfer(from, to, tokenId, data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(
            _checkOnERC721Received(from, to, tokenId, data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
     */
    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
        return _owners[tokenId];
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(
        address spender,
        uint256 tokenId
    ) internal view virtual returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner ||
            isApprovedForAll(owner, spender) ||
            getApproved(tokenId) == spender);
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId, 1);

        // Check that tokenId was not minted by `_beforeTokenTransfer` hook
        require(!_exists(tokenId), "ERC721: token already minted");

        unchecked {
            // Will not overflow unless all 2**256 token ids are minted to the same owner.
            // Given that tokens are minted one by one, it is impossible in practice that
            // this ever happens. Might change if we allow batch minting.
            // The ERC fails to describe this case.
            _balances[to] += 1;
        }

        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId, 1);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     * This is an internal function that does not check if the sender is authorized to operate on the token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId, 1);

        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
        owner = ERC721.ownerOf(tokenId);

        // Clear approvals
        delete _tokenApprovals[tokenId];

        unchecked {
            // Cannot overflow, as that would require more tokens to be burned/transferred
            // out than the owner initially received through minting and transferring in.
            _balances[owner] -= 1;
        }
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId, 1);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(
            ERC721.ownerOf(tokenId) == from,
            "ERC721: transfer from incorrect owner"
        );
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId, 1);

        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
        require(
            ERC721.ownerOf(tokenId) == from,
            "ERC721: transfer from incorrect owner"
        );

        // Clear approvals from the previous owner
        delete _tokenApprovals[tokenId];

        unchecked {
            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
            // `from`'s balance is the number of token held, which is at least one before the current
            // transfer.
            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
            // all 2**256 token ids to be minted, which in practice is impossible.
            _balances[from] -= 1;
            _balances[to] += 1;
        }
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId, 1);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits an {Approval} event.
     */
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Reverts if the `tokenId` has not been minted yet.
     */
    function _requireMinted(uint256 tokenId) internal view virtual {
        require(_exists(tokenId), "ERC721: invalid token ID");
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) private returns (bool) {
        if (to.isContract()) {
            try
                IERC721Receiver(to).onERC721Received(
                    _msgSender(),
                    from,
                    tokenId,
                    data
                )
            returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert(
                        "ERC721: transfer to non ERC721Receiver implementer"
                    );
                } else {
                    /// @solidity memory-safe-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
     * - When `from` is zero, the tokens will be minted for `to`.
     * - When `to` is zero, ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual {}

    /**
     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
     * - When `from` is zero, the tokens were minted for `to`.
     * - When `to` is zero, ``from``'s tokens were burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual {}

    /**
     * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
     *
     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant
     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such
     * that `ownerOf(tokenId)` is `a`.
     */
    // solhint-disable-next-line func-name-mixedcase
    function __unsafe_increaseBalance(
        address account,
        uint256 amount
    ) internal {
        _balances[account] += amount;
    }
}


// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: @openzeppelin/contracts/utils/Base64.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides a set of functions to operate with Base64 strings.
 *
 * _Available since v4.5._
 */
library Base64 {
    /**
     * @dev Base64 Encoding/Decoding Table
     */
    string internal constant _TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /**
     * @dev Converts a `bytes` to its Bytes64 `string` representation.
     */
    function encode(bytes memory data) internal pure returns (string memory) {
        /**
         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence
         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol
         */
        if (data.length == 0) return "";

        // Loads the table into memory
        string memory table = _TABLE;

        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter
        // and split into 4 numbers of 6 bits.
        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up
        // - `data.length + 2`  -> Round up
        // - `/ 3`              -> Number of 3-bytes chunks
        // - `4 *`              -> 4 characters for each chunk
        string memory result = new string(4 * ((data.length + 2) / 3));

        /// @solidity memory-safe-assembly
        assembly {
            // Prepare the lookup table (skip the first "length" byte)
            let tablePtr := add(table, 1)

            // Prepare result pointer, jump over length
            let resultPtr := add(result, 32)

            // Run over the input, 3 bytes at a time
            for {
                let dataPtr := data
                let endPtr := add(data, mload(data))
            } lt(dataPtr, endPtr) {

            } {
                // Advance 3 bytes
                dataPtr := add(dataPtr, 3)
                let input := mload(dataPtr)

                // To write each character, shift the 3 bytes (18 bits) chunk
                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
                // and apply logical AND with 0x3F which is the number of
                // the previous character in the ASCII table prior to the Base64 Table
                // The result is then added to the table to get the character to write,
                // and finally write it in the result pointer but with a left shift
                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits

                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance
            }

            // When data `bytes` is not exactly 3 bytes long
            // it is padded with `=` characters at the end
            switch mod(mload(data), 3)
            case 1 {
                mstore8(sub(resultPtr, 1), 0x3d)
                mstore8(sub(resultPtr, 2), 0x3d)
            }
            case 2 {
                mstore8(sub(resultPtr, 1), 0x3d)
            }
        }

        return result;
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)

pragma solidity ^0.8.0;

/**
 * @dev These functions deal with verification of Merkle Tree proofs.
 *
 * The tree and the proofs can be generated using our
 * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].
 * You will find a quickstart guide in the readme.
 *
 * WARNING: You should avoid using leaf values that are 64 bytes long prior to
 * hashing, or use a hash function other than keccak256 for hashing leaves.
 * This is because the concatenation of a sorted pair of internal nodes in
 * the merkle tree could be reinterpreted as a leaf value.
 * OpenZeppelin's JavaScript library generates merkle trees that are safe
 * against this attack out of the box.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    /**
     * @dev Calldata version of {verify}
     *
     * _Available since v4.7._
     */
    function verifyCalldata(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProofCalldata(proof, leaf) == root;
    }

    /**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs & pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Calldata version of {processProof}
     *
     * _Available since v4.7._
     */
    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by
     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function multiProofVerify(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProof(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Calldata version of {multiProofVerify}
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function multiProofVerifyCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProofCalldata(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction
     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another
     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false
     * respectively.
     *
     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree
     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the
     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).
     *
     * _Available since v4.7._
     */
    function processMultiProof(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    /**
     * @dev Calldata version of {processMultiProof}.
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function processMultiProofCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: @openzeppelin/contracts/utils/math/Math.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}


// File: @openzeppelin/contracts/utils/Strings.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

import "./math/Math.sol";

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}


// File: contracts/Assets.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.21;

import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./ENSResolver.sol";

contract Assets is Ownable {
    ENSResolver _ensResolver;
    using Strings for uint256;
    using Strings for uint32;

    bytes public constant header =
        "' width='100%' height='100%'><style>.sa {} .sb { animation: sx 130ms ease-out alternate infinite; } .sc { animation: sx 200ms ease-in alternate infinite; } .sd { animation: sx 271ms ease-out alternate infinite; } .se { animation: sx 450ms ease-in alternate infinite; } .sf { animation: sx 682ms ease-out alternate infinite; } .sg { animation: sx 849ms ease-in alternate infinite; } .sh { animation: sx 1000ms ease-out alternate infinite; } .si { animation: sx 1470ms ease-in alternate infinite; } .sj { animation: sy 50ms ease-in alternate infinite; } .sk { animation: sy 152ms ease-in alternate infinite; } .sl { animation: sy 271ms ease-in alternate infinite; } .sm { animation: sy 450ms ease-in alternate infinite; } .sn { animation: sy 682ms ease-in alternate infinite; } .so { animation: sy 849ms ease-in alternate infinite; } .sp { animation: sy 1000ms ease-out alternate infinite; } .s {transform-origin: center;transform-box: fill-box;} @keyframes sx { from { transform: translateX(-1px); } to { transform: translateX(1px); } } @keyframes sy { from { transform: translateY(-1px); } to { transform: translateY(1px); } }.a0 { animation: pulse 5.2s infinite alternate-reverse; } .a1 { animation: pulse 0.8s infinite reverse; } .a2 { animation: pulse 1.7s infinite alternate-reverse; } .a3 { animation: pulse 2.5s infinite alternate-reverse; } .a4 { animation: pulse 1.3s infinite alternate-reverse; } .a5 { animation: pulse 2s infinite alternate-reverse; } .a6 { animation: pulse 4.1s infinite alternate-reverse; } .a7 { animation: pulse 3.7s infinite alternate-reverse; } @keyframes pulse { 0% { r: 20; } 20% { r: 10; } 40% { r: 30; } 60% { r: 10; } 80% { r: 30; } 100% { r: 20; } } .g0 { animation: fade 100s infinite alternate-reverse; } .g1 { animation: fade 0.5s infinite alternate-reverse; } .g2 { animation: fade 1s infinite alternate-reverse; } .g3 { animation: fade 2s infinite alternate-reverse; } .g4 { animation: fade 5s infinite alternate-reverse; } .g5 { animation: fade 10s infinite alternate-reverse; } .g6 { animation: fade 20s infinite alternate-reverse; } .g7 { animation: fade 23s infinite alternate-reverse; } @keyframes fade { 0% { opacity: 0.8; } 20% { opacity: 0.4; } 40% { opacity: 0.6; } 60% { opacity: 0.1; } 80% { opacity: 0.6; } 100% { opacity: 0.8; } } #r { filter: url(#blur); } @media (max-width: 384px) { #r { filter: none; } @keyframes fade {} @keyframes pulse {} }</style><defs><filter id='blur' y='-40%' x='-40%' width='180%' height='180%'> <feGaussianBlur stdDeviation='0. '/></filter><filter id='pb'> <feGaussianBlur stdDeviation='40' /> </filter><filter id='a' y='-100%' x='-100%' width='400%' height='400%'> <feGaussianBlur stdDeviation='5' /> </filter> <filter id='g' y='-100%' x='-100%' width='400%' height='400%'> <feGaussianBlur stdDeviation='10' /> </filter><circle id='a0' r='20' fill='transparent' filter='url(#a)' class='a0' stroke-width='10px'/><circle id='a1' r='20' fill='transparent' filter='url(#a)' class='a1' stroke-width='10px'/> <circle id='a2' r='20' fill='transparent' filter='url(#a)' class='a2' stroke-width='10px'/> <circle id='a3' r='20' fill='transparent' filter='url(#a)' class='a3' stroke-width='10px'/> <circle id='a4' r='20' fill='transparent' filter='url(#a)' class='a4' stroke-width='10px'/> <circle id='a5' r='20' fill='transparent' filter='url(#a)' class='a5' stroke-width='10px'/> <circle id='a6' r='20' fill='transparent' filter='url(#a)' class='a6' stroke-width='10px'/> <circle id='a7' r='20' fill='transparent' filter='url(#a)' class='a7' stroke-width='10px'/><circle r='40' id='g0' filter='url(#g)' class='g0'/><circle r='40' id='g1' filter='url(#g)' class='g1'/> <circle r='40' id='g2' filter='url(#g)' class='g2'/> <circle r='40' id='g3' filter='url(#g)' class='g3'/> <circle r='40' id='g4' filter='url(#g)' class='g4'/> <circle r='40' id='g5' filter='url(#g)' class='g5'/> <circle r='40' id='g6' filter='url(#g)' class='g6'/> <circle r='40' id='g7' filter='url(#g)' class='g7'/></defs><rect x='-30000' y='-30000' width='100000' height='100000' fill='black' />";

    bytes public constant path1 =
        "<path d='M 20000 20000 l -440 0 l 0 -880 l 1320 0 l 0 1760 l -2200 0 l 0 -2640 l 3080 0 l 0 3520 l -3960 0 l 0 -4400 l 4840 0 l 0 5280 l -5720 0 l 0 -6160 l 6600 0 l 0 7040 l -7480 0 l 0 -7920 l 8360 0 l 0 8800 l -9240 0 l 0 -9680 l 10120 0 l 0 10560 l -11000 0 l 0 -11440 l 11880 0 l 0 12320 l -12760 0 l 0 -13200 l 13640 0 l 0 14080 l -14520 0 l 0 -14960 l 15400 0 l 0 15840 l -16280 0 l 0 -16720 l 17160 0 l 0 17600 l -18040 0 l 0 -18480 l 18920 0 l 0 19360 l -19800 0 l 0 -20240 l 20680 0 l 0 21120 l -21560 0 l 0 -22000 l 22440 0 l 0 22880 l -23320 0 l 0 -23760 l 24200 0 l 0 24640' stroke='hsl(";
    bytes public constant path2 = ",";
    bytes public constant path3 = "%,";
    bytes public constant path4 = "%)' transform='rotate(";
    bytes public constant path5 =
        ", 20000, 20000)' filter='url(#pb)' fill='transparent' stroke-width='150px'/>";

    bytes constant colors =
        "5A7043220F246B715085CD47E1DFDBE0C1EBCDAA89F14037242424090B0AFEFBFB454054949593BED1B2F7F5E9CCD0C8953FCAD3F971F3F3E7ACC8F11A1E1E7DF830B823A47972792A2922591236281C3B24150F262E23658859212231B6A5775B2F2F1111555038DCF8D5D3828ABAADEBC4DC555018130C3AB6445B0BB735551B52492E792F44978F30BFCFBF5D5627A8F0EC322F061F1E19752791350F0D0E100A0B100489484E887235152D22FFFAFC97A432B5A15E4E3C36BD7A7A98B587D1F96CBDC3D004273973493AA298161D2306C2EEFE171212938666F6FEF6CC2A1462ED1DECCDC1C0C596C5C2BF771390283248B386847A746615141AFEFCFAC18D8B928F3A7376198E1E1A1B1109040506C0AF7C5F5397092F49615562314442F9F2FC8A651492FC9C8651464637342C2B17434B51263324726C7ACDBCBC41156F7E7C72E3DCE581724688116086A2E47D2E2B2D1F0133559EDF9D727EA53B6F0652EADDC8E1F6234BE78CF6EAF21D2522F2F8A0251D0418AF899CAB6DD9265C36246BFDFFFAFDE2D37C7850B040694F52426F5CF0656567BEC32C08361ADBDFCD6A583EE1ECDAF8CECFE2E2C6ACDE17F4F4BE202428C3D5C44494191A1414FCE4E8E45349D0CC955259121C2C3B1A1820211D2A596921DEDCF9736045B1803E20221B4E7365205A79D3CAFCC2568587737ABD924CE5E6E54A4B4F93F695BE63BF3135541A181B1A14151E3617321D1A68636E8B416735565AF5FAFFA197BE220906FEE7BE1E193EF3B4CF32302A64606C23240F2512045D745E454A47B4703C21192AF1FDF4156F32191415269230994D70EB759EF2AC922A40266331507D5E1C30181C441109FAFDE3A0A48ECD5B18380600533249C09B967D821CCCDDEB90726AB8D5A478594F251E042E2B297ACA681A1A1EFAE8E5919A796963693E302E798047141504122A0EDFFBE9191A198271C6272636FBB6DDC9CACA388005EBF3CD556742E9D8E1D14C3D8450910E0D11746C20AABB96C24BD86315135346493C4572CAC72196874F84525DE179092C2A51FBFBF8D0C5B43AE494695D682A132438410B158E44090807080623403E3A4354302A1E2396958D2B330AE9CF5850B2C3AA8964747274B8B8A3DE21962A7321ADC6905058460E070C336980338D02827B30C0CC8553466DD9E6CBFD26FD13073113131B2F1E0F201E1EE0DBB26BC78B171216F3F7F5C7CFBA190F1FE8CC593B3411E2EEEBC0C5C846F681100F0A1B082133576657385C87AAB5C2BFAD2E35276A535B3A383EA8A280201D1D070B04130D06EF348E400F0D8D2A111B090CB98ADBE9DAF6AE9F7A550675B3C22E455ABA3E20649AA29C4F567DC8D0F4D5D6D72815281611040E161584828C26252835462A20272D8F66660EAFB4EFE6B9C983C51B281AE3F6FC530E4479819A751E7BFAFDE2524C509DA9759FA2A3FA947AA0A17DC8B9B67A8A9F09110B2B1203DAF6C18E908FEDE9E8E3DDE3423F294D3C19F2B39CF2F7C5E6F2ABD8FDE703453DEEF4FB0DA5316F4294B49941EF9A80DEE292CBFDC9071C22E5E7E4382541F2F3C357387058405E1B2720F3F2F23214108A4F0F94FA611698256B8CB3A09779B38AC7D619EB2577B10D0708BFD5A448671E524642739136A47151BA8C9541433D231E1BEBFCE8232523959D80C6FEB828373EDF30730A06086A4E259F3C552620CFF1D9F784DF16D5EC658BFEAD2B0D1CB0A58D2B77974A07234B883F7D695EF684A2291E23C75B5287754F98A9A41A1F196143192625184C4C4C3B3202C8E1BCE8D3E6EBFDB4C0C242142422F7F7FC135346CBBAF713120C5047447C3E2DF4E4DCD2DECADA8F3E707B322729302E1B142E0A12ABF2EA7B515B901B04B781521A1A1A550714F6EFF27B78BF89989FDE8F4F5CA60CF2C0E6A0AAB1FE342A2C8776F7C3C0271C0716220CEFE9E6A8EE7C2D34331F180FB36B6EA6C3923C552B919D6C77CF4FF0CBC63F523D0D3C40D5D4D9777A75572759725937322C24125E39DFC8EAEDDEE63A2C170DE7A2523249CBA952B096873F2A27A6DE8C635C70AB7259F7FEEC15140AD9D8D909C1C8FCFDFC4234248D5BA443382D040103987D3EBCE5EB030704CEF8DFD8F4069BA3807F92FA505E52862004131006231A1DF6FCCF805ABA060604FCE9DFC17957B85BC8021426A86E6127162197AFF76364AB97D8ACF3EFD3654362BB027D303126231E24C06B5D67EFE18D49538050232B1725CA2ADF91B36B6248473749080386840F13060A414DD0D4B5540E081F1E1E5C2838454903CD9E9D268C2BD9ECCB242225D87B5F7D2A176D6F3E6A4734EBD4B7FBF4BC2A36411C0F0DEDE9A1686B47CECB69253909512A3FFDFDFC6A8A7921ABA27D491C2D2A2BCC7161D1EBDE0CCBE4F736EA1E1E2F03016F383932F8D3F12D6907C1A9B1EF7BC1BB3A4DECFEEC5D6F2F48B04521355E56E52EB5DF537A5761FAD1F8FE7D721B271BD5A090EDE3D9543C21F8F7AFE0D6B3131201E7E8E3F9DDDC7D29C7F42ABB36430A3A5659E6B9945797A8E6EDB0050901101519A9523DA6987D5D1A14CDBCB1FFFAFE3B453CB85656CBCBA46F4D662759506B1F41706E6B2E3747AC402AEBE6E0D583DD0B3003CDC8C60A0900FE8F9C87684FBD862E51115579676C55511B0A5C2C6A1B2E3B4E4F130835969795B0C9C9DE79E23838382D56954E543BFCC05A1C261DAAA7AA98B9C32631501BD006233C6C604270B57898273E4FF3BB95744E5D13A034E2C28D937B39AE9EAA042525CCD9DB4437084C4D4DC878ED0F0E014818492D152BDDD5DAD9E3DF666065FBF4F70B3D2493C2D7B88FBC4A6E308783732223254B4716D5CCD764970C16040451435BEC5BB949FD499560045B20390604044C2F75173F1A232F2DEEA5A63B392BFAF1E5D7DCE0493C31040606584F720E2520D487404C500CF6F8F15F5D3529271EA69B7D233270E3DED8938E7BD699C5D1D2D1B0B0ABE5E2E12A1409684E27463B4ED5DCBC2435381B1819EFF4DC5EBBEDB1B578F5FD531802972C2024F2B21C424B07A59978B4B3B16D6B701A1919A88D67050B1A1C111CA8ABA65B73029AE1376E8B8C37390A0C080815787F5A32764422360C1336B5EF763D1F101B0E1575D1BAA7C3748A1E4F46331B393B3C65467C1C1A03147FEBC4A0921A1B0D1D9202AC615D374D28E4DFD2414862D6C20A3E1E22282B2FFEB19A02C1E314333E1F1F1FFE534DEFE1ECDF68431D1B1D02550E525516E1AC41193638FC4FFCB9B192E7D5D91C1C27BF8C6E4C6EDC23A7D7A6A8679A2D2D24C4F958AF50C1F4F6133149FCF4F3D1DDD0102315D5878506322A071A40E3F2EA4D44F81227910A0506492D42775B325EA4C50E16104A5C5EC0C4AB4936095729450D120F31312F5EEDBE334F0CC5C15974390241348323200198FBE7520A3F343441D8D4B1CBC3CA524A82D0EDF0FDFBF7617568C68D71704D48625309FEE1E238511A7A6C1A745707B76501D8DDD5834425F7F4F3FA6BBE1A1B1E54594535536EDBC2DB0506053D492D2C30173B3F31BCB8B85B575C9477F3FCF9F8383F51F0BDB7888F381D1A3CC1A9A46C56996B6D0D7F381584BF63307E47B6F254425D32403460474C3D5A7C90606C763F3D3BD5A77CD0F547DDA2A76F979B1B132FF6F6EED2CED9DBFAF6103225C8C1C710140A504B071F0505F5F5F52B07364B362AF8F2ED752EFADDB6981D1911C2C0B79DD382B37B7A48453D2E231ED00E0BA7767EF0F2F5E8FCEA79F1997DD2329F9D092F6E79A8866B9C89731209342E37251E1E20BEBFBBD7E0E08A5C74321125541E0783839114102309294EEAC7BD223404272C21695E73AFB5CB1C0E0D7A6C5268743401AD204D55205E44D5221E2AEF01C7141010DADBD23C59DD586C3DBB869A88FB8C998BA73E580ED07C6DB2BF82F4F6DFC0C794C9B49C5CAD5E3A0F08C3BAA2BBAAB6E2AF9814663CCE704094927F19482F9401016D601CABA39CCECCB612080B4898A3392C28A2A49DE561C26986B0671D64F9E6104EBFE4535ADFB79B801B9AE4241F1E3BDE77305C146CBA0DFAFDF7DBD361A28B90C4A3400401130E1415211F1C38434DA6A0C0464544282C07292433E1EAD70F0C0ABED5C92D2D063F100D090606B299A556573DC8CB1A1412107045425D781269F14BC8C0D32622089CF362A380A2B7BCAE18342B7E92AE9F3B09B25C53F4F9C82020278C65217B9664E4D0E75E6378B90E55B4F49F4B8676241414756B619E8D4C50982A1F3D2132232083D8A36481960C1311B270A34C503A4D9979D6D9D3AB98B30E110D1A2322DFFDDD211F2851102FFCF6F24A50448BAA5A221F231B37373366378A7A4CC4A6B89F9989193E392F28332B4C24248A3344E4612A1003F4F6E42423234B4A4FAF4608702A92CF07DA595572C4BFCA2C2C2567287134048634389D95665B3911400F241B8B5B6D50832002C508312411A3051DC6535E070D0D2F2E2DEBD9522C21261A2F0AE4E6F7F5EED64B240125556520E9DC15150FB4AC9C1B2216E7E6E44413131D0C104D5E31580604EAC3BDC0B468573854E2AC182F0404D3DBCDFCF7FBC6422423231FF2D57DD5816CF8FBE0281939B078BF3B2E26A98E9A5F2D0C0309113F6B065C7138B3C2930D6A6ECBE5E78552A3877F5A4B4949DE2B171512171B092AFFFAFA472E35B1D55D2D1A22ED317FC2DD92B877F9DDDDDA072C166466E86118689B68084B2F25A77295583C3E3E1A42F8EFED1910163E299E14130BCBD4C47D7454120F15040401F4FAF97A9419B1A0A4FB74941F2123E6F68EC8E1ADBFABB257480A5B4958757575DC18C5839169805267232716D3DEA05A6D5CC3C1C1FEFEF61E1F1F5855B4C1A7CD568A89665B4DF8A130C0EA1A7DAEF73AD99CC3B713D5B59A060901BDA72E2C2621E557AA13160E3976C0998F8AAAAD8A442E2C0A0D08B5E6141E201369744E6219E1B3ABCFB5A469302108143839163E460F2A0EE6D9D5B590690CC6A085AC110A0805F4BF1FEBED9CA6E7FC826A4F0708094D454284C5300308020B3D478FE699F2647ED9DAD809200E4912734D14145A6BAF1534371A434742461B8FD0FEF7F6F27C8F705F6EB9E9FDBAF2F0F5D3DEDE1E8F8F384229912F2717271EDED3DB4636254319CC4C76AE25242817A5DE382C1A53680DBF63AFFDF8F21E6EA43DDA2FF2F4E7C3FED0505C47FFCCE2ACADA9E2BC9DF8FCFB958391BBDFF6D283AD553A5364574A7B4804264A470B0B09B8FD96FECD716CA94C8444ABFBF1DA0D0709F6FFF0587479CECAD8E2C3C0DBDAD68888869FC2898D8168E6DDDBCEB2976E6F25D1E8738D8777593960292829A5E755244922D1AB2EF5FAF7FBFCFEC0C1BD1F201DF6B1C98E2981495110CBD0BE282F29B9AC8315664C2719169EA38A1E120BF96E0B0A0800D2914BFCF9F7494059A199974729572B3A1D4D4F51C1391AE1DED0133BAAB7B8B2783917253725092439343746BDC0AA5284487407329D86C1577A67362E2BCDCDCBBEB69D1A0524B44B5462403C2A2928A38F620B0C0F3C4338272716401F036E5F72938885D8C7AB475A3F801955CFF2DC35272DA49F1EFBF9F9182F59FDF6F25C4A42FA9542F2DAB1191A044F1E1CE43B253540300D233068A3DF1B090FFAEEE141B9E14B1802826559FBE3A21B22212644135E8D753D340A1C12157754188BA159050500C1A95376566A63BB54094549242729471C0A91A966151A0AC6C2CB63671E08033F846EAF5272361B412EE5E4E14529024D4247ECEAE45E017ACD748F59632CF0EAF634322DC2BEBCC1A3C767745D363E44A1F7D6F6FDFC64E8D83C10132B375A3706140E140B6F5F2F959772F6E4C6D4CC3AF5D2BCCFD2EDE0E35FFAFFFF9F999A676665B386DAFAFAF94F421C342514D0D62E7E1616363536F56A192523222E75B813181B654815E9E32F680BF4B7C0CD4444363D1B0BB0A682FDFEE2969D62D1CBC7EFFA14202331161C1D614860F1DFE6282F19B9EF5D080807CEBF36AEEAD6986792342263BB40079F976FCEF7F5231B1E351308050506311736E7CBCC6EA1A672716E575352928FBD68086443B2CB87ACB0901B092B290D458C53879F32CAEAB81410140F0A0C121617C4E6ED382D3E561A1E0D0206FBF8FBC5E5A4451D1C4458EE7C4B4F0F0A10172117FC74592E2E2D5A3F4843F9C6CAA7963B44A09D93852D433CE49672C1E78417252C405D281D441EBFB1B067B1D59FBD93A59E93EDD3C5130D0B27271B8455AFFEED6C2D26240C1815202C17DCD1E5656B5B4B271B232F197BC05487534AE6DCF9A81CCE5A1B02FCF5DF5948AD371F34084C63E8EFD1345555F4C9C8B0B3A80D100A534145F15D3BAD9776434137A4754CC3B1C4F6816F9A2EA820F0191406011E222981785A26142E0803023F16A7E0D6AE5557144A520588D917556841EBE2C68B8527A7BEAF0B040A4E5638C9C2CB7A5C6E4F40499F6932CDE58A9898B31A0F054F260DFBF2DACCD1C7F9E39FDB6E66DF90B9A6CE7E66330A7B6C3DF5F5EF18191B8E8980F6B493272124CFFA9E531E76948B51958532090A05ECFE77B759D4B4D56D3F1C3B3C4368F4C5BD653E5BBD6593A55CB244132B4F4A081F1924D093E6537F7CEE1B7A95958E392E2855BB0C3E1909FDFDFB2A5549B9875523182A6B865F505D7726A68A04DC1E8C36879CBC62C7C0B8DFCDC8928649604639F6F6F32FA745181820262B2974FBE9F9EDE6E9EDDEF4FCCFB4816A3E2E1E191E298860A9120D0D46AF2CD47F77C153DF186781341E31E0F6EF8238304F4252E8642C56535219262AF6F4C1F2F532226B6D5B6A3E0B060F8F4E3DC6EFB8DADBDC3D3B344D16501D2125E2F8FE4363ADD8BF8DFEFBFE23BFCD1E1E25BDCB95090609CD64375B4033E3F6D5020F18FAF47F8477480B0406156A34796CA30B09107939721412171C4F472A28295F5C61616524F425E2663CAFFEFEFA513D2A260D23211B0DB2F362F45925604A3E184517072627DBD0EC852CA59C938B2815101A2C0295049F4C463D641F89D5AC394418192D2D34F3F8EDFBDF84560B1BFEFDFA79F74B50F26B3D49189D8B62232D01DDDCE536161C102D4CB4C7FDA5A79ABD884C303136585F25213E45272120BFBF6EA5273835323162603C1E11012E3E37F9F8F52F1824D889691D867330243D476D715100082D3937D9C7F4463851782411B3B99DACB0A0010909ECF0F334AD683C2816E8A09B090401F1FDDD3F7D51EEC7A539494C155B475F3A49C0BDC7AC8B62C0A47CC0E2D8444743E8D9A15B4E74B696A57F437F583A59AEAE0997DFF7F1E6E0405443F8F5F11B1319D9C9BF470B1A7A7A7AB86F47CF865EFEF5F0725B7B1B1028DBD8DF20515B93918A599613519480DBDF9FAAB6D42F60790A130789F01460206054595855473F1B19134D47763634378D8220ABF81B1E1122C2AC89FEEBFAA88DCE453D3A4B342F87C328C5677AAC3943FEECEFCFDF53B9ACA7694983767637BC27FC8E5D3E05040684434A3F9D695C6629972052A89BB573552BAB4F8BB05B27289613793899915D46E3B878252E195C2376D4F8C4BEAA7E2F1F38152629301F1C4FE60F1C2C23C7C6C73025174F8722F25602DEB71B372406AE5B94CAE9BAE8D71728053DAA9E502B247ABBB8AF544740D3E7C64545112328342635403E552A9C961CA75401B082A42C2721BAFC4F2E1815090B0B440D27D9C9D4DDDBDABF5D36EEE5A0D9F1888C73362A150E2E1F7A12424F4B625423570F2318342A1F18130E017576471F0C0A5158617DBF92B7CFD7DDEFB3AFCFC0A9F4C68B89892A22262F3121AD7BEA1BE4396F29709E7C0A185431F7F7F891756ED4E170481A19354755B090D51FEABE214A87B99E4BB41813D2F109F7EFDE31622D20312E9185EA19310D615842534036687E5D382906BDB7EBB7B157505747D8B1B7D98C9873CF63C7B3E0551B16B7BE9D541C2C1E32A413B995CBD7C6FBCFCBA43265514F4D000000F7F75EE5F5ED49458218060B9C7791442C17F5E4DB232E34982A71E5E5B8EC905B2AEFD596976DB8B9A2034868090C0BD8EFCDF1D5CB0804028C8E3E3A1D4E97CD7A0203038F9B828F6F0FB69AD064502B4D783F344026450D2C001A51CBD2D8466020F3EE49B6CBA9EEF2E3424B20D1D8CA4BDD663329424A4F4D77706985D945332A4609251264AC4D423F2E1F213D526F3EEAAF7BEB37C1A3A4FAE3E3E3904E478286567816F81B181A0F03006A5A96363635D4878A9F581E97996667570F241E1EC57D9E9F759C23247153232ED7E0C82A2A284BFBD8130D167D909B0A0C080C130F6F5A1F59E3D3D24B6FFCE8D412141609060754271283661B1F120EB3F29167645B2322010909065B1183F3EAD8E2657805E1C431634E49505A0F0D125958546866F0BBB29BF566CA26263BAC63BBC8464D403F88FAFDF6E0DFC71C271C949BB36388920B0A09779BB6ADCA07D99981FDFCF1D9BBFBBE98D278D9B2487F5EA296B0636444102D22A2E7C2ED8CF2E8DAB0E1E3D36A2A2A873231201622C1BBAEAA9FDFA6A3912D3A1D3637344A171E3E2F42BED5D5F7EDF5383633085B0157712D7DB351FAFAFAF8F7A0A964C45B6E861506419E76886A5629483149BD3A284F4940CEA1D332650BEAF6F1A40A5C2E282FFFFFFF000000";

    constructor(address ensResolver) {
        _ensResolver = ENSResolver(ensResolver);
    }

    function setENSResolver(address ensResolverAddress) external onlyOwner {
        _ensResolver = ENSResolver(ensResolverAddress);
    }

    function getColors() external pure returns (bytes memory) {
        return colors;
    }

    function getHeader() external pure returns (bytes memory) {
        return header;
    }

    function getPaths()
        external
        pure
        returns (
            bytes memory,
            bytes memory,
            bytes memory,
            bytes memory,
            bytes memory
        )
    {
        return (path1, path2, path3, path4, path5);
    }

    function metadataDetails(
        uint256 tokenIndex
    ) external pure returns (bytes memory) {
        bytes memory details = abi.encodePacked(
            '{"name":"Q #',
            tokenIndex.toString(),
            '", "description":"_Rivers know this: there is no hurry. We shall get there some day._ A.A. Milne","image":"data:image/svg+xml,'
        );

        return details;
    }

    function convertWallet(
        address wallet
    ) public view returns (string memory ensOrHex, bool didFallback) {
        (ensOrHex, didFallback) = _ensResolver.resolveWithFallback(wallet);
    }

    function metadataAttributes(
        uint256 peopleCount,
        uint256 zoomLevel,
        uint256 relativePosition,
        uint256 minQueueIndex,
        uint256 queueLength,
        uint256 updates,
        address wallet
    ) external view returns (bytes memory) {
        bytes memory subjectName;
        (string memory subject, ) = convertWallet(wallet);
        subjectName = bytes(subject);

        bytes memory attributes = abi.encodePacked(
            '","attributes":',
            '[{"trait_type":"Height","value":"',
            zoomLevel.toString(),
            '"},{"display_type": "number", "trait_type":"Position, Absolute","value":',
            (relativePosition + minQueueIndex).toString(),
            '},{"display_type": "number", "trait_type":"Position, Relative","value":',
            (relativePosition).toString(),
            '},{"trait_type":"Progress","value":"',
            minQueueIndex.toString()
        );
        attributes = abi.encodePacked(
            attributes,
            '"},{"trait_type":"Framed Blocks","value":"',
            peopleCount.toString(),
            '"},{"trait_type":"Updates","value":"',
            updates == 0 ? "Original" : updates.toString(),
            '"},{"trait_type":"Length","value":',
            (queueLength - minQueueIndex).toString(),
            '},{"trait_type":"Subject","value":"',
            subjectName,
            '"}]}'
        );

        return attributes;
    }

    function _increment(
        uint256 segmentLength,
        int256 tilt,
        int256 SQUARE_SIDE_MARGIN
    ) internal pure returns (int32 incrementX, int32 incrementY) {
        int256 direction = -(((int256(segmentLength) >> 1) & 1) << 1) + 1;
        int256 xDirection = int256((segmentLength) & 1) * direction;
        int256 yDirection = (1 - int256((segmentLength) & 1)) * direction;
        incrementX =
            int32(SQUARE_SIDE_MARGIN * xDirection) +
            int32(tilt * yDirection);
        incrementY =
            int32(SQUARE_SIDE_MARGIN * yDirection) +
            int32(tilt * -xDirection);
    }

    function _renderIteration(
        bytes memory buffer,
        uint256 count,
        uint256 minQueueIndex,
        uint160[4096] memory queue,
        int32 SQUARE_SIDE_MARGIN
    ) internal pure returns (bytes memory) {
        uint256 currentLength = 0;
        uint256 segmentLength = 0;

        int256 tilt = 0;
        uint256 tiltRound = 5;
        int32 lx = 0;
        int32 ly = 0;
        for (uint256 i = 0; i < count; ++i) {
            (int32 incrementX, int32 incrementY) = _increment(
                segmentLength,
                tilt,
                SQUARE_SIDE_MARGIN
            );

            lx += incrementX;
            ly += incrementY;
            if (currentLength == 0 && segmentLength % tiltRound == 4) {
                tilt += int256(uint256(queue[i + minQueueIndex] % 5));
                tiltRound += 1;
            }

            currentLength += 1;
            if (currentLength == segmentLength + 1 || i == count - 1) {
                buffer = abi.encodePacked(buffer, bytes(" l "));
                if (lx < 0) {
                    buffer = abi.encodePacked(buffer, bytes("-"));
                    lx = lx * -1;
                }
                buffer = abi.encodePacked(
                    buffer,
                    bytes(uint32(lx).toString()),
                    bytes(" ")
                );
                if (ly < 0) {
                    buffer = abi.encodePacked(buffer, bytes("-"));
                    ly = ly * -1;
                }
                buffer = abi.encodePacked(buffer, bytes(uint32(ly).toString()));
                lx = 0;
                ly = 0;
                currentLength = 0;
                segmentLength += 1;
            }
        }

        return buffer;
    }

    function renderFallback(
        uint256 minQueueIndex,
        uint256 count,
        uint160[4096] memory queue,
        uint256 WIDTH,
        uint256 HEIGHT,
        uint256 HALF_SQUARE_SIDE,
        uint256 SQUARE_SIDE,
        int32 SQUARE_SIDE_MARGIN
    ) external pure returns (bytes memory buffer) {
        int32 lx = int32(uint32((WIDTH >> 1) - HALF_SQUARE_SIDE));
        int32 ly = int32(uint32((HEIGHT >> 1) - HALF_SQUARE_SIDE));
        buffer = abi.encodePacked(
            bytes(
                "<path id='l' stroke='hsl(0,0%,65%)' fill='transparent' stroke-width='"
            ),
            bytes(SQUARE_SIDE.toString()),
            bytes("px' stroke-dasharray='"),
            bytes(SQUARE_SIDE.toString()),
            bytes("'  d='M "),
            bytes(uint32(lx).toString()),
            bytes(" "),
            bytes(uint32(ly).toString())
        );

        buffer = _renderIteration(
            buffer,
            count,
            minQueueIndex,
            queue,
            SQUARE_SIDE_MARGIN
        );

        buffer = abi.encodePacked(buffer, bytes("' />"));

        return buffer;
    }
}


// File: contracts/DynamicBuffer.sol
// SPDX-License-Identifier: MIT
// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)

pragma solidity 0.8.21;

/// @title DynamicBuffer
/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also
///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer
/// @notice This library is used to allocate a big amount of container memory
//          which will be subsequently filled without needing to reallocate
///         memory.
/// @dev First, allocate memory.
///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if
///      bounds checking is required.
library DynamicBuffer {
    /// @notice Allocates container space for the DynamicBuffer
    /// @param capacity_ The intended max amount of bytes in the buffer
    /// @return buffer The memory location of the buffer
    /// @dev Allocates `capacity_ + 0x60` bytes of space
    ///      The buffer array starts at the first container data position,
    ///      (i.e. `buffer = container + 0x20`)
    function allocate(
        uint256 capacity_
    ) internal pure returns (bytes memory buffer) {
        assembly {
            // Get next-free memory address
            let container := mload(0x40)

            // Allocate memory by setting a new next-free address
            {
                // Add 2 x 32 bytes in size for the two length fields
                // Add 32 bytes safety space for 32B chunked copy
                let size := add(capacity_, 0x60)
                let newNextFree := add(container, size)
                mstore(0x40, newNextFree)
            }

            // Set the correct container length
            {
                let length := add(capacity_, 0x40)
                mstore(container, length)
            }

            // The buffer starts at idx 1 in the container (0 is length)
            buffer := add(container, 0x20)

            // Init content with length 0
            mstore(buffer, 0)
        }

        return buffer;
    }

    /// @notice Appends data to buffer, and update buffer length
    /// @param buffer the buffer to append the data to
    /// @param data the data to append
    /// @dev Does not perform out-of-bound checks (container capacity)
    ///      for efficiency.
    function appendUnchecked(
        bytes memory buffer,
        bytes memory data
    ) internal pure {
        assembly {
            let length := mload(data)
            for {
                data := add(data, 0x20)
                let dataEnd := add(data, length)
                let copyTo := add(buffer, add(mload(buffer), 0x20))
            } lt(data, dataEnd) {
                data := add(data, 0x20)
                copyTo := add(copyTo, 0x20)
            } {
                // Copy 32B chunks from data to buffer.
                // This may read over data array boundaries and copy invalid
                // bytes, which doesn't matter in the end since we will
                // later set the correct buffer length, and have allocated an
                // additional word to avoid buffer overflow.
                mstore(copyTo, mload(data))
            }

            // Update buffer length
            mstore(buffer, add(mload(buffer), length))
        }
    }

    /// @notice Appends data to buffer, and update buffer length
    /// @param buffer the buffer to append the data to
    /// @param data the data to append
    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.
    function appendSafe(bytes memory buffer, bytes memory data) internal pure {
        checkOverflow(buffer, data.length);
        appendUnchecked(buffer, data);
    }

    /// @notice Appends data encoded as Base64 to buffer.
    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.
    /// @param noPadding Whether to strip away the padding.
    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.
    /// See: https://datatracker.ietf.org/doc/html/rfc4648
    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)
    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)
    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.
    function appendSafeBase64(
        bytes memory buffer,
        bytes memory data,
        bool fileSafe,
        bool noPadding
    ) internal pure {
        uint256 dataLength = data.length;

        if (data.length == 0) {
            return;
        }

        uint256 encodedLength;
        uint256 r;
        assembly {
            // For each 3 bytes block, we will have 4 bytes in the base64
            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.
            // The `shl(2, ...)` is equivalent to multiplying by 4.
            encodedLength := shl(2, div(add(dataLength, 2), 3))

            r := mod(dataLength, 3)
            if noPadding {
                // if r == 0 => no modification
                // if r == 1 => encodedLength -= 2
                // if r == 2 => encodedLength -= 1
                encodedLength := sub(
                    encodedLength,
                    add(iszero(iszero(r)), eq(r, 1))
                )
            }
        }

        checkOverflow(buffer, encodedLength);

        assembly {
            let nextFree := mload(0x40)

            // Store the table into the scratch space.
            // Offsetted by -1 byte so that the `mload` will load the character.
            // We will rewrite the free memory pointer at `0x40` later with
            // the allocated size.
            mstore(0x1f, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef")
            mstore(
                0x3f,
                sub(
                    "ghijklmnopqrstuvwxyz0123456789-_",
                    // The magic constant 0x0230 will translate "-_" + "+/".
                    mul(iszero(fileSafe), 0x0230)
                )
            )

            // Skip the first slot, which stores the length.
            let ptr := add(add(buffer, 0x20), mload(buffer))
            let end := add(data, dataLength)

            // Run over the input, 3 bytes at a time.
            // prettier-ignore
            // solhint-disable-next-line no-empty-blocks
            for {} 1 {} {
                    data := add(data, 3) // Advance 3 bytes.
                    let input := mload(data)

                    // Write 4 bytes. Optimized for fewer stack operations.
                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))
                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))
                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))
                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))
                    
                    ptr := add(ptr, 4) // Advance 4 bytes.
                    // prettier-ignore
                    if iszero(lt(data, end)) { break }
                }

            if iszero(noPadding) {
                // Offset `ptr` and pad with '='. We can simply write over the end.
                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.
                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.
            }

            mstore(buffer, add(mload(buffer), encodedLength))
            mstore(0x40, nextFree)
        }
    }

    /// @notice Returns the capacity of a given buffer.
    function capacity(bytes memory buffer) internal pure returns (uint256) {
        uint256 cap;
        assembly {
            cap := sub(mload(sub(buffer, 0x20)), 0x40)
        }
        return cap;
    }

    /// @notice Reverts if the buffer will overflow after appending a given
    /// number of bytes.
    function checkOverflow(
        bytes memory buffer,
        uint256 addedLength
    ) internal pure {
        uint256 cap = capacity(buffer);
        uint256 newLength = buffer.length + addedLength;
        if (cap < newLength) {
            revert("DynamicBuffer: Appending out of bounds.");
        }
    }
}


// File: contracts/ENSResolver.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.21;

import "@openzeppelin/contracts/utils/Strings.sol";

interface PublicResolver {
    function name(bytes32 node) external view returns (string memory);
}

interface ReverseRegistry {
    function node(address addr) external view returns (bytes32);
}

/// @title On-Chain ENS Resolution
/// @author Miragenesi
/// @notice Use this contract to resolve the ENS name of an address
contract ENSResolver {
    ReverseRegistry _reverseRegistry;
    PublicResolver _publicResolver;
    bytes32 constant DEFAULT_NAME = keccak256("reverse.ens.eth");
    bytes32 constant EMPTY_NAME = keccak256("");

    constructor(address reverseRegistry, address publicResolver) {
        _reverseRegistry = ReverseRegistry(reverseRegistry);
        _publicResolver = PublicResolver(publicResolver);
    }

    /**
     * Returns whatever is resolved for this address.
     * It might be the ENS name, empty or some default
     * result.
     * @param addr the requested address
     * @return ENS or 0x string of the requested address
     * @return always false;
     */
    function resolve(address addr) public view returns (string memory, bool) {
        return _resolve(addr, false);
    }

    /**
     * Returns the ENS of the given address, or the hex-string
     * version of the address if no ENS is associated to it.
     * @param addr the requested address
     * @return ENS or 0x string of the requested address
     * @return whether the string represents the ENS or the 0x-address
     */
    function resolveWithFallback(
        address addr
    ) public view returns (string memory, bool) {
        return _resolve(addr, true);
    }

    function _resolve(
        address addr,
        bool fall
    ) internal view returns (string memory name, bool didFallback) {
        if (
            address(_reverseRegistry) != address(0) &&
            address(_publicResolver) != address(0)
        ) {
            try _reverseRegistry.node(addr) returns (bytes32 node) {
                try _publicResolver.name(node) returns (string memory name_) {
                    name = name_;
                } catch (bytes memory) {}
            } catch (bytes memory) {}
        }

        if (fall) {
            bytes32 khash = keccak256(abi.encodePacked(name));
            if (khash == DEFAULT_NAME || khash == EMPTY_NAME) {
                name = Strings.toHexString(addr);
                didFallback = true;
            }
        }
    }
}


// File: contracts/Queue.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.21;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "./QueueRenderer.sol";

/**
######################### ##############################
########################     ###########################
####################### #####  #########################
#####################  ###    #   ######################
####################  ##  ####  ##   ###################
##################  ###  ##    #  ###  #################
#################  ##  ###  ###  ##  ##   ##############
################  ##  ##  ##    #  ##  ###   ###########
##############  ##  ##  ##  ##    #  ##   ##   #########
#############  ##  #  ##  ##  ##    #  ##   ###   ######
############ ##  #  ##  #  ##      #  #  ###  ####  ####
########### ## ##  #  #  #   #      ## ##  ###  ####   #
#########  #  #                     #  #  ##  ###   #### 
####  ## ## #    #  #                # ##  ##  #### ## #
###  #  #  #  ##  #  #   Queue     #  #  ## ###    ## ##
##  #  #  ###  ##  ## #   Wait    # #  #  #    #  #  ###
#  #  ####   ##  ##  #     Mint            # ## ##  ####
  #####  ###   ##  ##                    #  #  ## ######
##   ####   ###  ##  #      ##  #   #  #  ## ##  #######
#####  #####  ###  ##  # #   ##  ##  ## ##  ##  ########
#######   ####   ##  ##    ##  ##  ##  ##  ## ##########
##########   ####  ##  ##    ##  ##  ##  ##  ###########
#############   ###   ##  #    ##  ###  ##  ############
################   ###  ##  ####  ### ###  #############
###################  ###  ##    ###  ### ###############
######################  ###  ####  ###  ################
########################   ##     ###  #################
###########################   ######  ##################
##############################   #  ####################
#################################  #####################
 */

contract Queue is ERC721, Ownable, QueueRenderer {
    uint256 public mintBegin;
    uint256 public queueBegin;
    uint256 public startMintingFee;
    uint256 public priceIncrement;
    uint256 public currentToken = 1;

    bytes32 internal _root;
    uint256 internal _maxBlocksRich = 600;
    uint256 internal _maxBlocksPlain = 1300;
    uint256 internal constant DISCOUNTED = 85;

    mapping(uint256 => uint256) internal _tokenViews;

    constructor(
        string memory name,
        string memory symbol,
        uint256 mintBegin_,
        uint256 queueBegin_,
        uint256 startMintingFee_,
        uint256 priceIncrement_,
        address assets
    ) QueueRenderer(assets) ERC721(name, symbol) {
        mintBegin = mintBegin_;
        queueBegin = queueBegin_;
        startMintingFee = startMintingFee_;
        priceIncrement = priceIncrement_;
    }

    modifier mintClosed() {
        require(block.number < mintBegin, "mint begun");
        _;
    }

    modifier mintOpen() {
        require(block.number >= mintBegin, "mint closed");
        _;
    }

    modifier tradingActive() {
        require(
            currentToken >= queueLength ||
                block.number - mintBegin > queueLength,
            "trading not active"
        );
        _;
    }

    modifier mintInProgress() {
        require(block.number < mintBegin + queueLength, "mint ended");
        _;
    }

    // Admin

    function withdraw(address to) external onlyOwner {
        (bool success, ) = to.call{ value: address(this).balance }("");
        require(success, "fail");
    }

    function setRoot(bytes32 root) external onlyOwner {
        _root = root;
    }

    function setRenderingThresholds(
        uint256 maxBlocksRich_,
        uint256 maxBlocksPlain_
    ) external onlyOwner {
        _maxBlocksRich = maxBlocksRich_;
        _maxBlocksPlain = maxBlocksPlain_;
    }

    function setPrices(
        uint256 priceIncrement_,
        uint256 startMintingFee_
    ) external onlyOwner mintClosed {
        priceIncrement = priceIncrement_;
        startMintingFee = startMintingFee_;
    }

    function setAssets(address assets) external onlyOwner {
        _assets = Assets(assets);
    }

    function setTimes(
        uint256 mintBegin_,
        uint256 queueBegin_
    ) external onlyOwner mintClosed {
        mintBegin = mintBegin_;
        queueBegin = queueBegin_;
    }

    function mintPrivate(
        address[] memory wallets,
        uint256[] memory amounts
    ) external onlyOwner mintOpen {
        uint256 walletLength = wallets.length;

        for (uint256 i = 0; i < walletLength; i++) {
            uint256 amount = amounts[i];
            require(currentToken - 1 + amount <= queueLength, "sales ended");
            _mintBatch(wallets[i], amount);
        }
    }

    function mintZero() external onlyOwner {
        _mint(owner(), 0);
    }

    // ***** Public *****
    // Write

    /**
     * Queue up.
     */
    function enter() external mintClosed {
        require(block.number > queueBegin, "wait to wait");
        queue[queueLength++] = uint160(msg.sender);
    }

    /**
     * Mint
     */
    function mint(
        uint256 amount,
        uint256[] calldata positions
    ) public payable mintOpen mintInProgress {
        uint256 currentSlot = _calculateSlot(block.number);
        _validate(
            currentSlot,
            amount,
            _priceAt(currentSlot, queueLength) * amount,
            positions
        );
        _mintBatch(msg.sender, amount);
    }

    /**
     * Mint with discount options
     */
    function mintDiscount(
        uint256 amount,
        uint256[] calldata positions,
        uint8 freeAmount,
        bytes32[] calldata proof
    ) public payable mintOpen mintInProgress {
        require(balanceOf(msg.sender) == 0, "voucher used");
        bytes32 leaf = keccak256(
            bytes.concat(keccak256(abi.encode(msg.sender, freeAmount)))
        );
        require(MerkleProof.verify(proof, _root, leaf), "invalid proof");
        uint256 currentSlot = _calculateSlot(block.number);
        uint256 currentPrice = _priceAt(currentSlot, queueLength);
        uint256 total = ((currentPrice * DISCOUNTED) / 100) *
            (amount - freeAmount);

        _validate(currentSlot, amount, total, positions);
        _mintBatch(msg.sender, amount);
    }

    /**
     * Explore your queue.
     * @param tokenId Your token
     * @param height Height of the camera
     * @param subjectIndex Centered block, relative to the first block in the queue at *this* stage. Starts from 0.
     */
    function explore(
        uint256 tokenId,
        uint256 height,
        uint256 subjectIndex
    ) public {
        require(msg.sender == ownerOf(tokenId), "not the owner");
        require(height > 0 && height < 32, "invalid height");
        require(subjectIndex < queueLength - (tokenId - 1), "invalid subject");
        uint256 updates = ((_tokenViews[tokenId] >> 128) + 1) & (2 ** 123 - 1);
        _tokenViews[tokenId] =
            (height << 251) |
            (updates << 128) |
            uint128(subjectIndex);
    }

    // Read

    /**
     * It renders the current state of the queue as an svg.
     * It will be complete right before the minting starts.
     * It will be empy after the minting ends, at which point
     * this method becomes pretty much useless
     * (unless you are interested in a permanently degree-and-hue-rotating background).
     * @param plain if true it will render a plain version of the line
     * @return svg an svg string of the queue
     * @return index the index currently at the head of the queue
     * @return count number of blocks in the queue
     */
    function renderCurrent(
        bool plain
    ) public view returns (string memory, uint256, uint256) {
        uint256 index = _calculateSlotSafe(block.number);

        (bytes memory output, uint256 count) = _renderFrom(index, plain);

        return (string(output), index, count);
    }

    /**
     * Returns information related to the account
     * @param account the desired account
     * @return wallet the ENS or 0x string of the given wallet
     * @return svg the block rendering of the given wallet
     * @return positions the positions in line, starting from 0
     */
    function accountData(
        address account
    )
        public
        view
        returns (
            string memory wallet,
            string memory svg,
            uint256[] memory positions
        )
    {
        (wallet, ) = _assets.convertWallet(account);
        svg = _renderWallet(account);

        uint256 total;
        uint256[] memory positionsTmp = new uint256[](4096);
        for (uint256 i = 0; i < queueLength; i++) {
            if (queue[i] == uint160(account)) {
                positionsTmp[total++] = i;
            }
        }

        positions = new uint256[](total);
        for (uint256 i = 0; i < total; i++) {
            positions[i] = positionsTmp[i];
        }
    }

    /**
     * Returns information related to a given index in line.
     * @param index the index, starting from 0
     * @return wallet the ENS or 0x string of the wallet at the given index
     * @return svg the block rendering of the wallet at the given index
     */
    function walletAtIndex(
        uint256 index
    ) public view returns (string memory wallet, string memory svg) {
        require(index < queueLength, "index beyond queue");
        address account = address(queue[index]);
        (wallet, ) = _assets.convertWallet(account);
        svg = _renderWallet(account);
    }

    // Overrides

    function tokenURI(
        uint256 tokenId
    ) public view override returns (string memory) {
        require(_exists(tokenId), "non existing token");

        uint256 zoom = 32;
        uint256 subject = 0;
        uint256 updates = 0;
        uint256 minQueueIndex = 0;
        uint256 blockNumber = block.number;

        if (tokenId > 0) {
            blockNumber = mintBegin + tokenId;
            (zoom, subject, updates) = _getViewConfig(tokenId);
            minQueueIndex = tokenId - 1;
        }

        bytes memory buffer = DynamicBuffer.allocate(20000);
        DynamicBuffer.appendUnchecked(buffer, "data:application/json,");

        bytes memory details = _assets.metadataDetails(tokenId);
        DynamicBuffer.appendUnchecked(buffer, details);

        bytes memory output;
        uint256 peopleCount;

        if (tokenId > 0) {
            (output, peopleCount) = _render(
                buffer,
                Mode.STANDARD,
                queueLength - minQueueIndex,
                blockNumber,
                minQueueIndex,
                subject,
                zoom
            );
            bytes memory attributes = _getAttributes(
                minQueueIndex,
                subject,
                peopleCount,
                zoom,
                updates
            );
            DynamicBuffer.appendUnchecked(output, attributes);
            return string(output);
        } else {
            (output, ) = _renderFrom(0, false);
            DynamicBuffer.appendUnchecked(buffer, output);
            DynamicBuffer.appendUnchecked(buffer, '"}');
            return string(buffer);
        }
    }

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override tradingActive {
        super._transfer(from, to, tokenId);
    }

    function _approve(
        address to,
        uint256 tokenId
    ) internal virtual override tradingActive {
        super._approve(to, tokenId);
    }

    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual override tradingActive {
        require(queueLength > 1, "trading not active");
        super._setApprovalForAll(owner, operator, approved);
    }

    //**** Internal *****

    // Write

    function _mintBatch(address to, uint256 amount) internal {
        for (uint256 i = 0; i < amount; i++) {
            super._mint(to, currentToken++);
        }
    }

    // Read

    function _getAttributes(
        uint256 minQueueIndex,
        uint256 subject,
        uint256 peopleCount,
        uint256 zoom,
        uint256 updates
    ) internal view returns (bytes memory) {
        address wallet = address(queue[minQueueIndex + subject]);
        return
            _assets.metadataAttributes(
                peopleCount,
                zoom,
                subject,
                minQueueIndex,
                queueLength,
                updates,
                wallet
            );
    }

    function _priceAt(
        uint256 slot,
        uint256 length
    ) internal view returns (uint256) {
        if (slot < length >> 1) {
            return startMintingFee + priceIncrement * slot;
        } else {
            return startMintingFee + priceIncrement * (length - slot - 1);
        }
    }

    function _validate(
        uint256 currentSlot,
        uint256 amount,
        uint256 price,
        uint256[] calldata indexes
    ) internal view {
        require(queue[indexes[0]] == uint160(msg.sender), "invalid index");
        uint256 length = indexes.length;
        for (uint256 i = 1; i < length; i++) {
            require(
                indexes[i - 1] < indexes[i] &&
                    queue[indexes[i]] == uint160(msg.sender),
                "invalid indexes"
            );
        }
        require(
            balanceOf(msg.sender) + amount <= length << 1,
            "invalid amount"
        );
        require(currentSlot >= indexes[0], "not your turn");
        require(currentToken - 1 + amount <= queueLength, "sales ended");
        require(msg.value >= price, "not enough ether");
    }

    function _calculateSlot(
        uint256 blockNumber
    ) internal view returns (uint256) {
        return blockNumber - mintBegin;
    }

    function _calculateSlotSafe(
        uint256 blockNumber
    ) internal view returns (uint256) {
        return blockNumber < mintBegin ? 0 : _calculateSlot(blockNumber);
    }

    function _getViewConfig(
        uint256 tokenId
    ) internal view returns (uint256 zoom, uint256 subject, uint256 updates) {
        uint256 tokenView = _tokenViews[tokenId];
        zoom = tokenView >> 251;
        updates = (tokenView >> 128) & (2 ** 123 - 1);
        subject = uint128(tokenView);
        if (zoom == 0) {
            uint256 randomness = uint256(
                keccak256(abi.encodePacked(tokenId, queueLength))
            );
            uint256 prob = randomness % queueLength;

            if (prob < (queueLength * 850) / 1000) {
                zoom = (prob % 5) + 1;
            } else if (prob < (queueLength * 950) / 1000) {
                zoom = (prob % 6) + 5;
            } else if (prob < (queueLength * 999) / 1000) {
                zoom = (prob % 11) + 11;
            } else {
                zoom = 31;
            }
            subject = uint128(randomness % (queueLength - tokenId + 1));
        }
    }

    function _renderFrom(
        uint256 index,
        bool plain
    ) internal view returns (bytes memory, uint256) {
        uint256 count;
        if (index < queueLength) {
            count = queueLength - index;
        }

        Mode mode;
        if (count < _maxBlocksRich && !plain) {
            mode = Mode.FULL_RICH;
        } else if (count < _maxBlocksPlain) {
            mode = Mode.FULL_PLAIN;
        } else {
            mode = Mode.FULL_PATH;
        }

        bytes memory beforeBuffer;
        (bytes memory output, ) = _render(
            beforeBuffer,
            mode,
            count,
            block.number,
            index,
            0,
            32
        );

        return (output, count);
    }
}


// File: contracts/QueueRenderer.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.21;

import "@openzeppelin/contracts/utils/Strings.sol";
import "./DynamicBuffer.sol";
import "./SVG.sol";

contract QueueRenderer is SVG {
    using Strings for uint32;
    using Strings for uint256;

    uint256 constant SQUARE_SIDE = 100;
    uint256 constant HALF_SQUARE_SIDE = 50;
    uint256 constant MARGIN = 15;
    int32 constant SQUARE_SIDE_MARGIN = int32(uint32(SQUARE_SIDE + MARGIN));
    uint256 constant WIDTH = 40000;
    uint256 constant HEIGHT = 40000;
    uint256 constant GRADIENT_PROB = 4;
    uint256 constant CIRCLE_PROB = 2;

    uint256 constant MAX_QUEUE_SIZE = 4096;
    uint256 constant RANDOMNES_CHUNK_SIZE_WALLET = 160 / 8;
    uint256 constant MASK_WALLET = 2 ** RANDOMNES_CHUNK_SIZE_WALLET - 1;

    struct Boundaries {
        uint32 firstX;
        uint32 firstY;
        uint32 lastX;
        uint32 lastY;
        int256 offsetX;
        int256 offsetY;
    }

    enum Mode {
        STANDARD,
        FULL_PLAIN,
        FULL_RICH,
        FULL_PATH
    }

    struct WalletTraits {
        uint8 variant;
        uint8 gradientAnimation;
        uint8 circleAnimation;
        uint8 scale;
        uint8 useCircle;
        uint8 shakeAnimation;
        uint8 colorSolid;
        uint16 colorBackground;
    }

    mapping(uint8 => string) _scales;

    bytes constant _blurs = hex"343434343636363639393939";
    bytes constant _gradients = hex"30303030303030303131323334353637";
    bytes constant _animations = hex"6162636465666768696A6B6C6D6E6F70";

    uint160[MAX_QUEUE_SIZE] public queue;
    uint256 public queueLength;

    constructor(address assets) SVG(assets) {
        _scales[0] = "0.2";
        _scales[1] = "0.4";
        _scales[2] = "0.5";
        _scales[3] = "0.7";
        _scales[4] = "0.8";
        _scales[5] = "1.0";
        _scales[6] = "1.05";
        _scales[7] = "1.1";
    }

    function _render(
        bytes memory beforeBuffer,
        Mode mode,
        uint256 count,
        uint256 mintBlockNumber,
        uint256 minQueueIndex,
        uint256 zoomedSquare, // relative to minQueueIndex
        uint256 shownSquares
    ) internal view returns (bytes memory output, uint256 blocksCount) {
        bytes memory buffer = DynamicBuffer.allocate(200000);
        DynamicBuffer.appendUnchecked(buffer, beforeBuffer);

        Data memory data = _precompute(
            mintBlockNumber,
            minQueueIndex,
            zoomedSquare,
            count
        );
        data.showSquares = uint32(shownSquares);

        (int256 offsetX, int256 offsetY) = _offset(mode, data);

        Boundaries memory boundaries = _boundaries(data, mode);
        boundaries.offsetX = offsetX;
        boundaries.offsetY = offsetY;
        uint256 maxQueueIndex = minQueueIndex + count;

        blocksCount = _compose(
            buffer,
            mode,
            minQueueIndex,
            maxQueueIndex,
            (7 * shownSquares),
            data,
            boundaries
        );
        output = buffer;
    }

    function _compose(
        bytes memory buffer,
        Mode mode,
        uint256 minIndex,
        uint256 maxIndex,
        uint256 padding,
        Data memory data,
        Boundaries memory boundaries
    ) internal view returns (uint256 peopleCount) {
        svgTemplate1(
            buffer,
            data.showSquares > 10 ? bytes1(0x30) : _blurs[data.showSquares],
            boundaries.offsetX - int256(padding >> 1),
            boundaries.offsetY - int256(padding >> 1),
            padding,
            data
        );

        if (mode == Mode.FULL_PLAIN || mode == Mode.FULL_RICH) {
            _renderPlainFull(buffer, data, minIndex, mode == Mode.FULL_PLAIN);
        } else if (mode == Mode.FULL_PATH) {
            _renderPath(buffer, minIndex, maxIndex - minIndex);
        } else {
            peopleCount = _renderZoom(buffer, boundaries, data, minIndex);
        }
        svgTemplate2(buffer);
    }

    function _renderPlainFull(
        bytes memory buffer,
        Data memory data,
        uint256 minIndex,
        bool plain
    ) internal view {
        bytes memory allColors = _assets.getColors();
        uint256 length = data.segments;
        for (uint256 i = 0; i < length; ++i) {
            int32 startX = int32(data.coords[i][0]);
            int32 startY = int32(data.coords[i][1]);
            int32 incrementX = data.increments[i][0];
            int32 incrementY = data.increments[i][1];

            for (uint256 j = 0; j <= i; ++j) {
                if (plain) {
                    _renderPlainRects(
                        buffer,
                        uint32(startX + incrementX * int32(int256(j))),
                        uint32(startY + incrementY * int32(int256(j))),
                        queue[minIndex++],
                        allColors
                    );
                } else {
                    _renderRects(
                        buffer,
                        uint32(startX + incrementX * int32(int256(j))),
                        uint32(startY + incrementY * int32(int256(j))),
                        queue[minIndex++],
                        allColors
                    );
                }

                if (minIndex == queueLength) {
                    break;
                }
            }
        }
    }

    function _renderZoom(
        bytes memory buffer,
        Boundaries memory boundaries,
        Data memory data,
        uint256 minIndex
    ) internal view returns (uint256 peopleCount) {
        bytes memory allColors = _assets.getColors();
        for (uint256 i = 0; i < data.segments; ++i) {
            int32 startX = int32(data.coords[i][0]);
            int32 startY = int32(data.coords[i][1]);
            int32 incrementX = data.increments[i][0];
            int32 incrementY = data.increments[i][1];

            for (uint256 j = 0; j <= i; ++j) {
                uint32 x = uint32(startX + incrementX * int32(int256(j)));
                uint32 y = uint32(startY + incrementY * int32(int256(j)));

                if (
                    x > boundaries.firstX &&
                    x < boundaries.lastX &&
                    y > boundaries.firstY &&
                    y < boundaries.lastY
                ) {
                    peopleCount++;
                    _renderRects(buffer, x, y, queue[minIndex], allColors);
                }

                minIndex++;

                if (minIndex == queueLength) {
                    break;
                }
            }
        }
    }

    function _renderWallet(
        address wallet
    ) internal view returns (string memory) {
        bytes memory allColors = _assets.getColors();
        bytes memory buffer = DynamicBuffer.allocate(200000);
        Data memory data;
        data.frameSize = uint32(SQUARE_SIDE);

        svgTemplate1(buffer, "1", 0, 0, (MARGIN << 1), data);
        _renderRects(buffer, MARGIN, MARGIN, uint160(wallet), allColors);
        svgTemplate2(buffer);

        return string(buffer);
    }

    function _renderRects(
        bytes memory buffer,
        uint256 x,
        uint256 y,
        uint160 wallet,
        bytes memory allColors
    ) internal view {
        WalletTraits memory traits = _walletTraits(wallet);

        rectTemplate1(
            buffer,
            x,
            y,
            _animations[traits.shakeAnimation],
            bytes(_scales[traits.scale])
        );

        bytes memory color1 = new bytes(6);
        bytes memory color2 = new bytes(6);
        bytes memory color3 = new bytes(6);
        uint256 start = 32 + traits.colorBackground * 6;
        if (traits.variant < GRADIENT_PROB) {
            assembly {
                mstore(add(color1, 32), mload(add(allColors, start)))
            }

            rectGradientAttributes(buffer, color1);
            rectTemplate2(buffer);

            if (traits.variant == 0) {
                assembly {
                    mstore(
                        add(color2, 32),
                        mload(add(allColors, add(start, 6)))
                    )
                }

                gradient(
                    buffer,
                    _gradients[traits.gradientAnimation],
                    x + 50,
                    y + 50,
                    color2
                );
            }
        } else {
            rectSolidAttributes(buffer, traits.colorSolid);
            rectTemplate2(buffer);
        }

        if (traits.useCircle < CIRCLE_PROB) {
            assembly {
                mstore(add(color3, 32), mload(add(allColors, add(start, 12))))
            }
            circle(buffer, traits.circleAnimation, x + 50, y + 50, color3);
        }

        rectTemplate3(buffer);
    }

    function _renderPlainRects(
        bytes memory buffer,
        uint256 x,
        uint256 y,
        uint160 wallet,
        bytes memory allColors
    ) internal view {
        uint8 variant = uint8(_randomNumberWallet(wallet, 0) & 7);
        uint32 colorBackground = uint32(_randomNumberWallet(wallet, 1) & 2047);
        uint8 scale = uint8(_randomNumberWallet(wallet, 4) & 7);
        uint8 shakeAnimation = uint8(_randomNumberWallet(wallet, 5) & 15);
        uint8 colorSolid = uint8(_randomNumberWallet(wallet, 7) & 63) + 18;

        rectTemplate1(
            buffer,
            x,
            y,
            _animations[shakeAnimation],
            bytes(_scales[scale])
        );

        bytes memory color1 = new bytes(6);
        uint256 start = 32 + colorBackground * 6;
        if (variant < GRADIENT_PROB) {
            assembly {
                mstore(add(color1, 32), mload(add(allColors, start)))
            }
            rectGradientAttributes(buffer, color1);
        } else {
            rectSolidAttributes(buffer, colorSolid);
        }

        rectTemplate2(buffer);
        rectTemplate3(buffer);
    }

    function _precompute(
        uint256 mintBlockNumber,
        uint256 minQueueIndex,
        uint256 zoomedSquare,
        uint256 count
    ) internal view returns (Data memory data) {
        _frameTraits(mintBlockNumber, data);
        data.zoomedSquare = uint32(zoomedSquare);

        int32 x = int32(uint32((WIDTH >> 1) - HALF_SQUARE_SIDE));
        int32 y = int32(uint32((HEIGHT >> 1) - HALF_SQUARE_SIDE));

        data.minX = data.maxX = data.zoomX = uint32(x);
        data.minY = data.maxY = data.zoomY = uint32(y);

        int32 segmentIndex = 0;
        int256 tilt = 0;
        int32 tiltRound = 5;
        int32 incrementX = 0;
        int32 incrementY = 0;

        for (uint256 i = 0; i < count; ) {
            uint32 index = uint32(segmentIndex);

            if (segmentIndex % tiltRound == 4) {
                tilt += int256(uint256(queue[i + minQueueIndex] % 5));
                tiltRound += 1;
            }

            data.coords[index][0] = uint32(x);
            data.coords[index][1] = uint32(y);

            int256 direction = -(((int256(segmentIndex) >> 1) & 1) << 1) + 1;
            int256 xDirection = int256((segmentIndex) & 1) * direction;
            int256 yDirection = (1 - int256((segmentIndex) & 1)) * direction;

            incrementX = (int32(SQUARE_SIDE_MARGIN * xDirection) +
                int32(tilt * yDirection));
            incrementY = (int32(SQUARE_SIDE_MARGIN * yDirection) +
                int32(tilt * -xDirection));

            if (
                data.zoomedSquare >= i &&
                data.zoomedSquare <= i + uint256(int256(segmentIndex))
            ) {
                int32 delta = int32(uint32(data.zoomedSquare - i));
                data.zoomX = uint32(x + incrementX * delta);
                data.zoomY = uint32(y + incrementY * delta);
            }

            x = x + incrementX * int32(segmentIndex + 1);
            y = y + incrementY * int32(segmentIndex + 1);

            data.increments[index][0] = incrementX;
            data.increments[index][1] = incrementY;

            unchecked {
                segmentIndex++;
                i += uint256(int256(segmentIndex));
            }
        }

        data.segments = uint32(segmentIndex);
        _minMax(data, count);

        if (count == 0) {
            data.minX = uint32(WIDTH / 2 - ((SQUARE_SIDE + MARGIN) * 83) / 2);
            data.maxX = uint32(WIDTH / 2 + ((SQUARE_SIDE + MARGIN) * 83) / 2);
            data.minY = uint32(HEIGHT / 2 - ((SQUARE_SIDE + MARGIN) * 83) / 2);
            data.maxY = uint32(HEIGHT / 2 + ((SQUARE_SIDE + MARGIN) * 83) / 2);
        }

        data.lengthX = data.maxX - data.minX + uint32(SQUARE_SIDE);
        data.lengthY = data.maxY - data.minY + uint32(SQUARE_SIDE);
        if (data.lengthX > data.lengthY) {
            data.frameSize = data.lengthX;
        } else {
            data.frameSize = data.lengthY;
        }
    }

    function _minMax(Data memory data, uint256 count) internal pure {
        for (uint256 i = 0; i < data.segments; ++i) {
            uint32 startX = data.coords[i][0];
            uint32 startY = data.coords[i][1];
            int32 incrementX = data.increments[i][0];
            int32 incrementY = data.increments[i][1];
            uint256 numberBlocks = i;
            if (numberBlocks >= count) {
                numberBlocks = count - 1;
            }

            uint32 endX = uint32(
                int32(startX) + incrementX * int32(int256(numberBlocks))
            );
            uint32 endY = uint32(
                int32(startY) + incrementY * int32(int256(numberBlocks))
            );

            (uint32 minX, uint32 maxX) = _minAndMax(startX, endX);
            if (minX < data.minX) {
                data.minX = minX;
            } else if (maxX > data.maxX) {
                data.maxX = maxX;
            }

            (uint32 minY, uint32 maxY) = _minAndMax(startY, endY);
            if (minY < data.minY) {
                data.minY = minY;
            } else if (maxY > data.maxY) {
                data.maxY = maxY;
            }

            count -= numberBlocks + 1;
        }
    }

    function _minAndMax(
        uint32 a,
        uint32 b
    ) internal pure returns (uint32 min, uint32 max) {
        min = a;
        max = b;
        if (min > b) {
            max = min;
            min = b;
        }
    }

    function _renderPath(
        bytes memory buffer,
        uint256 minQueueIndex,
        uint256 count
    ) internal view {
        DynamicBuffer.appendUnchecked(
            buffer,
            _assets.renderFallback(
                minQueueIndex,
                count,
                queue,
                WIDTH,
                HEIGHT,
                HALF_SQUARE_SIDE,
                SQUARE_SIDE,
                SQUARE_SIDE_MARGIN
            )
        );
    }

    function _boundaries(
        Data memory data,
        Mode mode
    ) internal pure returns (Boundaries memory boundaries) {
        if (mode != Mode.STANDARD) {
            boundaries.firstX = 0;
            boundaries.firstY = 0;
            boundaries.lastX = data.maxX + 100;
            boundaries.lastY = data.maxY + 100;
        } else {
            boundaries.firstX = uint32(
                data.zoomX + HALF_SQUARE_SIDE - data.frameSize / 2
            );
            boundaries.lastX = uint32(
                data.zoomX - HALF_SQUARE_SIDE + data.frameSize / 2
            );
            boundaries.firstY = uint32(
                data.zoomY + HALF_SQUARE_SIDE - data.frameSize / 2
            );
            boundaries.lastY = uint32(
                data.zoomY - HALF_SQUARE_SIDE + data.frameSize / 2
            );
        }
    }

    function _offset(
        Mode mode,
        Data memory data
    ) internal pure returns (int256 offsetX, int256 offsetY) {
        if (mode != Mode.STANDARD) {
            int256 frameCenterX = int256(
                int32(data.lengthX) / 2 + int32(data.minX)
            );
            int256 frameCenterY = int256(
                int32(data.lengthY) / 2 + int32(data.minY)
            );

            offsetX = frameCenterX - int32(data.frameSize) / 2;
            offsetY = frameCenterY - int32(data.frameSize) / 2;
        } else {
            int256 frameSize16 = int256(int32(data.frameSize));
            int256 center = frameSize16 >> 1;
            uint256 zoomLevel = ((uint256(data.frameSize) * 1000) /
                (uint256(data.showSquares) *
                    SQUARE_SIDE +
                    uint256(data.showSquares + 1) *
                    MARGIN));

            data.frameSize = uint32(
                (uint256(data.frameSize) * 1000) / (zoomLevel)
            );
            int256 diffFrameSize = frameSize16 -
                int256(uint256(data.frameSize));

            int256 frameCenterX = int256(data.zoomX + HALF_SQUARE_SIDE) +
                (diffFrameSize >> 1);
            int256 frameCenterY = int256(data.zoomY + HALF_SQUARE_SIDE) +
                (diffFrameSize >> 1);

            offsetX = frameCenterX - center;
            offsetY = frameCenterY - center;
        }
    }

    // Randomness

    function _frameTraits(
        uint256 mintBlockNumber,
        Data memory data
    ) internal pure {
        data.pathRotation = uint32(mintBlockNumber % 360);
        data.pathHue = data.pathRotation;
        data.pathSat =
            uint8(uint256(keccak256(abi.encodePacked(mintBlockNumber)))) %
            100;
        data.pathLum = uint8(mintBlockNumber % 5) + 5;
    }

    function _randomNumberWallet(
        uint160 wallet,
        uint256 index
    ) internal pure returns (uint256) {
        return ((wallet >> (RANDOMNES_CHUNK_SIZE_WALLET * index)) &
            MASK_WALLET);
    }

    function _walletTraits(
        uint160 wallet
    ) internal pure returns (WalletTraits memory traits) {
        traits.variant = uint8(_randomNumberWallet(wallet, 0) & 7);
        traits.colorBackground = uint16(_randomNumberWallet(wallet, 1) & 2047);
        traits.gradientAnimation = uint8(_randomNumberWallet(wallet, 2) & 15);
        traits.circleAnimation = uint8(_randomNumberWallet(wallet, 3) & 7);
        traits.scale = uint8(_randomNumberWallet(wallet, 4) & 7);
        traits.shakeAnimation = uint8(_randomNumberWallet(wallet, 5) & 15);
        traits.useCircle = uint8(_randomNumberWallet(wallet, 6) & 7);
        traits.colorSolid = uint8(_randomNumberWallet(wallet, 7) & 63) + 18;
    }
}


// File: contracts/SVG.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.21;

import "@openzeppelin/contracts/utils/Strings.sol";
import "./DynamicBuffer.sol";
import "./Assets.sol";

contract SVG {
    Assets _assets;

    using Strings for uint256;
    using Strings for uint32;
    using Strings for uint16;
    using Strings for uint8;

    struct Data {
        uint8 pathSat;
        uint8 pathLum;
        uint32 minX;
        uint32 minY;
        uint32 maxX;
        uint32 maxY;
        uint32 zoomX;
        uint32 zoomY;
        uint32 lengthX;
        uint32 lengthY;
        uint32 frameSize;
        uint32 showSquares;
        uint32 pathHue;
        uint32 pathRotation;
        uint32 zoomedSquare;
        uint32 segments;
        uint32[2][100] coords;
        int32[2][100] increments;
    }

    constructor(address assets) {
        _assets = Assets(assets);
    }

    function _path(
        bytes memory buffer,
        uint256 h,
        uint256 s,
        uint256 l,
        uint256 rotation
    ) public view {
        (
            bytes memory path1,
            bytes memory path2,
            bytes memory path3,
            bytes memory path4,
            bytes memory path5
        ) = _assets.getPaths();
        DynamicBuffer.appendUnchecked(buffer, path1);
        DynamicBuffer.appendUnchecked(buffer, bytes(h.toString()));
        DynamicBuffer.appendUnchecked(buffer, path2);
        DynamicBuffer.appendUnchecked(buffer, bytes(s.toString()));
        DynamicBuffer.appendUnchecked(buffer, path3);
        DynamicBuffer.appendUnchecked(buffer, bytes(l.toString()));
        DynamicBuffer.appendUnchecked(buffer, path4);
        DynamicBuffer.appendUnchecked(buffer, bytes(rotation.toString()));
        DynamicBuffer.appendUnchecked(buffer, path5);
    }

    bytes constant gradient1 = bytes("<use href='#g ' x='");
    bytes constant gradient3 = bytes("' y='");
    bytes constant gradient4 = bytes("' fill='#");
    bytes constant gradient5 = bytes("' />");

    function gradient(
        bytes memory buffer,
        bytes1 id,
        uint256 x,
        uint256 y,
        bytes memory color
    ) public pure {
        bytes memory gradient1Memory = gradient1;
        gradient1Memory[13] = id;
        DynamicBuffer.appendUnchecked(buffer, gradient1Memory);
        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));
        DynamicBuffer.appendUnchecked(buffer, gradient3);
        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));
        DynamicBuffer.appendUnchecked(buffer, gradient4);
        DynamicBuffer.appendUnchecked(buffer, color);
        DynamicBuffer.appendUnchecked(buffer, gradient5);
    }

    bytes constant circle1 = bytes("<use href='#a");
    bytes constant circle2 = bytes("' x='");
    bytes constant circle4 = bytes("' stroke='#");

    function circle(
        bytes memory buffer,
        uint256 circleAnimation,
        uint256 x,
        uint256 y,
        bytes memory color
    ) public pure {
        DynamicBuffer.appendUnchecked(buffer, circle1);
        DynamicBuffer.appendUnchecked(
            buffer,
            bytes(circleAnimation.toString())
        );
        DynamicBuffer.appendUnchecked(buffer, circle2);
        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));
        DynamicBuffer.appendUnchecked(buffer, gradient3);
        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));
        DynamicBuffer.appendUnchecked(buffer, circle4);
        DynamicBuffer.appendUnchecked(buffer, color);
        DynamicBuffer.appendUnchecked(buffer, gradient5);
    }

    function rectGradientAttributes(
        bytes memory buffer,
        bytes memory color
    ) public pure {
        DynamicBuffer.appendUnchecked(buffer, bytes("fill='#"));
        DynamicBuffer.appendUnchecked(buffer, color);
        DynamicBuffer.appendUnchecked(buffer, bytes("'"));
    }

    function rectSolidAttributes(bytes memory buffer, uint8 color) public pure {
        DynamicBuffer.appendUnchecked(buffer, bytes("fill='hsl(25,0%,"));
        DynamicBuffer.appendUnchecked(buffer, bytes(color.toString()));
        DynamicBuffer.appendUnchecked(buffer, bytes("%)'"));
    }

    bytes constant rect1 = bytes("<g class='s' transform='scale(");
    bytes constant rect2 = bytes(")'><path class='s ' d='M");
    bytes constant rect4 = bytes(" ");
    bytes constant rect5 = bytes("h100v100h-100' ");
    bytes constant rect6 = bytes(" >");
    bytes constant rect7 = bytes("</path>");
    bytes constant rect8 = bytes("</g>");

    function rectTemplate1(
        bytes memory buffer,
        uint256 x,
        uint256 y,
        bytes1 animation,
        bytes memory scale
    ) public pure {
        DynamicBuffer.appendUnchecked(buffer, rect1);
        DynamicBuffer.appendUnchecked(buffer, scale);
        bytes memory rect2o = rect2;
        rect2o[17] = animation;
        DynamicBuffer.appendUnchecked(buffer, rect2o);
        DynamicBuffer.appendUnchecked(buffer, bytes(x.toString()));
        DynamicBuffer.appendUnchecked(buffer, rect4);
        DynamicBuffer.appendUnchecked(buffer, bytes(y.toString()));
        DynamicBuffer.appendUnchecked(buffer, rect5);
    }

    // atributes

    function rectTemplate2(bytes memory buffer) public pure {
        DynamicBuffer.appendUnchecked(buffer, rect6);
        DynamicBuffer.appendUnchecked(buffer, rect7);
    }

    // content

    function rectTemplate3(bytes memory buffer) internal pure {
        DynamicBuffer.appendUnchecked(buffer, rect8);
    }

    function svgTemplate1(
        bytes memory buffer,
        bytes1 blur,
        int256 x,
        int256 y,
        uint256 padding,
        Data memory data
    ) public view {
        DynamicBuffer.appendUnchecked(
            buffer,
            bytes("<svg xmlns='http://www.w3.org/2000/svg' viewBox='")
        );

        uint256 xU;
        if (x < 0) {
            DynamicBuffer.appendUnchecked(buffer, bytes("-"));
            xU = uint256(-x);
        } else {
            xU = uint256(x);
        }

        DynamicBuffer.appendUnchecked(buffer, bytes(xU.toString()));
        DynamicBuffer.appendUnchecked(buffer, bytes(" "));

        uint256 yU;
        if (y < 0) {
            DynamicBuffer.appendUnchecked(buffer, bytes("-"));
            yU = uint256(-y);
        } else {
            yU = uint256(y);
        }

        DynamicBuffer.appendUnchecked(buffer, bytes(yU.toString()));
        DynamicBuffer.appendUnchecked(buffer, bytes(" "));
        DynamicBuffer.appendUnchecked(
            buffer,
            bytes((data.frameSize + padding).toString())
        );
        DynamicBuffer.appendUnchecked(buffer, bytes(" "));
        DynamicBuffer.appendUnchecked(
            buffer,
            bytes((data.frameSize + padding).toString())
        );
        bytes memory header = bytes(_assets.getHeader());
        header[2514] = blur;
        DynamicBuffer.appendUnchecked(buffer, header);
        DynamicBuffer.appendUnchecked(buffer, bytes("<g id='r'>"));
        _path(buffer, data.pathHue, data.pathSat, data.pathLum, data.pathHue);
    }

    function svgTemplate2(bytes memory buffer) public pure {
        DynamicBuffer.appendUnchecked(buffer, bytes("</g>"));
        DynamicBuffer.appendUnchecked(buffer, bytes("</svg>"));
    }
}

