
// File: @thirdweb-dev/contracts/extension/interface/IPermissions.sol
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/// @author thirdweb

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IPermissions {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}


// File: @thirdweb-dev/contracts/extension/Permissions.sol
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/// @author thirdweb

import "./interface/IPermissions.sol";
import "../lib/TWStrings.sol";

/**
 *  @title   Permissions
 *  @dev     This contracts provides extending-contracts with role-based access control mechanisms
 */
contract Permissions is IPermissions {
    /// @dev Map from keccak256 hash of a role => a map from address => whether address has role.
    mapping(bytes32 => mapping(address => bool)) private _hasRole;

    /// @dev Map from keccak256 hash of a role to role admin. See {getRoleAdmin}.
    mapping(bytes32 => bytes32) private _getRoleAdmin;

    /// @dev Default admin role for all roles. Only accounts with this role can grant/revoke other roles.
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /// @dev Modifier that checks if an account has the specified role; reverts otherwise.
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    /**
     *  @notice         Checks whether an account has a particular role.
     *  @dev            Returns `true` if `account` has been granted `role`.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     *  @param account  Address of the account for which the role is being checked.
     */
    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return _hasRole[role][account];
    }

    /**
     *  @notice         Checks whether an account has a particular role;
     *                  role restrictions can be swtiched on and off.
     *
     *  @dev            Returns `true` if `account` has been granted `role`.
     *                  Role restrictions can be swtiched on and off:
     *                      - If address(0) has ROLE, then the ROLE restrictions
     *                        don't apply.
     *                      - If address(0) does not have ROLE, then the ROLE
     *                        restrictions will apply.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     *  @param account  Address of the account for which the role is being checked.
     */
    function hasRoleWithSwitch(bytes32 role, address account) public view returns (bool) {
        if (!_hasRole[role][address(0)]) {
            return _hasRole[role][account];
        }

        return true;
    }

    /**
     *  @notice         Returns the admin role that controls the specified role.
     *  @dev            See {grantRole} and {revokeRole}.
     *                  To change a role's admin, use {_setRoleAdmin}.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     */
    function getRoleAdmin(bytes32 role) external view override returns (bytes32) {
        return _getRoleAdmin[role];
    }

    /**
     *  @notice         Grants a role to an account, if not previously granted.
     *  @dev            Caller must have admin role for the `role`.
     *                  Emits {RoleGranted Event}.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     *  @param account  Address of the account to which the role is being granted.
     */
    function grantRole(bytes32 role, address account) public virtual override {
        _checkRole(_getRoleAdmin[role], msg.sender);
        if (_hasRole[role][account]) {
            revert("Can only grant to non holders");
        }
        _setupRole(role, account);
    }

    /**
     *  @notice         Revokes role from an account.
     *  @dev            Caller must have admin role for the `role`.
     *                  Emits {RoleRevoked Event}.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     *  @param account  Address of the account from which the role is being revoked.
     */
    function revokeRole(bytes32 role, address account) public virtual override {
        _checkRole(_getRoleAdmin[role], msg.sender);
        _revokeRole(role, account);
    }

    /**
     *  @notice         Revokes role from the account.
     *  @dev            Caller must have the `role`, with caller being the same as `account`.
     *                  Emits {RoleRevoked Event}.
     *
     *  @param role     keccak256 hash of the role. e.g. keccak256("TRANSFER_ROLE")
     *  @param account  Address of the account from which the role is being revoked.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        if (msg.sender != account) {
            revert("Can only renounce for self");
        }
        _revokeRole(role, account);
    }

    /// @dev Sets `adminRole` as `role`'s admin role.
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = _getRoleAdmin[role];
        _getRoleAdmin[role] = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /// @dev Sets up `role` for `account`
    function _setupRole(bytes32 role, address account) internal virtual {
        _hasRole[role][account] = true;
        emit RoleGranted(role, account, msg.sender);
    }

    /// @dev Revokes `role` from `account`
    function _revokeRole(bytes32 role, address account) internal virtual {
        _checkRole(role, account);
        delete _hasRole[role][account];
        emit RoleRevoked(role, account, msg.sender);
    }

    /// @dev Checks `role` for `account`. Reverts with a message including the required role.
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!_hasRole[role][account]) {
            revert(
                string(
                    abi.encodePacked(
                        "Permissions: account ",
                        TWStrings.toHexString(uint160(account), 20),
                        " is missing role ",
                        TWStrings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /// @dev Checks `role` for `account`. Reverts with a message including the required role.
    function _checkRoleWithSwitch(bytes32 role, address account) internal view virtual {
        if (!hasRoleWithSwitch(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "Permissions: account ",
                        TWStrings.toHexString(uint160(account), 20),
                        " is missing role ",
                        TWStrings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }
}


// File: @thirdweb-dev/contracts/lib/TWAddress.sol
// SPDX-License-Identifier: Apache 2.0
pragma solidity ^0.8.0;

/// @author thirdweb

/**
 * @dev Collection of functions related to the address type
 */
library TWAddress {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * [EIP1884](https://eips.ethereum.org/EIPS/eip-1884) increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File: @thirdweb-dev/contracts/lib/TWStrings.sol
// SPDX-License-Identifier: Apache 2.0
pragma solidity ^0.8.0;

/// @author thirdweb

/**
 * @dev String operations.
 */
library TWStrings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}


// File: contracts/base/interface/IProductMarket.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @author Syky - Nathan Rempel

interface IProductMarket {
    /*//////////////////////////////////////////////////////////////
                        Structs
    //////////////////////////////////////////////////////////////*/

    /**
     *  @notice A data structure to configure Product Listings
     *  @dev Should compress to 512 bytes.
     *
     *  @param productId The productId of the asset being sold.     (max 16,777,215)
     *  @param quantity The total quantity listed for sale.         (max 65,535)
     *  @param reserved The quantity availablein the VIP window.    (max 65,535)
     *  @param vipLimit The purchase limit for VIPs.                (max 65,535)
     *  @param pubLimit The purchase limit for public.              (max 65,535)
     *  @param vipPrice The price in ETH per item for VIPs.         (max 18.4467 ETH)
     *  @param pubPrice The price in ETH per item for public.       (max 18.4467 ETH)
     *  @param endTimestamp The sale end timestamp for everyone.
     *  @param vipStartTimestamp The sale start timestamp for VIPs.
     *  @param pubStartTimestamp The sale start timestamp for public.
     *  @param enabled The listing is enabled
     */
    struct ListingParams {
        uint24 productId;
        uint16 quantity;
        uint16 reserved;
        uint16 vipLimit;
        uint16 pubLimit;
        uint64 vipPrice;
        uint64 pubPrice;
        uint32 endTimestamp;
        uint32 vipStartTimestamp;
        uint32 pubStartTimestamp;
        bool enabled;
        //spare 192 bytes space capacity
        //compresses to one 256
    }

    /**
     *  @notice A data structure to store Product Listings
     *  @dev Should compress to 512 bytes.
     *
     *  @param productId The productId of the asset being sold.     (max 16,777,215)
     *  @param enabled The listing is enabled                       (value > 0 = true)
     *  @param quantity The total quantity listed for sale.         (max 65,535)
     *  @param reserved The quantity availablein the VIP window.    (max 65,535)
     *  @param vipLimit The purchase limit for VIPs.                (max 65,535)
     *  @param pubLimit The purchase limit for public.              (max 65,535)
     *  @param vipPrice The price in ETH per item for VIPs.         (max 18.4467 ETH)
     *  @param pubPrice The price in ETH per item for public.       (max 18.4467 ETH)
     *  @param endTimestamp The sale end timestamp for everyone.
     *  @param vipStartTimestamp The sale start timestamp for VIPs.
     *  @param pubStartTimestamp The sale start timestamp for public.
     *  @param resPurchased The VIP purchase quantity in the VIP window.
     *  @param vipPurchased The VIP purchase quantity of the sale in any window.
     *  @param pubPurchased The public purchase quantity of the sale.
     *  @param vipIncome The VIP purchase income of the sale.       (max 4,722.3664 ETH)
     *  @param pubIncome The public purchase income of the sale.    (max 4,722.3664 ETH)
     */
    struct Listing {
        uint24 productId;
        uint8 enabled;
        uint16 quantity;
        uint16 reserved;
        uint16 vipLimit;
        uint16 pubLimit;
        uint64 vipPrice;
        uint64 pubPrice;
        uint32 endTimestamp;
        //compresses to one 256
        uint32 vipStartTimestamp;
        uint32 pubStartTimestamp;
        uint16 resPurchased;
        uint16 vipPurchased;
        uint16 pubPurchased;
        uint72 vipIncome;
        uint72 pubIncome;
        //compresses to one 256
    }

    /// @notice A data structure to return a set of listings
    struct ListingQuery {
        uint256 listingId;
        Listing listingData;
    }

    enum AuctionStatus {
        UNSET,
        CREATED,
        COMPLETED,
        CANCELLED
    }

    struct AuctionParams {
        uint56 productId;
        uint32 startTimestamp;
        uint32 endTimestamp;
        uint64 bidBufferBps;
        uint64 timeBufferSeconds;
        uint256 minimumBidAmount;
        uint256 reserveBidAmount;
    }

    struct Auction {
        uint56 productId;
        AuctionStatus status;
        uint32 startTimestamp;
        uint32 endTimestamp;
        uint64 bidBufferBps;
        uint64 timeBufferSeconds;
        uint256 minimumBidAmount;
        uint256 reserveBidAmount;
    }

    struct AuctionQuery {
        uint256 auctionId;
        Auction auctionData;
        Bid winningBid;
    }

    struct Bid {
        uint64 auctionId;
        uint32 bidTimestamp;
        address bidder;
        uint256 bidAmount;
    }

    struct BidHistory {
        uint256 count;
        mapping(uint256 => Bid) bids;
    }

    struct ProductLookup {
        uint256 count;
        mapping(uint256 => uint256) id;
    }

    /*//////////////////////////////////////////////////////////////
                        Events
    //////////////////////////////////////////////////////////////*/

    /// @dev Emitted when a new listing is created.
    event ListingAdded(uint256 indexed listingId, Listing listing);

    /// @dev Emitted when the parameters of a listing are updated.
    event ListingUpdated(uint256 indexed listingId, Listing listing);

    /// @dev Emitted when a listing is enabled or disabled.
    event ListingEnabled(uint256 indexed listingId, bool indexed enabled);

    /// @dev Emitted when a listing token contract is updated.
    event ListingContract(uint256 indexed listingId, address indexed tokenContract);

    /// @dev Emitted when a new sale occurs for a listing.
    event NewSale(
        uint256 indexed listingId,
        address indexed buyer,
        address indexed recipient,
        uint256 productId,
        uint256 quantity,
        uint256 price
    );

    /// @dev Emitted when withdrawal recipient is approved or unapproved.
    event WithdrawalRecipientApproved(address indexed recipient, bool indexed approved);

    /// @dev Emitted when market income is withdrawn.
    event IncomeWithdrawal(
        address indexed operator,
        address indexed recipient,
        uint256 indexed amount
    );

    event AuctionAdded(uint256 indexed auctionId, Auction auction);

    event AuctionUpdated(uint256 indexed auctionId, Auction auction);

    event AuctionCancelled(uint256 indexed auctionId);

    /// @dev Emitted when a listing token contract is updated.
    event AuctionContract(uint256 indexed auctionId, address indexed tokenContract);


    event AuctionClosed(
        uint256 indexed auctionId,
        address indexed bidder,
        uint256 indexed bidAmount,
        uint256 productId,
        bool tokenAwarded,
        bool bidRefunded
    );

    event NewBid(
        uint256 indexed auctionId,
        address indexed bidder,
        uint256 indexed bidAmount,
        Auction auction
    );

    /*//////////////////////////////////////////////////////////////
                        Errors
    //////////////////////////////////////////////////////////////*/

    /// @dev Action requires the finance or admin role
    error FinanceRoleRequired();

    /// @dev Action requires the manager or admin role
    error ManagerRoleRequired();

    /// @dev VIP Sale start must be before or equal to Public Sale start
    error ListingVipStartAfterPubStart(
        uint32 vipStartTimestamp,
        uint32 pubStartTimestamp
    );

    /// @dev Public Sale start must be before sale close
    error ListingPubStartAfterEnd(uint32 pubStartTimestamp, uint32 endTimestamp);

    error ListingReserveExceedsQuantity(uint16 reserved, uint16 quantity);

    error ListingDoesNotExist();

    error ListingPurchasesExceedsQuantity(uint16 quantity, uint256 purchased);

    error ListingPurchasesExceedsReserve(uint16 reserve, uint256 purchased);

    error ListingNotEnabled();

    error ListingHasEnded();

    error ListingQueryInvalidRange();

    error ListingExpectedPriceNotEqualValue(
        uint256 expectedTotalPrice,
        uint256 transactionValue
    );

    error ListingInsufficientQuantity(
        uint256 requestedQuantity,
        uint256 availableQuantity
    );

    error ListingVipSaleNotStarted(uint64 vipStartTime, uint256 currentTimestamp);

    error ListingPublicSaleNotStarted(uint64 publicStartTime, uint256 currentTimestamp);

    error ListingVipLimitExceeded(uint256 purchases, uint256 limit);

    error ListingVipReserveExceeded(uint256 requestedQuantity, uint256 availableQuantity);

    error ListingPublicLimitExceeded(uint256 purchases, uint256 limit);

    error ListingVipExpectedPriceInvalid(
        uint256 expectedTotalPrice,
        uint256 actualTotalPrice
    );

    error ListingPublicExpectedPriceInvalid(
        uint256 expectedTotalPrice,
        uint256 actualTotalPrice
    );

    error AuctionQueryInvalidRange();

    error AuctionStartAfterEnd(uint32 startTimestamp, uint32 endTimestamp);

    error AuctionBufferBpsExceedsMax();

    error AuctionDoesNotExist();

    error AuctionNotActive();

    error AuctionNotEnded(uint32 endTimestamp, uint256 currentTimestamp);

    error AuctionHasBids(uint256 numberOfBids);

    error AuctionHasNoBids();

    error AuctionReserveNotMet(uint256 highestBidAmount, uint256 reserveBidAmount);

    error AuctionReserveWasMet(uint256 highestBidAmount, uint256 reserveBidAmount);

    error AuctionPreviousBidRefundRejected();

    error AuctionNotStarted(uint32 startTimestamp, uint256 currentTimestamp);

    error AuctionHasEnded();

    error AuctionBidAmountZero();

    error AuctionBidBelowMinimum(uint256 bidAmount, uint256 minimumBidAmount);

    error AuctionBidAmountNotEqualValue(uint256 bidAmount, uint256 transactionValue);

    error AuctionBidAmountInsufficient(uint256 bidAmount, uint256 requiredBidAmount);

    error WithdrawalRecipientNotApproved();

    error WithdrawalRecipientRejectedTransfer();

    error WithdrawalInsufficientBalance(uint256 requested, uint256 available);
}


// File: contracts/base/interface/IProductToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @author Syky - Nathan Rempel

interface IProductToken {
    /*//////////////////////////////////////////////////////////////
                        Methods
    //////////////////////////////////////////////////////////////*/

    /// @notice Lets an authorized address mint single NFTs to a recipient.
    function mintTo(address _to, uint256 _productId) external;

    function mintTo(address _to, uint256 _productId, bytes memory _data) external;

    function mintTo(
        address _to,
        uint256 _productId,
        string calldata _uri,
        bytes memory _data
    ) external;

    /// @notice Lets an authorized address mint multiple NFTs at once to a recipient.
    function batchMintTo(address _to, uint256 _productId, uint256 _quantity) external;

    function batchMintTo(
        address _to,
        uint256 _productId,
        uint256 _quantity,
        bytes memory _data
    ) external;

    function batchMintTo(
        address _to,
        uint256 _productId,
        uint256 _quantity,
        string[] calldata _uris,
        bytes memory _data
    ) external;

    /*//////////////////////////////////////////////////////////////
                        Events
    //////////////////////////////////////////////////////////////*/

    /// @dev Emitted when all minting is enabled or disabled
    event GlobalMintingRestricted(bool restricted);

    /// @dev Emitted when all transfers are enabled or disabled
    event GlobalTransfersRestricted(bool restricted);

    /// @dev Emitted when all burning is enabled or disabled
    event GlobalBurningRestricted(bool restricted);

    /*//////////////////////////////////////////////////////////////
                        Errors
    //////////////////////////////////////////////////////////////*/

    /// @dev URIs array length for batch mint must match _quantity
    error BatchMintURICountMismatch();

    /// @dev Action requires the manager or admin role
    error ManagerRoleRequired();

    /// @dev Action requires the minting or admin role
    error MintingRoleRequired();

    /// @dev Minting has been disabled via address(0) role
    error GlobalMintingDisabled();

    /// @dev Transfers have been disabled via address(0) role
    error GlobalTransfersDisabled();

    /// @dev Burning has been disabled via address(0) role
    error GlobalBurningDisabled();
}


// File: contracts/base/interface/IVipManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @author Syky - Nathan Rempel

interface IVipManager {
    struct VipConditions {
        GroupConditions groupConditions;
        ProductConditions[] productConditions;
        ERC721Conditions[] erc721Conditions;
        ERC1155Conditions[] erc1155Conditions;
    }

    struct VipConditionsData {
        uint256 productLength;
        uint256 erc721Length;
        uint256 erc1155Length;
        GroupConditions groupConditions;
        mapping(uint256 => ERC721Conditions) erc721Conditions;
        mapping(uint256 => ERC1155ConditionsData) erc1155Conditions;
        mapping(uint256 => ProductConditionsData) productConditions;
    }

    struct GroupConditions {
        address groupContract;
        uint256 groupId;
    }

    struct ERC721Conditions {
        address tokenContract;
    }

    struct ProductConditions {
        address tokenContract;
        uint256[] productIds;
    }

    struct ERC1155Conditions {
        address tokenContract;
        uint256[] tokenIds;
    }

    struct ERC1155ConditionsData {
        address tokenContract;
        uint96 length;
        mapping(uint256 => uint256) tokenIds;
    }

    struct ProductConditionsData {
        address tokenContract;
        uint96 length;
        mapping(uint256 => uint256) productIds;
    }

    function isVip(uint256 _selectorId, address _member) external view returns (bool);

    error ManagerRoleRequired();

    event VipSelectorConditionsUpdated(
        uint256 indexed selectorId,
        uint256 indexed conditionsId
    );

    event VipConditionsUpdated(uint256 indexed conditionsId, VipConditions conditions);
}


// File: contracts/base/ProductMarket.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @author Syky - Nathan Rempel

import "./interface/IProductMarket.sol";
import "./interface/IProductToken.sol";
import "./interface/IVipManager.sol";

import "@thirdweb-dev/contracts/extension/Permissions.sol";
import "@thirdweb-dev/contracts/lib/TWAddress.sol";

contract ProductMarket is IProductMarket, Permissions {
    using TWAddress for address;

    /*//////////////////////////////////////////////////////////////
                            Constants
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant FINANCE_ROLE = keccak256("FINANCE_ROLE");
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    /// @dev The max bps of the contract. So, 10_000 == 100 %
    uint64 private constant MAX_BPS = 10_000;

    /*//////////////////////////////////////////////////////////////
                            Mappings
    //////////////////////////////////////////////////////////////*/

    address private _vipContract;

    //counter for total listings created
    uint256 private _totalListings;

    //counter for total auctions created
    uint256 private _totalAuctions;

    //mapping of sale parameters to listingId
    mapping(uint256 => Listing) private _listings;

    //reverse lookup of listings by productId
    mapping(uint256 => ProductLookup) private _productListings;

    //mapping of product token address to listingId
    mapping(uint256 => address) private _listingContracts;

    //mapping of purchases made by an address to listingId
    mapping(uint256 => mapping(address => uint256)) private _listingPurchases;

    //mapping of auction parameters to auctionId
    mapping(uint256 => Auction) private _auctions;

    //reverse lookup of auctions by productId
    mapping(uint256 => ProductLookup) private _productAuctions;

    //mapping of product token address to auctionId
    mapping(uint256 => address) private _auctionContracts;

    //mapping of auction bids to auctionId
    mapping(uint256 => BidHistory) private _auctionBids;

    //mapping of auction bids to address
    mapping(address => BidHistory) private _addressBids;

    //mapping of approved withdrawal addresses
    mapping(address => bool) private _withdrawalApproved;

    /*//////////////////////////////////////////////////////////////
                            Constructor
    //////////////////////////////////////////////////////////////*/

    constructor(address defaultAdmin_, address defaultToken_, address vipContract_) {
        _listingContracts[0] = defaultToken_;
        _auctionContracts[0] = defaultToken_;
        _vipContract = vipContract_;
        _setupRole(DEFAULT_ADMIN_ROLE, defaultAdmin_);
        _setRoleAdmin(FINANCE_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    /*//////////////////////////////////////////////////////////////
                        Admin functions
    //////////////////////////////////////////////////////////////*/

    function setVipContract(address _vipContract_) external onlyManager {
        _vipContract = _vipContract_;
    }

    function createListing(
        ListingParams calldata _params
    ) external onlyManager returns (uint256 listingId) {
        // overflow is impossible short of 2**256-1 listings being created
        unchecked {
            listingId = ++_totalListings;
        }

        Listing storage listing = _listings[listingId];

        if (_params.pubStartTimestamp < _params.vipStartTimestamp)
            revert ListingVipStartAfterPubStart(
                _params.vipStartTimestamp,
                _params.pubStartTimestamp
            );
        if (_params.endTimestamp <= _params.pubStartTimestamp)
            revert ListingPubStartAfterEnd(
                _params.pubStartTimestamp,
                _params.endTimestamp
            );
        if (_params.quantity < _params.reserved)
            revert ListingReserveExceedsQuantity(_params.reserved, _params.quantity);

        listing.productId = _params.productId;
        listing.enabled = _params.enabled ? 1 : 0;
        listing.quantity = _params.quantity;
        listing.reserved = _params.reserved;
        listing.vipLimit = _params.vipLimit;
        listing.pubLimit = _params.pubLimit;
        listing.vipPrice = _params.vipPrice;
        listing.pubPrice = _params.pubPrice;
        listing.endTimestamp = _params.endTimestamp;
        listing.vipStartTimestamp = _params.vipStartTimestamp;
        listing.pubStartTimestamp = _params.pubStartTimestamp;

        //reverse lookup
        unchecked {
            uint256 reverseIdx = _productListings[_params.productId].count++;
            _productListings[_params.productId].id[reverseIdx] = listingId;
        }

        emit ListingAdded(listingId, listing);
    }

    function updateListing(
        uint256 _listingId,
        ListingParams calldata _params
    ) external onlyManager {
        Listing storage listing = _listings[_listingId];

        if (listing.productId == 0) revert ListingDoesNotExist();
        if (_params.pubStartTimestamp < _params.vipStartTimestamp)
            revert ListingVipStartAfterPubStart(
                _params.vipStartTimestamp,
                _params.pubStartTimestamp
            );
        if (_params.endTimestamp <= _params.pubStartTimestamp)
            revert ListingPubStartAfterEnd(
                _params.pubStartTimestamp,
                _params.endTimestamp
            );
        if (_params.quantity < _params.reserved)
            revert ListingReserveExceedsQuantity(_params.reserved, _params.quantity);

        unchecked {
            uint256 totalPurchased = listing.vipPurchased + listing.pubPurchased;

            if (_params.quantity < totalPurchased)
                revert ListingPurchasesExceedsQuantity(_params.quantity, totalPurchased);
            if (_params.reserved < listing.resPurchased)
                revert ListingPurchasesExceedsReserve(
                    _params.reserved,
                    listing.resPurchased
                );
        }

        listing.enabled = _params.enabled ? 1 : 0;
        listing.quantity = _params.quantity;
        listing.reserved = _params.reserved;
        listing.vipLimit = _params.vipLimit;
        listing.pubLimit = _params.pubLimit;
        listing.vipPrice = _params.vipPrice;
        listing.pubPrice = _params.pubPrice;
        listing.endTimestamp = _params.endTimestamp;
        listing.vipStartTimestamp = _params.vipStartTimestamp;
        listing.pubStartTimestamp = _params.pubStartTimestamp;

        emit ListingUpdated(_listingId, listing);
    }

    function enableListing(uint256 _listingId, bool _enabled) external onlyManager {
        _listings[_listingId].enabled = _enabled ? 1 : 0;
        emit ListingEnabled(_listingId, _enabled);
    }

    function setListingContract(
        uint256 _listingId,
        address _tokenContract
    ) external onlyManager {
        _listingContracts[_listingId] = _tokenContract;
        emit ListingContract(_listingId, _tokenContract);
    }

    function setAuctionContract(
        uint256 _auctionId,
        address _tokenContract
    ) external onlyManager {
        _auctionContracts[_auctionId] = _tokenContract;
        emit AuctionContract(_auctionId, _tokenContract);
    }

    function createAuction(
        AuctionParams calldata _params
    ) external onlyManager returns (uint256 auctionId) {
        unchecked {
            auctionId = ++_totalAuctions;
        }

        Auction storage auction = _auctions[auctionId];

        if (_params.endTimestamp <= _params.startTimestamp)
            revert AuctionStartAfterEnd(_params.startTimestamp, _params.endTimestamp);
        if (MAX_BPS < _params.bidBufferBps) revert AuctionBufferBpsExceedsMax();

        auction.productId = _params.productId;
        auction.status = AuctionStatus.CREATED;
        auction.startTimestamp = _params.startTimestamp;
        auction.endTimestamp = _params.endTimestamp;
        auction.bidBufferBps = _params.bidBufferBps;
        auction.timeBufferSeconds = _params.timeBufferSeconds;
        auction.minimumBidAmount = _params.minimumBidAmount;
        auction.reserveBidAmount = _params.reserveBidAmount;

        unchecked {
            uint256 reverseIdx = _productAuctions[_params.productId].count++;
            _productAuctions[_params.productId].id[reverseIdx] = auctionId;
        }

        emit AuctionAdded(auctionId, auction);
    }

    function updateAuction(
        uint256 _auctionId,
        AuctionParams calldata _params
    ) external onlyManager {
        Auction storage auction = _auctions[_auctionId];

        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();
        if (auction.status != AuctionStatus.CREATED) revert AuctionNotActive();
        if (_params.endTimestamp <= _params.startTimestamp)
            revert AuctionStartAfterEnd(_params.startTimestamp, _params.endTimestamp);
        if (MAX_BPS < _params.bidBufferBps) revert AuctionBufferBpsExceedsMax();

        auction.startTimestamp = _params.startTimestamp;
        auction.endTimestamp = _params.endTimestamp;
        auction.bidBufferBps = _params.bidBufferBps;
        auction.timeBufferSeconds = _params.timeBufferSeconds;
        auction.minimumBidAmount = _params.minimumBidAmount;
        auction.reserveBidAmount = _params.reserveBidAmount;

        emit AuctionUpdated(_auctionId, auction);
    }

    function cancelAuction(uint256 _auctionId) external onlyManager {
        Auction storage auction = _auctions[_auctionId];

        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();
        if (auction.status != AuctionStatus.CREATED) revert AuctionNotActive();
        if (_auctionBids[_auctionId].count != 0)
            revert AuctionHasBids(_auctionBids[_auctionId].count);

        auction.status = AuctionStatus.CANCELLED;

        emit AuctionCancelled(_auctionId);
    }

    function rewardAuction(
        uint256 _auctionId,
        bool _allowUnmetReserve
    ) external onlyManager {
        Auction storage auction = _auctions[_auctionId];

        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();
        if (auction.status != AuctionStatus.CREATED) revert AuctionNotActive();
        if (block.timestamp < auction.endTimestamp)
            revert AuctionNotEnded(auction.endTimestamp, block.timestamp);

        uint256 numberOfBids = _auctionBids[_auctionId].count;
        if (numberOfBids == 0) revert AuctionHasNoBids();

        Bid memory winningBid = _auctionBids[_auctionId].bids[numberOfBids - 1];
        if (winningBid.bidAmount < auction.reserveBidAmount && !_allowUnmetReserve)
            revert AuctionReserveNotMet(winningBid.bidAmount, auction.reserveBidAmount);

        //reentrancy protection
        auction.status = AuctionStatus.COMPLETED;

        IProductToken(getAuctionContract(_auctionId)).mintTo(
            winningBid.bidder,
            auction.productId
        );

        emit AuctionClosed(
            _auctionId,
            winningBid.bidder,
            winningBid.bidAmount,
            auction.productId,
            true,
            false
        );
    }

    function closeAuction(uint256 _auctionId) external onlyManager {
        Auction storage auction = _auctions[_auctionId];

        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();
        if (auction.status != AuctionStatus.CREATED) revert AuctionNotActive();
        if (block.timestamp < auction.endTimestamp)
            revert AuctionNotEnded(auction.endTimestamp, block.timestamp);

        uint256 numberOfBids = _auctionBids[_auctionId].count;
        if (numberOfBids == 0) revert AuctionHasNoBids();

        Bid memory winningBid = _auctionBids[_auctionId].bids[numberOfBids - 1];
        if (auction.reserveBidAmount <= winningBid.bidAmount)
            revert AuctionReserveWasMet(winningBid.bidAmount, auction.reserveBidAmount);

        //reentrancy protection
        auction.status = AuctionStatus.COMPLETED;

        (bool success, ) = winningBid.bidder.call{value: winningBid.bidAmount}("");
        if (!success) revert AuctionPreviousBidRefundRejected();

        emit AuctionClosed(
            _auctionId,
            winningBid.bidder,
            winningBid.bidAmount,
            auction.productId,
            false,
            true
        );
    }

    /// @dev Sets `_recipient` as `_approved` for withdrawing income.
    function approveWithdrawalRecipient(
        address _recipient,
        bool _approved
    ) external onlyFinance {
        _withdrawalApproved[_recipient] = _approved;

        emit WithdrawalRecipientApproved(_recipient, _approved);
    }

    /// @dev Transfers `_amount` of native token to `_account`. `_account` must be approved.
    function withdrawIncome(
        address payable _recipient,
        uint256 _amount
    ) external onlyFinance {
        if (address(this).balance < _amount)
            revert WithdrawalInsufficientBalance(_amount, address(this).balance);
        if (!_withdrawalApproved[_recipient]) revert WithdrawalRecipientNotApproved();

        (bool success, ) = _recipient.call{value: _amount}("");
        if (!success) revert WithdrawalRecipientRejectedTransfer();

        emit IncomeWithdrawal(msg.sender, _recipient, _amount);
    }

    /*//////////////////////////////////////////////////////////////
                        Public functions
    //////////////////////////////////////////////////////////////*/

    function buyFromListing(
        uint256 _listingId,
        address _buyFor,
        uint256 _quantity,
        uint256 _expectedTotalPrice
    ) external payable {
        Listing storage listing = _listings[_listingId];

        if (listing.productId == 0) revert ListingDoesNotExist();
        if (listing.enabled == 0) revert ListingNotEnabled();
        if (_expectedTotalPrice != msg.value)
            revert ListingExpectedPriceNotEqualValue(_expectedTotalPrice, msg.value);
        if (listing.endTimestamp < block.timestamp) revert ListingHasEnded();
        unchecked {
            uint256 availableQuantity = listing.quantity -
                (listing.vipPurchased + listing.pubPurchased);

            if (availableQuantity < _quantity)
                revert ListingInsufficientQuantity(_quantity, availableQuantity);
        }

        uint256 listingPurchases = _listingPurchases[_listingId][msg.sender] + _quantity;

        //usually prefer non-duplicate code but this allows for custom messages and less memory use
        if (_checkListingVip(_listingId, msg.sender)) {
            if (block.timestamp < listing.vipStartTimestamp)
                revert ListingVipSaleNotStarted(
                    listing.vipStartTimestamp,
                    block.timestamp
                );
            if (listing.vipLimit < listingPurchases)
                revert ListingVipLimitExceeded(listingPurchases, listing.vipLimit);

            uint256 actualTotalPrice = listing.vipPrice * _quantity;
            if (actualTotalPrice != _expectedTotalPrice)
                revert ListingVipExpectedPriceInvalid(
                    _expectedTotalPrice,
                    actualTotalPrice
                );

            unchecked {
                //if VIP purchases are occuring BEFORE the external window, use the reserve
                if (block.timestamp < listing.pubStartTimestamp) {
                    //not allowed in creation or update to exceed
                    uint256 reserveAvailable = listing.reserved - listing.resPurchased;
                    if (reserveAvailable < _quantity)
                        revert ListingVipReserveExceeded(_quantity, reserveAvailable);
                    listing.resPurchased += uint16(_quantity);
                }

                listing.vipPurchased += uint16(_quantity);
                listing.vipIncome += uint72(_expectedTotalPrice);
            }
        } else {
            if (block.timestamp < listing.pubStartTimestamp)
                revert ListingPublicSaleNotStarted(
                    listing.pubStartTimestamp,
                    block.timestamp
                );
            if (listing.pubLimit < listingPurchases)
                revert ListingPublicLimitExceeded(listingPurchases, listing.pubLimit);

            uint256 actualTotalPrice = listing.pubPrice * _quantity;
            if (actualTotalPrice != _expectedTotalPrice)
                revert ListingPublicExpectedPriceInvalid(
                    _expectedTotalPrice,
                    actualTotalPrice
                );

            unchecked {
                listing.pubPurchased += uint16(_quantity);
                listing.pubIncome += uint72(_expectedTotalPrice);
            }
        }

        //perform updates before transfer to avoid re-entrancy
        _listingPurchases[_listingId][msg.sender] = listingPurchases;

        IProductToken(getListingContract(_listingId)).batchMintTo(
            _buyFor,
            listing.productId,
            _quantity
        );

        emit NewSale(
            _listingId,
            msg.sender,
            _buyFor,
            listing.productId,
            _quantity,
            _expectedTotalPrice
        );
    }

    function bidInAuction(uint256 _auctionId, uint256 _bidAmount) external payable {
        Auction memory auction = _auctions[_auctionId];

        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();
        if (auction.status != AuctionStatus.CREATED) revert AuctionNotActive();
        if (block.timestamp < auction.startTimestamp)
            revert AuctionNotStarted(auction.startTimestamp, block.timestamp);
        if (auction.endTimestamp < block.timestamp) revert AuctionHasEnded();
        if (_bidAmount == 0) revert AuctionBidAmountZero();
        if (_bidAmount < auction.minimumBidAmount)
            revert AuctionBidBelowMinimum(_bidAmount, auction.minimumBidAmount);
        if (_bidAmount != msg.value)
            revert AuctionBidAmountNotEqualValue(_bidAmount, msg.value);

        uint256 numberOfBids = _auctionBids[_auctionId].count;
        if (numberOfBids > 0) {
            Bid memory previousBid = _auctionBids[_auctionId].bids[numberOfBids - 1];

            unchecked {
                uint256 requiredBidAmount = previousBid.bidAmount +
                    ((previousBid.bidAmount * auction.bidBufferBps) / MAX_BPS);

                if (_bidAmount < requiredBidAmount)
                    revert AuctionBidAmountInsufficient(_bidAmount, requiredBidAmount);
            }
            (bool success, ) = previousBid.bidder.call{value: previousBid.bidAmount}("");
            if (!success) revert AuctionPreviousBidRefundRejected();

            // Reentrancy protection
            if (_auctionBids[_auctionId].count != numberOfBids) revert();
        }

        unchecked {
            ++_auctionBids[_auctionId].count;
        }

        Bid memory newBid = Bid({
            auctionId: uint64(_auctionId),
            bidTimestamp: uint32(block.timestamp),
            bidder: msg.sender,
            bidAmount: _bidAmount
        });

        _auctionBids[_auctionId].bids[numberOfBids] = newBid;

        unchecked {
            uint256 addressBids = _addressBids[msg.sender].count++;

            _addressBids[msg.sender].bids[addressBids] = newBid;
        }

        if (auction.endTimestamp - block.timestamp <= auction.timeBufferSeconds) {
            unchecked {
                auction.endTimestamp += uint32(auction.timeBufferSeconds);
            }
            _auctions[_auctionId] = auction;
        }

        emit NewBid(_auctionId, msg.sender, _bidAmount, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        Public getters
    //////////////////////////////////////////////////////////////*/

    function getVipContract() external view returns (address) {
        return _vipContract;
    }

    function totalListings() external view returns (uint256) {
        return _totalListings;
    }

    function getListingContract(uint256 _listingId) public view returns (address) {
        if (_listingContracts[_listingId] == address(0)) {
            return _listingContracts[0];
        } else {
            return _listingContracts[_listingId];
        }
    }

    function getListing(
        uint256 _listingId
    ) external view returns (ListingQuery memory _listing) {
        return ListingQuery({listingId: _listingId, listingData: _listings[_listingId]});
    }

    function getAllProductListings(
        uint256 _productId
    ) external view returns (ListingQuery[] memory _allListings) {
        ProductLookup storage productLookup = _productListings[_productId];
        uint256 count = productLookup.count;
        _allListings = new ListingQuery[](count);
        for (uint256 i; i < count; ) {
            uint256 listingId = productLookup.id[i];
            _allListings[i] = ListingQuery({
                listingId: listingId,
                listingData: _listings[listingId]
            });
            unchecked {
                ++i;
            }
        }
    }

    function getAllListings(
        uint256 _startId,
        uint256 _endId
    ) external view returns (ListingQuery[] memory _allListings) {
        if (_startId == 0 || _endId < _startId) revert ListingQueryInvalidRange();
        unchecked {
            uint256 maxId = (_endId > _totalListings ? _totalListings : _endId) + 1;

            _allListings = new ListingQuery[](maxId - _startId);

            for (uint256 i = _startId; i < maxId; ) {
                _allListings[i - _startId] = ListingQuery({
                    listingId: i,
                    listingData: _listings[i]
                });
                ++i;
            }
        }
    }

    function getWithdrawalApproved(address _recipient) external view returns (bool) {
        return _withdrawalApproved[_recipient];
    }

    function totalAuctions() external view returns (uint256) {
        return _totalAuctions;
    }

    function getAuctionContract(uint256 _auctionId) public view returns (address) {
        if (_auctionContracts[_auctionId] == address(0)) {
            return _auctionContracts[0];
        } else {
            return _auctionContracts[_auctionId];
        }
    }

    function getAuction(
        uint256 _auctionId
    ) external view returns (AuctionQuery memory _auction) {
        unchecked {
            uint256 numberOfBids = _auctionBids[_auctionId].count;

            return
                AuctionQuery({
                    auctionId: _auctionId,
                    auctionData: _auctions[_auctionId],
                    winningBid: _auctionBids[_auctionId].bids[
                        numberOfBids > 0 ? numberOfBids - 1 : 0
                    ]
                });
        }
    }

    function getAllProductAuctions(
        uint256 _productId
    ) external view returns (AuctionQuery[] memory _allAuctions) {
        ProductLookup storage productLookup = _productAuctions[_productId];
        uint256 count = productLookup.count;
        _allAuctions = new AuctionQuery[](count);
        for (uint256 i; i < count; ) {
            uint256 auctionId = productLookup.id[i];
            uint256 numberOfBids = _auctionBids[i].count;
            unchecked {
                _allAuctions[i] = AuctionQuery({
                    auctionId: auctionId,
                    auctionData: _auctions[auctionId],
                    winningBid: _auctionBids[auctionId].bids[
                        numberOfBids > 0 ? numberOfBids - 1 : 0
                    ]
                });
                ++i;
            }
        }
    }

    function getAllAuctions(
        uint256 _startId,
        uint256 _endId
    ) external view returns (AuctionQuery[] memory _allAuctions) {
        if (_startId == 0 || _endId < _startId) revert AuctionQueryInvalidRange();
        unchecked {
            uint256 maxId = (_endId > _totalAuctions ? _totalAuctions : _endId) + 1;

            _allAuctions = new AuctionQuery[](maxId - _startId);

            for (uint256 i = _startId; i < maxId; ) {
                uint256 numberOfBids = _auctionBids[i].count;

                _allAuctions[i - _startId] = AuctionQuery({
                    auctionId: i,
                    auctionData: _auctions[i],
                    winningBid: _auctionBids[i].bids[
                        numberOfBids > 0 ? numberOfBids - 1 : 0
                    ]
                });

                ++i;
            }
        }
    }

    function getAuctionBids(
        uint256 _auctionId
    ) external view returns (Bid[] memory _bids) {
        uint256 numberOfBids = _auctionBids[_auctionId].count;
        _bids = new Bid[](numberOfBids);
        for (uint256 i; i < numberOfBids; ) {
            _bids[i] = _auctionBids[_auctionId].bids[i];
            unchecked {
                ++i;
            }
        }
    }

    function getAddressBids(address _bidder) external view returns (Bid[] memory _bids) {
        uint256 numberOfBids = _addressBids[_bidder].count;
        _bids = new Bid[](numberOfBids);
        for (uint256 i; i < numberOfBids; ) {
            _bids[i] = _addressBids[_bidder].bids[i];
            unchecked {
                ++i;
            }
        }
    }

    function getWinningBidAmount(uint256 _auctionId) external view returns (uint256) {
        Auction memory auction = _auctions[_auctionId];
        if (auction.status == AuctionStatus.UNSET) revert AuctionDoesNotExist();

        uint256 numberOfBids = _auctionBids[_auctionId].count;
        if (numberOfBids > 0) {
            unchecked {
                Bid memory previousBid = _auctionBids[_auctionId].bids[numberOfBids - 1];
                return
                    previousBid.bidAmount +
                    ((previousBid.bidAmount * auction.bidBufferBps) / MAX_BPS);
            }
        }

        return auction.minimumBidAmount;
    }

    /*//////////////////////////////////////////////////////////////
                            Modifiers
    //////////////////////////////////////////////////////////////*/

    /// @dev Modifier that checks if an account has admin or finance role; reverts otherwise.
    modifier onlyFinance() {
        _checkFinanceAdmin();
        _;
    }

    /// @dev Modifier that checks if an account has admin or manager role; reverts otherwise.
    modifier onlyManager() {
        _checkManagerAdmin();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                        Internal functions
    //////////////////////////////////////////////////////////////*/

    /// @dev Function that checks if an account has admin or finance role; reverts otherwise.
    function _checkFinanceAdmin() internal view {
        if (
            !hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && !hasRole(FINANCE_ROLE, msg.sender)
        ) {
            revert FinanceRoleRequired();
        }
    }

    /// @dev Function that checks if an account has admin or manager role; reverts otherwise.
    function _checkManagerAdmin() internal view {
        if (
            !hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && !hasRole(MANAGER_ROLE, msg.sender)
        ) {
            revert ManagerRoleRequired();
        }
    }

    function _checkListingVip(
        uint256 _listingId,
        address _member
    ) internal view returns (bool) {
        if (_vipContract != address(0))
            return IVipManager(_vipContract).isVip(_listingId, _member);
        return false;
    }
}


// File: contracts/syky/SykyMarket.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @author Syky - Nathan Rempel

/*
           @@@   @@@@@   @@@@@@@         @@@@    @@@@@@@      @@@@@     @@@@@@@        @@@@
         @@@@      @@@     @@@@@@        @@       @@@@@@       @@        @@@@@@        @@
         @@@@@      @@      @@@@@       @@        @@@@@       @            @@@@@      @@
         @@@@@@      @@      @@@@@     @@         @@@@@     @               @@@@     @@
          @@@@@@      @       @@@@@   @@          @@@@@    @                @@@@@    @
           @@@@@@@             @@@@@ @@           @@@@@  @@@                 @@@@@  @
             @@@@@@             @@@@@@            @@@@@@@@@@@                 @@@@@@
               @@@@@@           @@@@@             @@@@@  @@@@@                 @@@@@
                @@@@@@@         @@@@@             @@@@@   @@@@@                @@@@@
         @        @@@@@@        @@@@@             @@@@@    @@@@@               @@@@@
         @@        @@@@@        @@@@@             @@@@@     @@@@@              @@@@@
         @@@@      @@@@@        @@@@@             @@@@@@     @@@@@@           @@@@@@
         @@@@@@   @@@@         @@@@@@@           @@@@@@@     @@@@@@@          @@@@@@@
*/

import "../base/ProductMarket.sol";

contract SykyMarket is ProductMarket {
    /*//////////////////////////////////////////////////////////////
                            Version Info
    //////////////////////////////////////////////////////////////*/

    string public constant ENV = "MAINNET";
    string public constant VER = "1.0.1";

    /*//////////////////////////////////////////////////////////////
                            Constructor
    //////////////////////////////////////////////////////////////*/

    constructor(
        address defaultAdmin_,
        address defaultToken_,
        address vipContract_
    ) ProductMarket(defaultAdmin_, defaultToken_, vipContract_) {}
}

