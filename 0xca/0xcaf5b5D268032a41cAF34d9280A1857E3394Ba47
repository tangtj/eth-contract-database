
// File: VestingExecutor.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.9;

/// @title: Vesting Executor
/// @author: davoice321

import "VestingManager.sol";
import "TokenLock.sol";

/**
 * Vesting Executor contract interacts with, and is the owner, of Vesting Manager. 
 Contract executes:
- Purchasing of vested tokens at varying prices. After purchase, asset is vested on behalf of user
- Swapping of asset for a vested asset (at a pre-defined ratio); after swap, asset is vested on behalf of swapper
- Standard vesting transaction: Assign a vesting schedule to an account 
- Cancellation of individual vesting schedules (limited to multisig)
- Withdrawal of unlocked tokens from Vesting Manager account (limited to multisig)
- Vesting and swapping are only possible when vesting/swapping is active 
- Asset claiming at end of cliff period on behalf of vestors 

Contract allows for multiple: 
- Assets to be vested simultaneously 
- Tokens to be used to purchase vested assets 
- Tokens to be used to swap for vested assets 
 */

contract VestingExecutor is Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    /* ========== State Variables ========== */

    address payable immutable TREASURY =
        payable(0xf950a86013bAA227009771181a885E369e158da3);

    uint256 public purchaseAmountThreshold; // Amount of vesting token that must be purchased to trigger immediate release of coins
    uint256 public releasePercentage; // Percentage of total amount that will be released
    uint256 public swapRatio; // Ratio that will determine how many swap tokens can be exchanged for vesting tokens
    VestingManager public vestingManager; // Vesting Manager contract
    TokenLock public tokenLock; // Contract where swapped tokens are deposited; Contract has no owner or withdraw functions

    /* ========== Structs and Mappings ========== */

    /**
     * @notice Vesting parameters struct.
     * @dev This struct holds necessary parameters for vesting.
     * @param asset The asset that the users are being vested.
     * @param isFixed If true, the vesting schedule cannot be cancelled
     * @param cliffWeeks The number of weeks that the cliff will be present at.
     * @param vestingWeeks The number of weeks the tokens will vest over (linearly).
     * @param startTime The timestamp for when this vesting should have started.
     */
    struct VestingParams {
        address asset;
        bool isFixed;
        uint256 cliffWeeks;
        uint256 vestingWeeks;
        uint256 startTime;
    }

    VestingParams public vestingParams;

    /**
     * @notice Valid vesting params struct
     * @dev This struct holds valid parameters for vesting.
     * @param purchaseCliffWeeks The number of weeks that the cliff will be present at (purchases)
     * @param purchaseVestingWeeks The number of weeks the tokens will vest over (linearly - purchases).
     * @param swapCliffWeeks The number of weeks that the cliff will be present at (swaps)
     * @param swapVestingWeeks The number of weeks the tokens will vest over (linearly - swaps)
     */

    struct ValidVestingParams {
        uint256 purchaseCliffWeeks;
        uint256 purchaseVestingWeeks;
        uint256 swapCliffWeeks;
        uint256 swapVestingWeeks;
    }

    ValidVestingParams public validVestingParams;

    /**
     * @dev Struct to represent approved purchase tokens
     * @param token IERC20 token that has been approved for purchase
     * @param decimals Number of decimals the token uses
     */
    struct approvedPurchaseTokens {
        IERC20 token;
        uint256 decimals;
        uint256 numDecimals;
    }

    mapping(address => approvedPurchaseTokens) public purchaseTokens;

    /**
     * @dev Struct to represent tokens available for vesting
     * @param token IERC20 token that is available for vesting
     * @param decimals Number of decimals the token uses
     */
    struct VestingTokens {
        IERC20 token;
        uint256 decimals;
        uint256 numDecimals;
        uint256 price;
    }

    mapping(address => VestingTokens) public vestingTokens;

    /**
     * @dev Struct to represent authorized swap tokens
     * @param token IERC20 token that has been authorized for swap
     * @param decimals Number of decimals the token uses
     */
    struct AuthorizedSwapTokens {
        IERC20 token;
        uint256 decimals;
    }

    mapping(address => AuthorizedSwapTokens) public authorizedSwapTokens;

    /**
     * @dev Struct to represent authorized swap whitelist addresses
     * @param address address to be added to whitelist
     * @param string status of whitelisted address
     */
    struct AuthorizedSwapAddresses {
        address whitelistaddress;
        bool isSet;
    }

    mapping(address => AuthorizedSwapAddresses) public authorizedSwapAddresses;

    /* ========== Events ========== */

    event vestingTransactionComplete(address vester, uint256 vestedAssetAmount);
    event vestingPurchaseTransactionComplete(
        address indexed vester,
        uint256 vestedAssetAmount,
        address purchaseToken,
        uint256 amountTransferred
    );
    event vestingTokenWithdrawal(address token, uint256 withdrawalAmount);
    event tokenLockWithdrawal(
        IERC20 token,
        address to,
        uint256 withdrawalAmount
    );
    event addressesAddedToWhiteList(address[] addresses);
    event bonusVestingTokenTransfered(
        address recipient,
        uint256 transferAmount
    );
    event processLog(string description, uint256 number);
    event processLog2(string message);
    event processLog3(address address2);

    /* ========== Constructor ========== */

    /**
     * @notice Deploys the Vesting Manager contract and sets the Vesting Executor as the owner of the VestingManager.
     Also deploys the Token Lock contract, which has no owner and no withdrawal functions; used to "burn" tokens swapped for vesting assets
     * @dev The VestingExecutor contract initializes the VestingManager contract during its own deployment.
     Constructor also sets the default purchase tokens: DAI, USDC and USDT.
     */
    constructor() {
        // Deploy a new instance of VestingManager, and TokenLock setting VestingExecutor (this contract) as the owner
        vestingManager = new VestingManager(address(this));
        tokenLock = new TokenLock(address(this));

        // Add initial valid purchase tokens to list (DAI, USDC, USDT)
        purchaseTokens[
            address(0x6B175474E89094C44Da98b954EedeAC495271d0F) //DAI
        ] = approvedPurchaseTokens({
            token: IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F),
            decimals: 10 ** 18,
            numDecimals: 18
        });

        purchaseTokens[
            address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) //USDC
        ] = approvedPurchaseTokens({
            token: IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48),
            decimals: 10 ** 6,
            numDecimals: 6
        });

        purchaseTokens[
            address(0xdAC17F958D2ee523a2206206994597C13D831ec7) //USDT
        ] = approvedPurchaseTokens({
            token: IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7),
            decimals: 10 ** 6,
            numDecimals: 6
        });
    }

    /* ========== Views ========== */

    /**
     * @notice Fetches locked amount of a specific asset (how many tokens locked overall for vesting)
     * @param assetAddress The address of the asset.
     * @return The amount of the asset currently locked.
     */
    function viewLockedAmount(
        address assetAddress
    ) public view returns (uint256) {
        return vestingManager.getLockedAmount(assetAddress);
    }

    /**
     * @notice Returns information about all vesting schedules for a given account
     * @param account The address of the account for which to return vesting schedule information
     * @return An array of ScheduleInfo structs, each containing the ID, cliff timestamp, and end timestamp for a vesting schedule (related to the account)
     */
    function retrieveScheduleInfo(
        address account
    ) public view returns (VestingManager.ScheduleInfo[] memory) {
        VestingManager.ScheduleInfo[] memory schedules = vestingManager
            .getScheduleInfo(account);
        return schedules;
    }

    /**
     * @notice Retrieves claimable token information for each vesting schedule of the given account
     * @param vestorAddress The account address to retrieve the claimable token information for
     * @return An array of structs containing the schedule ID and the corresponding number of claimable tokens
     */
    function retrieveClaimableTokens(
        address vestorAddress
    ) public view returns (VestingManager.ClaimableInfo[] memory) {
        VestingManager.ClaimableInfo[] memory claimInformation = vestingManager
            .retrieveClaimableTokens(vestorAddress);
        return claimInformation;
    }

    /**
     * @notice Fetches the data related to token claiming activity for a specific address
     * @param _vestorAddress The address of the vestor
     * @return Data related to asset claims by the vestor
     */
    function retrieveTokenClaimData(
        address _vestorAddress
    ) public view returns (VestingManager.TokenClaimInfo[] memory) {
        return vestingManager.getTokenClaimData(_vestorAddress);
    }

    /* ========== Modifiers ========== */

    /**
     * @notice Modifier to only allow certain function calls when vesting is active
     * @dev Reverts if the current vesting status is not active. Used to restrict function calling
     */
    modifier whenVestingActive() {
        require(
            current_vesting_status == vestingStatus.vestingActive,
            "Vesting not active"
        );
        _;
    }

    /**
     * @notice Modifier to enforce that swapping is active
     * @dev Reverts if the current swapping status is not active.
     */
    modifier whenSwappingActive() {
        require(
            current_swapping_status == swappingStatus.swappingActive,
            "Swapping not active"
        );
        _;
    }

    /**
     * @notice Modifier to only allow certain function calls when vesting is active
     * @dev Reverts if the current vesting status is not active. Used to restrict function calling
     */
    modifier whenStandardVestingActive() {
        require(
            current_standard_vesting_status ==
                standardVestingStatus.standardVestingActive,
            "Standard vesting not active"
        );
        _;
    }

    /**
     * @notice Modifier to restrict certain functions to multisig only calls
     * @dev Reverts if the caller is not the treasury.
     */
    modifier multiSigOnly() {
        require(msg.sender == TREASURY, "Multisig not caller");
        _;
    }

    /* ========== Transfer ERC20 Tokens ========== */

    /**
     * @notice Transfers a specific amount of ERC20 tokens to an address.
     * @dev The token transfer is executed using the input token's transfer function. It checks there are enough tokens on
     * the contract's balance before performing the transfer.
     * @param token The address of the ERC20 token contract that we want to make the transfer with.
     * @param to The recipient's address of the tokens.
     * @param amount The amount of tokens to be transferred.
     */

    function transferERC20(
        IERC20 token,
        address to,
        uint256 amount
    ) public onlyOwner {
        _transferERC20(token, to, amount);
    }

    function _transferERC20(IERC20 token, address to, uint256 amount) internal {
        uint256 erc20balance = token.balanceOf(address(this));
        require(amount <= erc20balance, "Balance too low to transfer token");
        token.transfer(to, amount);
    }

    /**
     * @notice Transfers a specific amount of ERC20 tokens from the TokenLock contract to an address.
     * @dev The token transfer is executed using the input token's transfer function. It checks there are enough tokens on
     * the contract's balance before performing the transfer.
     * @param token The address of the ERC20 token contract that we want to make the transfer with.
     * @param to The recipient's address of the tokens.
     * @param amount The amount of tokens to be transferred.
     */
    function transferLockedTokens(
        IERC20 token,
        address to,
        uint256 amount
    ) external onlyOwner {
        tokenLock.transferLockedTokens(token, to, amount);

        emit tokenLockWithdrawal(token, to, amount);
    }

    /* ========== Manage Vesting/Swap/Token Locking/Whitelist Status ========== */

    //Vesting status options
    enum vestingStatus {
        vestingActive, //0
        vestingInactive //1
    }

    //Default vesting status: Active
    vestingStatus public current_vesting_status = vestingStatus.vestingActive;

    /**
     * @notice Changes the vesting status of the contract
     * @dev Can only be called by the contract owner. Changes the status to the input value
     * @param value The new vesting status
     */
    function setVestingStatus(uint256 value) public onlyOwner {
        current_vesting_status = vestingStatus(value);
    }

    //Whitelist status options
    enum whiteListStatus {
        whiteListActive, //0
        whiteListInactive //1
    }

    //Default whitelist status: Inactive
    whiteListStatus public current_whitelist_status =
        whiteListStatus.whiteListInactive;

    /**
     * @notice Changes the whitelist status of the contract
     * @dev Can only be called by the contract owner. Changes the status to the input value
     * @param value The new whitelist status
     */
    function setWhiteListStatus(uint256 value) public onlyOwner {
        current_whitelist_status = whiteListStatus(value);
    }

    //Swapping status options
    enum swappingStatus {
        swappingActive, //0
        swappingInactive //1
    }

    //Default swapping status: Inactive
    swappingStatus public current_swapping_status =
        swappingStatus.swappingInactive;

    /**
     * @notice Changes the swapping status of the contract
     * @dev Can only be called by the contract owner. Changes the status to the input value
     * @param value The new swapping status
     */
    function setSwappingStatus(uint256 value) public onlyOwner {
        current_swapping_status = swappingStatus(value);
    }

    //Standard Vesting status options
    enum standardVestingStatus {
        standardVestingActive, //0
        standardVestingInactive //1
    }

    //Default standard vesting status: Active
    standardVestingStatus public current_standard_vesting_status =
        standardVestingStatus.standardVestingActive;

    /**
     * @notice Changes the vesting status (for standard vesting) of the contract
     * @dev Can only be called by the contract owner. Changes the status to the input value
     * @param value The new vesting status
     */
    function setStandardVestingStatus(uint256 value) public onlyOwner {
        current_standard_vesting_status = standardVestingStatus(value);
    }

    //Token lock options (whether swapped tokens are locked in the Token Lock contract)

    enum tokenLockStatus {
        tokenLockActive, //0
        tokenLockInactive //1
    }

    //Default token lock status: Active
    tokenLockStatus public current_token_lock_status =
        tokenLockStatus.tokenLockActive;

    /**
     * @notice Changes the token lock status of the contract
     * @dev Can only be called by the contract owner. Changes the status to the input value
     * @param value The new token locking status
     */
    function setTokenLockStatus(uint256 value) public onlyOwner {
        current_token_lock_status = tokenLockStatus(value);
    }

    /* ========== Set/Get Approved Purchase Tokens ========== */

    /**
     * @notice Adds a new token to the approved purchase tokens list
     * @dev Can only be called by the contract owner. Reverts if the token already exists on the list or if the address is invalid
     * @param tokenAddress The address of the new token to add
     * @param decimals The decimals of the new token
     * @param numDecimals Decimals of the token
     */
    function addPurchaseToken(
        address tokenAddress,
        uint256 decimals,
        uint256 numDecimals
    ) public onlyOwner {
        require(tokenAddress != address(0), "Invalid token address");
        require(
            address(purchaseTokens[tokenAddress].token) == address(0),
            "Purchase token on list"
        );

        purchaseTokens[tokenAddress] = approvedPurchaseTokens({
            token: IERC20(tokenAddress),
            decimals: decimals,
            numDecimals: numDecimals
        });
    }

    /**
     * @notice Removes a token from the approved purchase tokens list
     * @dev Can only be called by the contract owner. Reverts if the token is not currently on the list.
     * @param tokenAddress The address of the token to remove
     */
    function removePurchaseToken(address tokenAddress) public onlyOwner {
        require(
            address(purchaseTokens[tokenAddress].token) != address(0),
            "Purchase token not on list"
        );

        delete purchaseTokens[tokenAddress];
    }

    /* ========== Set/Get Approved Vesting Tokens ========== */

    /**
     * @notice Adds a new token to the approved vesting tokens list
     * @dev Can only be called by the contract owner. Reverts if the token already exists on the list or if the address is invalid
     * @param tokenAddress The address of the new token to add
     * @param decimals The decimals of the new token
     * @param price The USD price of the new token (multiply by 10^4 before sending to contract)
     * @param numDecimals Decimals of the token
     */
    function addVestingToken(
        address tokenAddress,
        uint256 decimals,
        uint256 price,
        uint256 numDecimals
    ) public onlyOwner {
        require(tokenAddress != address(0), "Invalid token address");
        require(
            address(vestingTokens[tokenAddress].token) == address(0),
            "Vesting token on list"
        );

        require(
            price >= 1 * 10 ** 4 && price <= 200 * 10 ** 4,
            "Price must be scaled to 10 ** 4"
        );

        vestingTokens[tokenAddress] = VestingTokens({
            token: IERC20(tokenAddress),
            decimals: decimals,
            price: price,
            numDecimals: numDecimals
        });
    }

    /**
     * @notice Removes a token from the approved vesting tokens list
     * @dev Can only be called by the contract owner. Reverts if the token is not currently on the list.
     * @param tokenAddress The address of the token to remove
     */
    function removeVestingToken(address tokenAddress) public onlyOwner {
        require(
            address(vestingTokens[tokenAddress].token) != address(0),
            "Vesting token on list"
        );

        delete vestingTokens[tokenAddress];
    }

    /* ========== Set/Get Approved Swap Tokens ========== */

    /**
     * @notice Adds a new token to the authorized swap tokens list
     * @dev Can only be called by the contract owner. Reverts if the token already exists on the list or if the address is invalid
     * @param tokenAddress The address of the new token to add
     * @param decimals The decimals of the new token
     */
    function addAuthorizedSwapToken(
        address tokenAddress,
        uint256 decimals
    ) public onlyOwner {
        require(tokenAddress != address(0), "Invalid token address");
        require(
            address(authorizedSwapTokens[tokenAddress].token) == address(0),
            "Swap token on list"
        );

        authorizedSwapTokens[tokenAddress] = AuthorizedSwapTokens({
            token: IERC20(tokenAddress),
            decimals: decimals
        });
    }

    /**
     * @notice Removes a token from the authorized swap tokens list
     * @dev Can only be called by the contract owner. Reverts if the token is not currently on the list.
     * @param tokenAddress The address of the token to remove
     */
    function removeAuthorizedSwapToken(address tokenAddress) public onlyOwner {
        require(
            address(authorizedSwapTokens[tokenAddress].token) != address(0),
            "Swap token not on list"
        );

        delete authorizedSwapTokens[tokenAddress];
    }

    /* ========== Set Vesting Parameters ========== */

    /**
     * @notice Sets the valid vesting parameters
     * @dev This function allows the owner to set the valid parameters for vesting.
     * @param _purchaseCliffWeeks The number of weeks that the cliff will be present at for purchases
     * @param _purchaseVestingWeeks The number of weeks the tokens will vest over linearly for purchases.
     * @param _swapCliffWeeks The number of weeks that the cliff will be present at for swaps
     * @param _swapVestingWeeks The number of weeks the tokens will vest over linearly for swaps.
     */

    function setValidVestingParams(
        uint256 _purchaseCliffWeeks,
        uint256 _purchaseVestingWeeks,
        uint256 _swapCliffWeeks,
        uint256 _swapVestingWeeks
    ) public onlyOwner {
        validVestingParams.purchaseCliffWeeks = _purchaseCliffWeeks;
        validVestingParams.purchaseVestingWeeks = _purchaseVestingWeeks;
        validVestingParams.swapCliffWeeks = _swapCliffWeeks;
        validVestingParams.swapVestingWeeks = _swapVestingWeeks;
    }

    /**
     * @notice Sets the release percentage for amount of vesting tokens that will immediately sent to users
     * @dev Allows the owner to set a threshold vesting token releases.
     * @param _releasePercentage The new percentage for the amount of vesting tokens immediately released to purchasers (should be scaled to 10^4)
     */
    function setReleasePercentage(uint256 _releasePercentage) public onlyOwner {
        require(
            _releasePercentage >= 1 * 10 ** 4 &&
                _releasePercentage <= 100 * 10 ** 4,
            "Release percentage must be scaled to 10 ** 4"
        );
        releasePercentage = _releasePercentage;
    }

    /**
     * @notice Sets the threshold for the amount of vesting tokens to be purchased.
     * @dev Allows the owner to set a threshold for vesting token purchase. If a user's purchase amount exceeds this threshold, a specified percentage of purchased tokens will be instantly transferred to the user.
     * @param threshold The new threshold for the amount of vesting tokens to be purchased.
     */
    function setPurchaseAmountThreshold(uint256 threshold) public onlyOwner {
        purchaseAmountThreshold = threshold;
    }

    /* ========== Set Vesting Swap Exchange Rate ========== */

    /**
     * @notice Sets the swap ratio for the vesting to swap token conversion
     * @dev Can only be executed by the owner of the contract
     * @param _ratio The ratio (multiply by 10^4 before sending to contract)
     */
    function setSwapRatio(uint256 _ratio) public onlyOwner {
        swapRatio = _ratio;
    }

    /* ========== Add/Remove Addresses to Swap Whitelist/Check Whether Address is on Whitelist ========== */

    /**
     * @notice Add provided addresses to the authorized swap addresses whitelist
     * @dev This function allows multiple addresses to be added to the whitelist status in a single transaction. 
     The provided addresses must be valid i.e. they cannot be the null address. It checks for this condition and reverts the transaction if the condition is not met
     * @param _addresses The array of addresses to be added to the authorized swap addresses whitelist
     * 
     */

    function addAuthorizedSwapAddresses(
        address[] memory _addresses
    ) public onlyOwner {
        for (uint i = 0; i < _addresses.length; i++) {
            require(_addresses[i] != address(0), "Null address not allowed");
            authorizedSwapAddresses[_addresses[i]] = AuthorizedSwapAddresses(
                _addresses[i],
                true
            );
        }

        emit addressesAddedToWhiteList(_addresses);
    }

    /**
     * @notice Removes an address from the authorized swap addresses whitelist
     * @dev Delete a specific address from the authorizedSwapAddresses mapping
     The provided address must exist in the whitelist and cannot be the null address
     * @param _address The address to be removed from the whitelist
     */

    function removeAuthorizedSwapAddress(address _address) public onlyOwner {
        require(
            authorizedSwapAddresses[_address].isSet,
            "Address does not exist in the whitelist"
        );
        delete authorizedSwapAddresses[_address];
    }

    /**
     * @notice Check if an address is on the authorized swap addresses whitelist
     * @dev Checks if the isSet field in the struct against the passed address in authorizedSwapAddresses is true
     * @param _address The address to check if it is on the whitelist
     * @return bool Returns true if the address is on the whitelist, false otherwise
     */
    function isWhitelisted(address _address) public view returns (bool) {
        return authorizedSwapAddresses[_address].isSet;
    }

    /* ========== Purchase and Vesting Functions ========== */

    /**
     * @notice Adjust the amount from the scale of the source decimal to the destination decimal
     * @dev This function handles the case where the decimal numbers vary between two tokens.
     * @param amount The source amount to be adjusted
     * @param fromDecimals The decimal number of the source token
     * @param toDecimals The decimal number of the destination token
     * @return The amount adjusted to the destination decimal scale
     */
    function adjustDecimals(
        uint256 amount,
        uint256 fromDecimals,
        uint256 toDecimals
    ) public pure returns (uint256) {
        if (fromDecimals == toDecimals) {
            return amount;
        } else if (fromDecimals > toDecimals) {
            return amount / (10 ** (fromDecimals - toDecimals));
        } else {
            return amount * (10 ** (toDecimals - fromDecimals));
        }
    }

    /**
     * @notice Allows user to purchase tokens with DAI or USDC, or another approved asset, which are then vested.
     * @dev Tokens being used for purchase must be approved. Transfers funds from purchaser to Treasury. Only available when vesting is active.
     * If the purchase amount meets the threshold, a portion of tokens is immediately released.
     * The rest of the tokens are vested; if not enough tokens are available to vest the transaction will revert.
     * @param _vestingTokenPurchaseAmount The amount of vesting tokens to be purchased
     * @param _exchangeToken The token used for the purchase, either DAI or USDC, or another approved token
     * @param _vestingAsset The asset to be vested
     */
    function purchaseVestingToken(
        uint256 _vestingTokenPurchaseAmount,
        address _exchangeToken,
        address _vestingAsset,
        VestingParams memory _vestingParams
    ) public payable whenVestingActive nonReentrant {
        // Ensure cliff is shorter than vesting (vesting includes the cliff duration) and cliff + vesting weeks; provided vesting parameters are valid; start time is valid

        require(
            _vestingParams.vestingWeeks > 0 &&
                _vestingParams.vestingWeeks >= _vestingParams.cliffWeeks &&
                _vestingParams.vestingWeeks >=
                validVestingParams.purchaseVestingWeeks &&
                _vestingParams.cliffWeeks >=
                validVestingParams.purchaseCliffWeeks,
            "Vesting: invalid vesting params set"
        );

        require(
            _vestingParams.startTime >= block.timestamp - 60 minutes,
            "Invalid start time set"
        );

        require(
            address(purchaseTokens[_exchangeToken].token) != address(0),
            "Exchange token must be a valid approved token"
        );

        uint256 scaledBuyPrice = _vestingTokenPurchaseAmount
            .mul(vestingTokens[_vestingAsset].price)
            .div(10 ** 4);

        //Calculate required amount of buy token

        uint256 requiredBuyAmount = adjustDecimals(
            scaledBuyPrice,
            vestingTokens[_vestingAsset].numDecimals,
            purchaseTokens[_exchangeToken].numDecimals
        );

        emit processLog(
            "Required Sell Token Payment Amount Calculated",
            requiredBuyAmount
        );

        require(
            IERC20(_exchangeToken).balanceOf(msg.sender) >= requiredBuyAmount,
            "Not enough tokens in wallet to exchange for vesting token"
        );

        //Logic to determine if purchase amount meets threshold for immediate release of portion of vested token asset

        uint256 vestingAmount;
        uint256 sellTokenAmountCalc;

        //Calculate sell token amount (to compare to purchase amount threshold)
        sellTokenAmountCalc = requiredBuyAmount.div(
            purchaseTokens[_exchangeToken].decimals
        );

        emit processLog(
            "Scaled Down Amount of Sell Token Calculated",
            sellTokenAmountCalc
        );

        //Transfer funds from purchaser to Treasury

        IERC20(_exchangeToken).safeTransferFrom(
            msg.sender,
            TREASURY,
            requiredBuyAmount
        );

        // Complete vesting operations //

        if (sellTokenAmountCalc >= purchaseAmountThreshold) {
            //Calculate amount to release
            uint256 percentToReleaseCalc = _vestingTokenPurchaseAmount
                .mul(releasePercentage)
                .div(vestingTokens[_vestingAsset].decimals);

            uint256 amountToRelease = percentToReleaseCalc
                .mul(vestingTokens[_vestingAsset].decimals)
                .div(10 ** 4)
                .div(100);

            emit processLog("Amount to Release Calculated", amountToRelease);

            // Withdraw amount from vesting contract and send to purchaser
            if (amountToRelease > 0) {
                _withdrawBonusTokens(
                    amountToRelease,
                    _vestingAsset,
                    msg.sender
                );
            }

            emit bonusVestingTokenTransfered(msg.sender, amountToRelease);

            // Calculate the remaining amount to vest
            vestingAmount = _vestingTokenPurchaseAmount.sub(amountToRelease);

            emit processLog("Vesting Amount Calculated", vestingAmount);

            // Vest the tokens for the user; if not enough tokens are available to vest the transaction will revert
            _vest(msg.sender, vestingAmount, _vestingParams);

            emit vestingPurchaseTransactionComplete(
                msg.sender,
                vestingAmount,
                _exchangeToken,
                sellTokenAmountCalc
            );
        } else {
            vestingAmount = _vestingTokenPurchaseAmount;

            _vest(msg.sender, vestingAmount, _vestingParams);

            emit vestingPurchaseTransactionComplete(
                msg.sender,
                vestingAmount,
                _exchangeToken,
                requiredBuyAmount
            );
        }
    }

    /**
     * @notice Sets up a token vesting schedule for the provided vestor
     * @dev Available only when vesting is active and only the owner can execute this function.
     *      If not enough tokens are available to vest, the transaction will be reverted.
     * @param vestor The address of the wallet to receive vesting tokens
     * @param amount The amount of tokens to be vested for the participant
     */
    function standardVesting(
        address vestor,
        uint256 amount,
        VestingParams memory _vestingParams
    ) public whenStandardVestingActive onlyOwner {
        //Ensure vesting start time is valid
        require(
            _vestingParams.startTime >= block.timestamp - 60 minutes,
            "Invalid start time set"
        );

        uint256 vestingAmount = amount;
        _vest(vestor, vestingAmount, _vestingParams);

        emit vestingTransactionComplete(msg.sender, vestingAmount);
    }

    /**
     * @notice Swaps a specified amount of tokens for a corresponding amount of vesting tokens, then vests those tokens for a specified address.
     * @dev Can only be called when swapping is active. Tokens to be swapped must be the authorized swap token.
     * Swapped tokens are sent to the Token Lock contract
     * If not enough tokens are available to vest, the transaction will revert.
     * @param swapTokenAmount The amount of swap tokens to be swapped and burned
     * @param tokenToSwap The token that is being swapped. Must be the authorized swap token.
     */
    function swapAndVest(
        uint256 swapTokenAmount,
        address tokenToSwap,
        VestingParams memory _vestingParams
    ) public whenSwappingActive nonReentrant {
        //Set vestor address to msg sender
        address vestor = msg.sender;

        // Ensure cliff is shorter than vesting (vesting includes the cliff duration) and cliff weeks, vesting weeks and start time are valid
        require(
            _vestingParams.vestingWeeks > 0 &&
                _vestingParams.vestingWeeks >= _vestingParams.cliffWeeks &&
                _vestingParams.cliffWeeks >=
                validVestingParams.swapCliffWeeks &&
                _vestingParams.vestingWeeks >=
                validVestingParams.swapVestingWeeks,
            "Vesting: not valid parameters"
        );

        require(
            _vestingParams.startTime >= block.timestamp - 60 minutes,
            "Invalid start time set"
        );

        // Check that swap token is authorized
        require(
            authorizedSwapTokens[tokenToSwap].token != IERC20(address(0)),
            "Token must be authorized swap token"
        );

        // If whitelist is active, check that sender is on the whitelist.
        if (current_whitelist_status == whiteListStatus.whiteListActive) {
            require(isWhitelisted(msg.sender), "Sender is not on whitelist");
        }

        // Calculate amount to vest
        uint256 vestingAmount = swapTokenAmount.mul(swapRatio).div(10 ** 4);
        emit processLog("Vesting Amount Calculated", vestingAmount);

        // Transfer tokens to TokenLock contract or Treasury
        authorizedSwapTokens[tokenToSwap].token.safeTransferFrom(
            msg.sender,
            address(this),
            swapTokenAmount
        );

        if (current_token_lock_status == tokenLockStatus.tokenLockActive) {
            // Transfer token to Token Lock contract (default behavior)
            _transferERC20(
                IERC20(tokenToSwap),
                address(tokenLock),
                swapTokenAmount
            );
        } else {
            // Transfer token to TREASURY
            _transferERC20(IERC20(tokenToSwap), TREASURY, swapTokenAmount);
        }

        emit processLog("Swap Token Transfered", swapTokenAmount);

        // Vest tokens on behalf of user
        _vest(vestor, vestingAmount, _vestingParams);

        emit vestingTransactionComplete(vestor, vestingAmount);
    }

    /**
     * @notice Sets up a vesting schedule for a user using the Vesting contract. Arguments are vesting parameters.
     * @param account The account that a vesting schedule is being set up for.
     * @param amount The amount of tokens being vested for the user.
     * @param params A struct containing the vesting parameters. The struct has
     *        the following parameters:
     *        ```
     *        {
     *          "asset": "<ADDRESS>", // The address of the token being vested
     *          "isFixed": <BOOLEAN>, // A flag indicating if the vesting schedule is fixed (can be adjusted)
     *          "cliffWeeks": <NUMBER>, // The number of weeks for the cliff period
     *          "vestingWeeks": <NUMBER>, // The number of weeks over which the tokens will vest
     *          "startTime": <UNIX_TIMESTAMP> // The start timestamp for the vesting
     *        }
     *        ```
     */
    function _vest(
        address account,
        uint256 amount,
        VestingParams memory params
    ) internal {
        vestingManager.vest(
            account,
            amount,
            params.asset,
            params.isFixed,
            params.cliffWeeks,
            params.vestingWeeks,
            params.startTime
        );
    }

    /**
     * @notice Allows claim of vested tokens; 
     * @dev Uses vestingManager to process the claim; 
     Vesting Executor claims on behalf of vestor and tokens are sent to vestor's account
     * @param scheduleId The ID of the vesting schedule
     * @param vestor The address of the vestor
     */
    function claimTokens(
        uint256 scheduleId,
        address vestor,
        address vestingAsset
    ) external {
        require(vestor == msg.sender, "Claimer is not vestor");

        vestingManager.claim(scheduleId, vestor, vestingAsset);
    }

    /**
     * @notice Cancel an individual vesting schedule.
     * @dev If the indiviudal vesting schedule is cancellable, it transfers the outstanding tokens to the VestingExecutor. Can only be called by the DAO multisig.
     * @param account The account to cancel vesting for.
     * @param scheduleId The id of the vesting schedule being canceled.
     */
    function cancelVesting(
        address account,
        uint256 scheduleId
    ) external multiSigOnly {
        vestingManager.cancelVesting(account, scheduleId);
    }

    /**
     * @notice Withdraws vesting tokens from the VestingManager contract.
     * @dev It only allows withdrawing tokens that are not locked in vesting. Can only be called by DAO multisig.
     * @param amount The amount to withdraw.
     * @param asset The token to withdraw.
     */
    function withdrawVestingTokens(
        uint256 amount,
        address asset
    ) external multiSigOnly {
        vestingManager.withdrawVestingTokens(amount, asset);

        _transferERC20(IERC20(asset), owner(), amount);

        emit vestingTokenWithdrawal(asset, amount);
    }

    /**
     * @notice Withdraws vesting tokens from the VestingManager contract (during token purchase transactions)
     * @dev It only allows withdrawing tokens that are not locked in vesting.
     * @param amount The amount to withdraw.
     * @param asset The token to withdraw.
     */
    function _withdrawBonusTokens(
        uint256 amount,
        address asset,
        address receipent
    ) internal {
        vestingManager.withdrawVestingTokens(amount, asset);

        _transferERC20(IERC20(asset), receipent, amount);
    }

    //End of contract
}


// File: VestingManager.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.9;

import "Ownable.sol";
import "ERC20.sol";
import "IERC20.sol";
import "SafeERC20.sol";
import "SafeMath.sol";
import "ReentrancyGuard.sol";

/**
 * Vesting Manager core functionality based on standard Myceleium 
 (formerly Tracer DAO) vesting contract. Source code 
 available at: https://github.com/tracer-protocol/vesting/blob/master/contracts/Vesting.sol.

 Vesting Manager can vest multiple tokens.
 An address can have multiple vesting schedules for multiple assets. 
 */

contract VestingManager is Ownable {
    /* ========== State Variables ========== */

    address payable immutable TREASURY =
        payable(0xf950a86013bAA227009771181a885E369e158da3);

    /* ========== Structs ========== */

    /**
     * @dev Represents a vesting schedule for an account.
     *
     * @param totalAmount Total amount of tokens that will be vested.
     * @param claimedAmount Amount of tokens that have already been claimed.
     * @param startTime Unix timestamp for the start of the vesting schedule.
     * @param cliffTime The timestamp at which the cliff period ends. No tokens can be claimed before the cliff.
     * @param endTime The timestamp at which the vesting schedule ends. All tokens can be claimed after endTime.
     * @param isFixed Flag indicating if the vesting schedule is fixed or can be modified.
     * @param asset The address of the token being vested.
     */
    struct Schedule {
        uint256 totalAmount;
        uint256 claimedAmount;
        uint256 startTime;
        uint256 cliffTime;
        uint256 endTime;
        bool isFixed;
        address asset;
    }

    /**
     * @dev Represents a summary of a vesting schedule.
     *
     * @param id Unique identifier for the vesting schedule.
     * @param cliffTime The timestamp at which the cliff period ends. No tokens can be claimed before the cliff.
     * @param endTime The timestamp at which the vesting schedule ends. All tokens can be claimed after endTime.
     
     */
    struct ScheduleInfo {
        uint256 id;
        uint256 startTime;
        uint256 cliffTime;
        uint256 endTime;
        uint256 claimedAmount;
        uint256 totalAmount;
        address asset;
    }

    /**
     * @dev Struct to represent amount of vested tokens claimable for a vesting schedule
     * @param scheduleID ID of vesting schedule
     * @param claimableTokens number of vesting tokens claimable as of the current time
     */
    struct ClaimableInfo {
        uint256 scheduleID;
        uint256 claimableTokens;
    }

    /**
     * @dev Struct to represent amount of vested tokens claimable for a vesting schedule
     * @param scheduleID ID of vesting schedule
     * @param claimableTokens number of vesting tokens claimable as of the current time
     */
    struct TokenClaimInfo {
        address asset;
        uint256 scheduleID;
        uint256 claimedAmount;
    }

    /* ========== Mappings ========== */

    // Maps a user address to a schedule ID, which can be used to identify a vesting schedule
    mapping(address => mapping(uint256 => Schedule)) public schedules;

    // Maps a user address to number of schedules created for the account
    mapping(address => uint256) public numberOfSchedules;

    //Provides number of total tokens locked for a specific asset
    mapping(address => uint256) public locked;

    //Maps an address to token claim information associated with a specific address
    mapping(address => TokenClaimInfo[]) public tokenClaimInfo;

    /* ========== Events ========== */

    event vestingClaim(
        uint256 scheduleID,
        address indexed claimer,
        uint256 tokenAmountClaimed,
        uint256 tokensClaimedToDate
    );
    event vestingCancelled(uint256 scheduleID, address account);

    event VestingScheduleCreated(
        address indexed account,
        uint256 indexed currentNumSchedules,
        uint256 amount,
        uint256 startTime,
        uint256 cliffTime,
        uint256 vestingTime,
        bool isFixed,
        address indexed asset
    );

    event processLog(string description, uint256 number);

    /* ========== Constructor ========== */
    // Owner will be set to VestingExecutor contract
    constructor(address initialOwner) {
        transferOwnership(initialOwner);
    }

    /* ========== Views ========== */

    /**
     * @notice Fetches locked amount of a specific asset.
     * @param _assetAddress The address of the asset.
     * @return The amount of the asset currently locked.
     */
    function getLockedAmount(
        address _assetAddress
    ) public view returns (uint256) {
        return locked[_assetAddress];
    }

    /**
     * @notice Returns information about all vesting schedules for a given account
     * @param account The address of the account for which to return vesting schedule information
     * @return An array of ScheduleInfo structs, each containing the ID, cliff timestamp, and end timestamp for a vesting schedule (related to the account)
     */
    function getScheduleInfo(
        address account
    ) public view returns (ScheduleInfo[] memory) {
        uint256 count = numberOfSchedules[account];
        ScheduleInfo[] memory scheduleInfoList = new ScheduleInfo[](count);
        for (uint256 i = 0; i < count; i++) {
            scheduleInfoList[i] = ScheduleInfo(
                i,
                schedules[account][i].startTime,
                schedules[account][i].cliffTime,
                schedules[account][i].endTime,
                schedules[account][i].claimedAmount,
                schedules[account][i].totalAmount,
                schedules[account][i].asset
            );
        }
        return scheduleInfoList;
    }

    /**
     * @notice Retrieves the number of claimable tokens per vesting schedule for a given account
     * @dev This function utilizes the calcVestingDistribution function to determine claimable tokens based on the current block timestamp
     * @param account The address of the account to retrieve claimable tokens for
     * @return An array of structs, each containing the scheduleID and the corresponding number of claimable tokens
     */
    function retrieveClaimableTokens(
        address account
    ) public view returns (ClaimableInfo[] memory) {
        ScheduleInfo[] memory scheduleInfoList = getScheduleInfo(account);

        ClaimableInfo[] memory claimableInfoList = new ClaimableInfo[](
            scheduleInfoList.length
        );

        for (uint256 i = 0; i < scheduleInfoList.length; i++) {
            uint256 claimableTokens = calcVestingDistribution(
                scheduleInfoList[i].totalAmount,
                block.timestamp,
                scheduleInfoList[i].startTime,
                scheduleInfoList[i].endTime
            );

            // Cap the claimable tokens to the total amount allocated for vesting
            claimableTokens = claimableTokens > scheduleInfoList[i].totalAmount
                ? scheduleInfoList[i].totalAmount
                : claimableTokens;

            // Adjust the amount based on the amount the user has claimed
            uint256 claimableAmount = claimableTokens >
                scheduleInfoList[i].claimedAmount
                ? claimableTokens - scheduleInfoList[i].claimedAmount
                : 0;

            claimableInfoList[i] = ClaimableInfo(i, claimableAmount);
        }

        return claimableInfoList;
    }

    /**
     * @notice Internal function to record vestor's claiming activity.
     * @param _vestor The address of the vestor.
     * @param _asset The address of the vesting asset.
     * @param _scheduleID The ID of the vesting schedule.
     * @param _claimedAmount The total amount claimed.
     */
    function _setTotalClaimedData(
        address _vestor,
        address _asset,
        uint256 _scheduleID,
        uint256 _claimedAmount
    ) internal {
        tokenClaimInfo[_vestor].push(
            TokenClaimInfo(_asset, _scheduleID, _claimedAmount)
        );
    }

    /**
     * @notice Retrieves token claim data for a vestor address.
     * @param _address The vestor address for which to retrieve the token claim data.
     * @return An array of TokenClaimInfo containing token claim data for the.
     */
    function getTokenClaimData(
        address _address
    ) public view returns (TokenClaimInfo[] memory) {
        return tokenClaimInfo[_address];
    }

    /* ========== Vesting Functions ========== */

    /**
     * @notice Sets up a vesting schedule for a set user.
     * @dev Adds a new Schedule to the schedules mapping.
     * @param account The account that a vesting schedule is being set up for. Account will be able to claim tokens post-cliff period
     * @param amount The amount of ERC20 tokens being vested for the user.
     * @param asset The ERC20 asset being vested
     * @param isFixed If true, the vesting schedule cannot be cancelled
     * @param cliffWeeks Important parameter that determines how long the vesting cliff will be. During a cliff, no tokens can be claimed and vesting is paused
     * @param vestingWeeks The number of weeks a token will be vested over (linear in this immplementation)
     * @param startTime The start time for the vesting period ( in UNIX)
     */
    function vest(
        address account,
        uint256 amount,
        address asset,
        bool isFixed,
        uint256 cliffWeeks,
        uint256 vestingWeeks,
        uint256 startTime
    ) public onlyOwner {
        // ensure cliff is shorter than vesting (vesting includes the cliff duration)
        require(
            vestingWeeks > 0 && vestingWeeks >= cliffWeeks && amount > 0,
            "Vesting: invalid vesting params set"
        );

        uint256 currentLocked = locked[asset];

        // require enough unlocked token is present to vest the desired amount
        require(
            IERC20(asset).balanceOf(address(this)) >= currentLocked + amount,
            "Vesting: Not enough unlocked supply available to to vest"
        );

        // create the schedule
        uint256 currentNumSchedules = numberOfSchedules[account];
        schedules[account][currentNumSchedules] = Schedule(
            amount,
            0,
            startTime,
            startTime + (cliffWeeks * 1 weeks),
            startTime + (vestingWeeks * 1 weeks),
            isFixed,
            asset
        );

        numberOfSchedules[account] = currentNumSchedules + 1; //Update number of schedules
        locked[asset] = currentLocked + amount; //Update amount of asset locked in vesting schedule

        emit VestingScheduleCreated(
            account,
            currentNumSchedules,
            amount,
            startTime,
            startTime + (cliffWeeks * 1 weeks),
            startTime + (vestingWeeks * 1 weeks),
            isFixed,
            asset
        );
    }

    /**
     * @notice Post-cliff period, users can claim their tokens
     * @param scheduleNumber which schedule the user is claiming against
     */
    function claim(
        uint256 scheduleNumber,
        address vestor,
        address asset
    ) external onlyOwner {
        Schedule storage schedule = schedules[vestor][scheduleNumber];
        require(
            schedule.cliffTime <= block.timestamp,
            "Vesting: cliff not reached"
        );
        require(schedule.totalAmount > 0, "Vesting: Token not claimable");

        // Get the amount to be distributed
        uint256 amount = calcVestingDistribution(
            schedule.totalAmount,
            block.timestamp,
            schedule.startTime,
            schedule.endTime
        );

        // Caps the claim amount to the total amount allocated to be vested to the address
        amount = amount > schedule.totalAmount ? schedule.totalAmount : amount;
        uint256 amountToTransfer = amount - schedule.claimedAmount;
        schedule.claimedAmount = amount; // set new claimed amount based off the curve
        locked[schedule.asset] = locked[schedule.asset] - amountToTransfer;

        _setTotalClaimedData(vestor, asset, scheduleNumber, amount);

        require(
            IERC20(schedule.asset).transfer(vestor, amountToTransfer),
            "Vesting: transfer failed"
        );

        emit vestingClaim(scheduleNumber, vestor, amountToTransfer, amount);
    }

    /**
     * @notice Allows an individual vesting schedule to be cancelled.
     * @dev Any outstanding tokens are returned to the system.
     * @param account the account of the user whos vesting schedule is being cancelled.
     * @param scheduleId the schedule ID of the vesting schedule being cancelled
     */
    function cancelVesting(
        address account,
        uint256 scheduleId
    ) external onlyOwner {
        Schedule storage schedule = schedules[account][scheduleId];
        require(!schedule.isFixed, "Vesting: Account is fixed");
        uint256 outstandingAmount = schedule.totalAmount -
            schedule.claimedAmount;
        require(outstandingAmount != 0, "Vesting: no outstanding tokens");
        schedule.totalAmount = 0;
        locked[schedule.asset] = locked[schedule.asset] - outstandingAmount;
        require(
            IERC20(schedule.asset).transfer(TREASURY, outstandingAmount),
            "Vesting: transfer failed"
        );
        emit vestingCancelled(scheduleId, account);
    }

    /**
     * @return calculates the amount of tokens to distribute to an account at any instance in time, based off some
     *         total claimable amount.
     * @param amount the total outstanding amount to be claimed for this vesting schedule.
     * @param currentTime the current timestamp.
     * @param startTime the timestamp this vesting schedule started.
     * @param endTime the timestamp this vesting schedule ends.
     */
    function calcVestingDistribution(
        uint256 amount,
        uint256 currentTime,
        uint256 startTime,
        uint256 endTime
    ) public pure returns (uint256) {
        // avoid uint underflow
        if (currentTime < startTime) {
            return 0;
        }

        // if endTime < startTime, this will throw. Since endTime should never be
        // less than startTime in safe operation, this is fine.
        return (amount * (currentTime - startTime)) / (endTime - startTime);
    }

    /**
     * @notice Withdraws vesting tokens from the contract.
     * @dev blocks withdrawing locked tokens.
     */
    function withdrawVestingTokens(
        uint256 amount,
        address asset
    ) external onlyOwner {
        IERC20 token = IERC20(asset);
        require(
            token.balanceOf(address(this)) - locked[asset] >= amount,
            "Vesting: Can't withdraw"
        );
        require(token.transfer(owner(), amount), "Vesting: withdraw failed");
    }

    //End of contract
}


// File: Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: ERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "IERC20.sol";
import "IERC20Metadata.sol";
import "Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}


// File: IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "IERC20.sol";
import "draft-IERC20Permit.sol";
import "Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: SafeMath.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


// File: ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: TokenLock.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.9;

import "Ownable.sol";
import "IERC20.sol";

/**
 * Token Lock contract holds tokens swapped by the Vesting Executor for vested tokens. 

 */

contract TokenLock is Ownable {
    /* ========== Constructor ========== */
    // Owner will be set to VestingExecutor contract
    constructor(address initialOwner) {
        transferOwnership(initialOwner);
    }

    /* ========== Transfer ERC20 Tokens ========== */

    /**
     * @notice Transfers a specific amount of ERC20 tokens to an address.
     * @dev The token transfer is executed using the input token's transfer function. It checks there are enough tokens on
     * the contract's balance before performing the transfer.
     * @param token The address of the ERC20 token contract that we want to make the transfer with.
     * @param to The recipient's address of the tokens.
     * @param amount The amount of tokens to be transferred.
     */

    function transferLockedTokens(
        IERC20 token,
        address to,
        uint256 amount
    ) external onlyOwner {
        uint256 erc20balance = token.balanceOf(address(this));
        require(amount <= erc20balance, "Balance too low to transfer token");
        token.transfer(to, amount);
    }
}

