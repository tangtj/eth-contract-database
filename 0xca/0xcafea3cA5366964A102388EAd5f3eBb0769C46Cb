
// File: @openzeppelin/contracts-v4/token/ERC20/extensions/draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts-v4/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: @openzeppelin/contracts-v4/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File: contracts/external/cow/GPv2Order.sol
// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity ^0.8.18;

import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";

/// @title Gnosis Protocol v2 Order Library
/// @author Gnosis Developers
library GPv2Order {
    /// @dev The complete data for a Gnosis Protocol order. This struct contains
    /// all order parameters that are signed for submitting to GP.
    struct Data {
        IERC20 sellToken;
        IERC20 buyToken;
        address receiver;
        uint256 sellAmount;
        uint256 buyAmount;
        uint32 validTo;
        bytes32 appData;
        uint256 feeAmount;
        bytes32 kind;
        bool partiallyFillable;
        bytes32 sellTokenBalance;
        bytes32 buyTokenBalance;
    }

    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256(
    ///     "Order(" +
    ///         "address sellToken," +
    ///         "address buyToken," +
    ///         "address receiver," +
    ///         "uint256 sellAmount," +
    ///         "uint256 buyAmount," +
    ///         "uint32 validTo," +
    ///         "bytes32 appData," +
    ///         "uint256 feeAmount," +
    ///         "string kind," +
    ///         "bool partiallyFillable" +
    ///         "string sellTokenBalance" +
    ///         "string buyTokenBalance" +
    ///     ")"
    /// )
    /// ```
    bytes32 internal constant TYPE_HASH =
        hex"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489";

    /// @dev The marker value for a sell order for computing the order struct
    /// hash. This allows the EIP-712 compatible wallets to display a
    /// descriptive string for the order kind (instead of 0 or 1).
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("sell")
    /// ```
    bytes32 internal constant KIND_SELL =
        hex"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775";

    /// @dev The OrderKind marker value for a buy order for computing the order
    /// struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("buy")
    /// ```
    bytes32 internal constant KIND_BUY =
        hex"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc";

    /// @dev The TokenBalance marker value for using direct ERC20 balances for
    /// computing the order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("erc20")
    /// ```
    bytes32 internal constant BALANCE_ERC20 =
        hex"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9";

    /// @dev The TokenBalance marker value for using Balancer Vault external
    /// balances (in order to re-use Vault ERC20 approvals) for computing the
    /// order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("external")
    /// ```
    bytes32 internal constant BALANCE_EXTERNAL =
        hex"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632";

    /// @dev The TokenBalance marker value for using Balancer Vault internal
    /// balances for computing the order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("internal")
    /// ```
    bytes32 internal constant BALANCE_INTERNAL =
        hex"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce";

    /// @dev Marker address used to indicate that the receiver of the trade
    /// proceeds should the owner of the order.
    ///
    /// This is chosen to be `address(0)` for gas efficiency as it is expected
    /// to be the most common case.
    address internal constant RECEIVER_SAME_AS_OWNER = address(0);

    /// @dev The byte length of an order unique identifier.
    uint256 internal constant UID_LENGTH = 56;

    /// @dev Returns the actual receiver for an order. This function checks
    /// whether or not the [`receiver`] field uses the marker value to indicate
    /// it is the same as the order owner.
    ///
    /// @return receiver The actual receiver of trade proceeds.
    function actualReceiver(Data memory order, address owner)
        internal
        pure
        returns (address receiver)
    {
        if (order.receiver == RECEIVER_SAME_AS_OWNER) {
            receiver = owner;
        } else {
            receiver = order.receiver;
        }
    }

    /// @dev Return the EIP-712 signing hash for the specified order.
    ///
    /// @param order The order to compute the EIP-712 signing hash for.
    /// @param domainSeparator The EIP-712 domain separator to use.
    /// @return orderDigest The 32 byte EIP-712 struct hash.
    function hash(Data memory order, bytes32 domainSeparator)
        internal
        pure
        returns (bytes32 orderDigest)
    {
        bytes32 structHash;

        // NOTE: Compute the EIP-712 order struct hash in place. As suggested
        // in the EIP proposal, noting that the order struct has 10 fields, and
        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.
        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let dataStart := sub(order, 32)
            let temp := mload(dataStart)
            mstore(dataStart, TYPE_HASH)
            structHash := keccak256(dataStart, 416)
            mstore(dataStart, temp)
        }

        // NOTE: Now that we have the struct hash, compute the EIP-712 signing
        // hash using scratch memory past the free memory pointer. The signing
        // hash is computed from `"\x19\x01" || domainSeparator || structHash`.
        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>
        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let freeMemoryPointer := mload(0x40)
            mstore(freeMemoryPointer, "\x19\x01")
            mstore(add(freeMemoryPointer, 2), domainSeparator)
            mstore(add(freeMemoryPointer, 34), structHash)
            orderDigest := keccak256(freeMemoryPointer, 66)
        }
    }

    /// @dev Packs order UID parameters into the specified memory location. The
    /// result is equivalent to `abi.encodePacked(...)` with the difference that
    /// it allows re-using the memory for packing the order UID.
    ///
    /// This function reverts if the order UID buffer is not the correct size.
    ///
    /// @param orderUid The buffer pack the order UID parameters into.
    /// @param orderDigest The EIP-712 struct digest derived from the order
    /// parameters.
    /// @param owner The address of the user who owns this order.
    /// @param validTo The epoch time at which the order will stop being valid.
    function packOrderUidParams(
        bytes memory orderUid,
        bytes32 orderDigest,
        address owner,
        uint32 validTo
    ) internal pure {
        require(orderUid.length == UID_LENGTH, "GPv2: uid buffer overflow");

        // NOTE: Write the order UID to the allocated memory buffer. The order
        // parameters are written to memory in **reverse order** as memory
        // operations write 32-bytes at a time and we want to use a packed
        // encoding. This means, for example, that after writing the value of
        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`
        // will **overwrite** bytes `20:32`. This is desirable as addresses are
        // only 20 bytes and `20:32` should be `0`s:
        //
        //        |           1111111111222222222233333333334444444444555555
        //   byte | 01234567890123456789012345678901234567890123456789012345
        // -------+---------------------------------------------------------
        //  field | [.........orderDigest..........][......owner.......][vT]
        // -------+---------------------------------------------------------
        // mstore |                         [000000000000000000000000000.vT]
        //        |                     [00000000000.......owner.......]
        //        | [.........orderDigest..........]
        //
        // Additionally, since Solidity `bytes memory` are length prefixed,
        // 32 needs to be added to all the offsets.
        //
        // solhint-disable-next-line no-inline-assembly
        assembly {
            mstore(add(orderUid, 56), validTo)
            mstore(add(orderUid, 52), owner)
            mstore(add(orderUid, 32), orderDigest)
        }
    }

    /// @dev Extracts specific order information from the standardized unique
    /// order id of the protocol.
    ///
    /// @param orderUid The unique identifier used to represent an order in
    /// the protocol. This uid is the packed concatenation of the order digest,
    /// the validTo order parameter and the address of the user who created the
    /// order. It is used by the user to interface with the contract directly,
    /// and not by calls that are triggered by the solvers.
    /// @return orderDigest The EIP-712 signing digest derived from the order
    /// parameters.
    /// @return owner The address of the user who owns this order.
    /// @return validTo The epoch time at which the order will stop being valid.
    function extractOrderUidParams(bytes calldata orderUid)
        internal
        pure
        returns (
            bytes32 orderDigest,
            address owner,
            uint32 validTo
        )
    {
        require(orderUid.length == UID_LENGTH, "GPv2: invalid uid");

        // Use assembly to efficiently decode packed calldata.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            orderDigest := calldataload(orderUid.offset)
            owner := shr(96, calldataload(add(orderUid.offset, 32)))
            validTo := shr(224, calldataload(add(orderUid.offset, 52)))
        }
    }
}


// File: contracts/external/enzyme/IEnzymeFundValueCalculatorRouter.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IEnzymeFundValueCalculatorRouter {
  function calcGrossShareValue(address _vaultProxy)
  external
  returns (address denominationAsset_, uint256 grossShareValue_);

  function calcNetShareValue(address _vaultProxy)
  external
  returns (address denominationAsset_, uint256 netShareValue_);
}




// File: contracts/external/enzyme/IEnzymePolicyManager.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IPolicyManager {
  function updatePolicySettingsForFund(
    address _comptrollerProxy,
    address _policy,
    bytes calldata _settingsData
  ) external;
}




// File: contracts/external/enzyme/IEnzymeV4Comptroller.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IEnzymeV4Comptroller {
    function getDenominationAsset() external view returns (address denominationAsset_);
    function redeemSharesForSpecificAssets(
        address _recipient,
        uint256 _sharesQuantity,
        address[] calldata _payoutAssets,
        uint256[] calldata _payoutAssetPercentages
    ) external returns (uint256[] memory payoutAmounts_);

  function vaultCallOnContract(
    address _contract,
    bytes4 _selector,
    bytes calldata _encodedArgs
  ) external;

  function buyShares(uint _investmentAmount, uint _minSharesQuantity) external;
}


// File: contracts/external/enzyme/IEnzymeV4Vault.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IEnzymeV4Vault {
  function getAccessor() external view returns (address);

  function getOwner() external view returns (address);

  function mintShares(address, uint256) external;
}


// File: contracts/interfaces/ICowSettlement.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

import "./IERC20Detailed.sol";

interface ICowSettlement {

  struct GPv2TradeData {
    uint256 sellTokenIndex;
    uint256 buyTokenIndex;
    address receiver;
    uint256 sellAmount;
    uint256 buyAmount;
    uint32 validTo;
    bytes32 appData;
    uint256 feeAmount;
    uint256 flags;
    uint256 executedAmount;
    bytes signature;
  }

  struct GPv2InteractionData {
    address target;
    uint256 value;
    bytes callData;
  }

  function setPreSignature(bytes calldata orderUid, bool signed) external;
  
  function invalidateOrder(bytes calldata orderUid) external; 

  function filledAmount(bytes calldata orderUid) external view returns (uint256);

  function vaultRelayer() external view returns (address);

  function domainSeparator() external view returns (bytes32);

  function settle(
    IERC20Detailed[] calldata tokens,
    uint256[] calldata clearingPrices,
    GPv2TradeData[] calldata trades,
    GPv2InteractionData[][3] calldata interactions
  ) external;

  function preSignature(bytes memory) external returns (uint);
}


// File: contracts/interfaces/IERC20Detailed.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IERC20Detailed {

  function totalSupply() external view returns (uint256);

  function balanceOf(address account) external view returns (uint256);

  function transfer(address recipient, uint256 amount) external returns (bool);

  function allowance(address owner, address spender) external view returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(address indexed owner, address indexed spender, uint256 value);

  function decimals() external view returns (uint8);

  function symbol() external view returns (string memory);
}


// File: contracts/interfaces/INXMMaster.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface INXMMaster {

  function tokenAddress() external view returns (address);

  function owner() external view returns (address);

  function emergencyAdmin() external view returns (address);

  function masterInitialized() external view returns (bool);

  function isInternal(address _add) external view returns (bool);

  function isPause() external view returns (bool check);

  function isMember(address _add) external view returns (bool);

  function checkIsAuthToGoverned(address _add) external view returns (bool);

  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);

  function contractAddresses(bytes2 code) external view returns (address payable);

  function upgradeMultipleContracts(
    bytes2[] calldata _contractCodes,
    address payable[] calldata newAddresses
  ) external;

  function removeContracts(bytes2[] calldata contractCodesToRemove) external;

  function addNewInternalContracts(
    bytes2[] calldata _contractCodes,
    address payable[] calldata newAddresses,
    uint[] calldata _types
  ) external;

  function updateOwnerParameters(bytes8 code, address payable val) external;
}


// File: contracts/interfaces/IPool.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

import "./IPriceFeedOracle.sol";

struct SwapDetails {
  uint104 minAmount;
  uint104 maxAmount;
  uint32 lastSwapTime;
  // 2 decimals of precision. 0.01% -> 0.0001 -> 1e14
  uint16 maxSlippageRatio;
}

struct Asset {
  address assetAddress;
  bool isCoverAsset;
  bool isAbandoned;
}

interface IPool {

  function swapOperator() external view returns (address);

  function getAsset(uint assetId) external view returns (Asset memory);

  function getAssets() external view returns (Asset[] memory);

  function transferAssetToSwapOperator(address asset, uint amount) external;

  function setSwapDetailsLastSwapTime(address asset, uint32 lastSwapTime) external;

  function getAssetSwapDetails(address assetAddress) external view returns (SwapDetails memory);

  function sendPayout(uint assetIndex, address payable payoutAddress, uint amount, uint ethDepositAmount) external;

  function sendEth(address payoutAddress, uint amount) external;

  function upgradeCapitalPool(address payable newPoolAddress) external;

  function priceFeedOracle() external view returns (IPriceFeedOracle);

  function getPoolValueInEth() external view returns (uint);

  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);

  function getInternalTokenPriceInAsset(uint assetId) external view returns (uint tokenPrice);

  function getInternalTokenPriceInAssetAndUpdateTwap(uint assetId) external returns (uint tokenPrice);

  function getTokenPrice() external view returns (uint tokenPrice);

  function getMCRRatio() external view returns (uint);

  function setSwapValue(uint value) external;
}


// File: contracts/interfaces/IPriceFeedOracle.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface Aggregator {
  function latestAnswer() external view returns (int);
}

struct OracleAsset {
  Aggregator aggregator;
  uint8 decimals;
}

interface IPriceFeedOracle {

  function ETH() external view returns (address);
  function assets(address) external view returns (Aggregator, uint8);

  function getAssetToEthRate(address asset) external view returns (uint);
  function getAssetForEth(address asset, uint ethIn) external view returns (uint);
  function getEthForAsset(address asset, uint amount) external view returns (uint);

}


// File: contracts/interfaces/ISafeTracker.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";

interface ISafeTracker is IERC20 {

  function symbol() external view returns (string memory);

  function decimals() external view returns (uint8);

  function safe() external view returns (address);

  event CoverReInvestmentUSDCUpdated(uint investedUSDC);

  error OnlySafe();
  error InvestmentSurpassesLimit();
}


// File: contracts/interfaces/ISwapOperator.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

import "../external/cow/GPv2Order.sol";
import "../interfaces/IPool.sol";

interface ISwapOperator {

  enum SwapOperationType {
    EthToAsset,
    AssetToEth,
    AssetToAsset
  }

  /* ========== VIEWS ========== */

  function getDigest(GPv2Order.Data calldata order) external view returns (bytes32);

  function getUID(GPv2Order.Data calldata order) external view returns (bytes memory);

  function orderInProgress() external view returns (bool);

  /* ==== MUTATIVE FUNCTIONS ==== */

  function placeOrder(GPv2Order.Data calldata order, bytes calldata orderUID) external;

  function closeOrder(GPv2Order.Data calldata order) external;

  function swapEnzymeVaultShareForETH(uint amountIn, uint amountOutMin) external;

  function swapETHForEnzymeVaultShare(uint amountIn, uint amountOutMin) external;

  function recoverAsset(address assetAddress, address receiver) external;

  function requestAsset(address asset, uint amount) external;

  function transferRequestedAsset(address requestedAsset, uint requestedAmount) external;

  /* ========== EVENTS AND ERRORS ========== */

  event OrderPlaced(GPv2Order.Data order);
  event OrderClosed(GPv2Order.Data order, uint filledAmount);
  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);
  event TransferredToSafe(address asset, uint amount);

  // Swap Order
  error OrderInProgress(bytes currentOrderUID);
  error NoOrderInPlace();
  error OrderUidMismatch(bytes providedOrderUID, bytes expectedOrderUID);
  error UnsupportedTokenBalance(string kind);
  error InvalidReceiver(address validReceiver);
  error TokenDisabled(address token);
  error AmountOutTooLow(uint amountOut, uint minAmount);
  error InvalidTokenAddress(string token);
  error InvalidDenominationAsset(address invalidAsset, address validAsset);

  // Valid To
  error BelowMinValidTo(uint minValidTo);
  error AboveMaxValidTo(uint maxValidTo);

  // Balance
  error InvalidBalance(uint tokenBalance, uint limit);
  error InvalidPostSwapBalance(uint postSwapBalance, uint limit);

  // Access Controls
  error OnlyController();

  // Transfer
  error TransferFailed(address to, uint value, address token);

  // Cool down
  error InsufficientTimeBetweenSwaps(uint minValidSwapTime);

  // Fee
  error AboveMaxFee(uint feeInEth, uint maxFee);
}


// File: contracts/interfaces/IWeth.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity >=0.5.0;

interface IWeth {
  function deposit() external payable;

  function withdraw(uint256 wad) external;

  function approve(address spender, uint256 value) external;

  function balanceOf(address account) external view returns (uint256);

  function transfer(address recipient, uint256 amount) external returns (bool);
}


// File: contracts/modules/capital/SwapOperator.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity ^0.8.18;

import "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol";

import "../../interfaces/ICowSettlement.sol";
import "../../interfaces/INXMMaster.sol";
import "../../interfaces/IPool.sol";
import "../../interfaces/ISwapOperator.sol";
import "../../interfaces/IPriceFeedOracle.sol";
import "../../interfaces/IWeth.sol";
import "../../interfaces/IERC20Detailed.sol";
import "../../interfaces/ISwapOperator.sol";
import "../../interfaces/ISafeTracker.sol";

import "../../external/enzyme/IEnzymeFundValueCalculatorRouter.sol";
import "../../external/enzyme/IEnzymeV4Vault.sol";
import "../../external/enzyme/IEnzymeV4Comptroller.sol";
import "../../external/enzyme/IEnzymePolicyManager.sol";

/// @title A contract for swapping Pool's assets using CoW protocol
/// @dev This contract's address is set on the Pool's swapOperator variable via governance
contract SwapOperator is ISwapOperator {
  using SafeERC20 for IERC20;

  // Structs
  struct Request {
    address asset;
    uint amount;
  }

  // Storage
  bytes public currentOrderUID;

  // Immutables
  ICowSettlement public immutable cowSettlement;
  address public immutable cowVaultRelayer;
  INXMMaster public immutable master;
  address public immutable swapController;
  IWeth public immutable weth;
  bytes32 public immutable domainSeparator;

  address public immutable enzymeV4VaultProxyAddress;
  IEnzymeFundValueCalculatorRouter public immutable enzymeFundValueCalculatorRouter;
  uint public immutable minPoolEth;

  // Constants
  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
  uint public constant MAX_SLIPPAGE_DENOMINATOR = 10000;
  uint public constant MIN_VALID_TO_PERIOD = 600; // 10 minutes
  uint public constant MAX_VALID_TO_PERIOD = 3600; // 60 minutes
  uint public constant MIN_TIME_BETWEEN_ORDERS = 900; // 15 minutes
  uint public constant MAX_FEE = 0.3 ether;

  // Safe variables
  address public safe;
  Request public transferRequest;
  mapping(address => bool) public allowedSafeTransferAssets;

  modifier onlyController() {
    if (msg.sender != swapController) {
      revert OnlyController();
    }
    _;
  }

    modifier onlySafe() {
      require(msg.sender == safe, "SwapOp: only Safe can execute");
      _;
    }

  /// @param _cowSettlement Address of CoW protocol's settlement contract
  /// @param _swapController Account allowed to place and close orders
  /// @param _master Address of Nexus' master contract
  /// @param _weth Address of wrapped eth token
  constructor(
    address _cowSettlement,
    address _swapController,
    address _master,
    address _weth,
    address _enzymeV4VaultProxyAddress,
    address _safe,
    address _dai,
    address _usdc,
    IEnzymeFundValueCalculatorRouter _enzymeFundValueCalculatorRouter,
    uint _minPoolEth
  ) {
    cowSettlement = ICowSettlement(_cowSettlement);
    cowVaultRelayer = cowSettlement.vaultRelayer();
    master = INXMMaster(_master);
    swapController = _swapController;
    weth = IWeth(_weth);
    domainSeparator = cowSettlement.domainSeparator();
    enzymeV4VaultProxyAddress = _enzymeV4VaultProxyAddress;
    enzymeFundValueCalculatorRouter = _enzymeFundValueCalculatorRouter;
    minPoolEth = _minPoolEth;
    safe = _safe;
    allowedSafeTransferAssets[_dai] = true;
    allowedSafeTransferAssets[_usdc] = true;
    allowedSafeTransferAssets[ETH] = true;
  }

  receive() external payable {}

  /// @dev Compute the digest of an order using CoW protocol's logic
  /// @param order The order
  /// @return The digest
  function getDigest(GPv2Order.Data calldata order) public view returns (bytes32) {
    bytes32 hash = GPv2Order.hash(order, domainSeparator);
    return hash;
  }

  /// @dev Compute the UID of an order using CoW protocol's logic
  /// @param order The order
  /// @return The UID (56 bytes)
  function getUID(GPv2Order.Data calldata order) public view returns (bytes memory) {
    bytes memory uid = new bytes(56);
    bytes32 digest = getDigest(order);
    GPv2Order.packOrderUidParams(uid, digest, order.receiver, order.validTo);
    return uid;
  }

  /// @dev Using oracle prices, returns the equivalent amount in `toAsset` for a given `fromAmount` in `fromAsset`
  /// Supports conversions for ETH to Asset, Asset to ETH, and Asset to Asset
  function getOracleAmount(address fromAsset, address toAsset, uint fromAmount) internal view returns (uint) {
    IPriceFeedOracle priceFeedOracle = _pool().priceFeedOracle();

    if (fromAsset == address(weth)) {
      // ETH -> toAsset
      return priceFeedOracle.getAssetForEth(toAsset, fromAmount);
    }
    if (toAsset == address(weth)) {
      // fromAsset -> ETH
      return priceFeedOracle.getEthForAsset(fromAsset, fromAmount);
    }
    // fromAsset -> toAsset via ETH
    uint fromAmountInEth = priceFeedOracle.getEthForAsset(fromAsset, fromAmount);
    return priceFeedOracle.getAssetForEth(toAsset, fromAmountInEth);
  }

  /// @dev Reverts if amountOut is less than amountOutMin
  function validateAmountOut(uint amountOut, uint amountOutMin) internal pure {
    if (amountOut < amountOutMin) {
      revert AmountOutTooLow(amountOut, amountOutMin);
    }
  }

  /// @dev Validates order.buyAmount against oracle prices and slippage limits
  /// Uses the higher maxSlippageRatio of either sell or buy swap details, then checks if the swap amount meets the minimum after slippage
  function validateOrderAmount(
    GPv2Order.Data calldata order,
    SwapDetails memory sellSwapDetails,
    SwapDetails memory buySwapDetails
  ) internal view {
    uint oracleBuyAmount = getOracleAmount(address(order.sellToken), address(order.buyToken), order.sellAmount);

    // Use the higher slippage ratio of either sell/buySwapDetails
    uint16 higherMaxSlippageRatio = sellSwapDetails.maxSlippageRatio > buySwapDetails.maxSlippageRatio
      ? sellSwapDetails.maxSlippageRatio
      : buySwapDetails.maxSlippageRatio;

    uint maxSlippageAmount = (oracleBuyAmount * higherMaxSlippageRatio) / MAX_SLIPPAGE_DENOMINATOR;
    uint minBuyAmountOnMaxSlippage = oracleBuyAmount - maxSlippageAmount;

    validateAmountOut(order.buyAmount, minBuyAmountOnMaxSlippage);
  }

  /// @dev Reverts if both swapDetails min/maxAmount are set to 0
  function validateTokenIsEnabled(address token, SwapDetails memory swapDetails) internal pure {
    if (swapDetails.minAmount == 0 && swapDetails.maxAmount == 0) {
      revert TokenDisabled(token);
    }
  }

  /// @dev Reverts if both swapDetails min/maxAmount (excluding WETH) are set to 0
  /// WETH is excluded in validation since it does not have set swapDetails (i.e. SwapDetails(0,0,0,0))
  function validateTokenIsEnabledSkipWeth(address token, SwapDetails memory swapDetails) internal view {
    if (token != address(weth)) {
      validateTokenIsEnabled(token, swapDetails);
    }
  }

  /// @dev Validates two conditions:
  /// 1. The current sellToken balance is greater than sellSwapDetails.maxAmount
  /// 2. The post-swap sellToken balance is greater than or equal to sellSwapDetails.minAmount
  /// Skips validation for WETH since it does not have set swapDetails
  function validateSellTokenBalance(
    IPool pool,
    GPv2Order.Data calldata order,
    SwapDetails memory sellSwapDetails,
    SwapOperationType swapOperationType,
    uint totalOutAmount
  ) internal view {
    uint sellTokenBalance = order.sellToken.balanceOf(address(pool));

    // validate ETH balance is within ETH reserves after the swap
    if (swapOperationType == SwapOperationType.EthToAsset) {
      uint ethPostSwap = address(pool).balance - totalOutAmount;
      if (ethPostSwap < minPoolEth) {
        revert InvalidPostSwapBalance(ethPostSwap, minPoolEth);
      }
      // skip sellSwapDetails validation for ETH/WETH since it does not have set swapDetails
      return;
    }

    if (sellTokenBalance <= sellSwapDetails.maxAmount) {
      revert InvalidBalance(sellTokenBalance, sellSwapDetails.maxAmount);
    }
    // NOTE: the totalOutAmount (i.e. sellAmount + fee) is used to get postSellTokenSwapBalance
    uint postSellTokenSwapBalance = sellTokenBalance - totalOutAmount;
    if (postSellTokenSwapBalance < sellSwapDetails.minAmount) {
      revert InvalidPostSwapBalance(postSellTokenSwapBalance, sellSwapDetails.minAmount);
    }
  }

  /// @dev Validates two conditions:
  /// 1. The current buyToken balance is less than buySwapDetails.minAmount
  /// 2. The post-swap buyToken balance is less than or equal to buySwapDetails.maxAmount
  /// Skip validation for WETH since it does not have set swapDetails
  function validateBuyTokenBalance(
    IPool pool,
    GPv2Order.Data calldata order,
    SwapDetails memory buySwapDetails
  ) internal view {
    uint buyTokenBalance = order.buyToken.balanceOf(address(pool));

    // skip validation for WETH since it does not have set swapDetails
    if (address(order.buyToken) == address(weth)) {
      return;
    }

    if (buyTokenBalance >= buySwapDetails.minAmount) {
      revert InvalidBalance(buyTokenBalance, buySwapDetails.minAmount);
    }
    // NOTE: use order.buyAmount to get postBuyTokenSwapBalance
    uint postBuyTokenSwapBalance = buyTokenBalance + order.buyAmount;
    if (postBuyTokenSwapBalance > buySwapDetails.maxAmount) {
      revert InvalidPostSwapBalance(postBuyTokenSwapBalance, buySwapDetails.maxAmount);
    }
  }

  /// @dev Helper function to determine the SwapOperationType of the order
  /// NOTE: ETH orders has WETH address because ETH will be eventually converted to WETH to do the swap
  function getSwapOperationType(GPv2Order.Data memory order) internal view returns (SwapOperationType) {
    if (address(order.sellToken) == address(weth)) {
      return SwapOperationType.EthToAsset;
    }
    if (address(order.buyToken) == address(weth)) {
      return SwapOperationType.AssetToEth;
    }
    return SwapOperationType.AssetToAsset;
  }

  /// @dev Performs pre-swap validation checks for the given order
  function performPreSwapValidations(
    IPool pool,
    IPriceFeedOracle priceFeedOracle,
    GPv2Order.Data calldata order,
    SwapOperationType swapOperationType,
    uint totalOutAmount
  ) internal view {
    // NOTE: for assets that does not have any set swapDetails such as WETH it will have SwapDetails(0,0,0,0)
    SwapDetails memory sellSwapDetails = pool.getAssetSwapDetails(address(order.sellToken));
    SwapDetails memory buySwapDetails = pool.getAssetSwapDetails(address(order.buyToken));

    // validate both sell and buy tokens are enabled
    validateTokenIsEnabledSkipWeth(address(order.sellToken), sellSwapDetails);
    validateTokenIsEnabledSkipWeth(address(order.buyToken), buySwapDetails);

    // validate sell/buy token balances against swapDetails min/max
    validateSellTokenBalance(pool, order, sellSwapDetails, swapOperationType, totalOutAmount);
    validateBuyTokenBalance(pool, order, buySwapDetails);

    // validate swap frequency to enforce cool down periods
    validateSwapFrequency(sellSwapDetails);
    validateSwapFrequency(buySwapDetails);

    // validate max fee and max slippage
    validateMaxFee(priceFeedOracle, address(order.sellToken), order.feeAmount);
    validateOrderAmount(order, sellSwapDetails, buySwapDetails);
  }

  /// @dev Executes asset transfers from Pool to SwapOperator for CoW Swap order executions
  /// Additionally if selling ETH, wraps received Pool ETH to WETH
  function executeAssetTransfer(
    IPool pool,
    IPriceFeedOracle priceFeedOracle,
    GPv2Order.Data calldata order,
    SwapOperationType swapOperationType,
    uint totalOutAmount
  ) internal returns (uint swapValueEth) {
    address sellTokenAddress = address(order.sellToken);
    address buyTokenAddress = address(order.buyToken);

    if (swapOperationType == SwapOperationType.EthToAsset) {
      // set lastSwapTime of buyToken only (sellToken WETH has no set swapDetails)
      pool.setSwapDetailsLastSwapTime(buyTokenAddress, uint32(block.timestamp));
      // transfer ETH from pool and wrap it (use ETH address here because swapOp.sellToken is WETH address)
      pool.transferAssetToSwapOperator(ETH, totalOutAmount);
      weth.deposit{value: totalOutAmount}();
      // no need to convert since totalOutAmount is already in ETH (i.e. WETH)
      swapValueEth = totalOutAmount;
    } else if (swapOperationType == SwapOperationType.AssetToEth) {
      // set lastSwapTime of sellToken only (buyToken WETH has no set swapDetails)
      pool.setSwapDetailsLastSwapTime(sellTokenAddress, uint32(block.timestamp));
      // transfer ERC20 asset from Pool
      pool.transferAssetToSwapOperator(sellTokenAddress, totalOutAmount);
      // convert totalOutAmount (sellAmount + fee) to ETH
      swapValueEth = priceFeedOracle.getEthForAsset(sellTokenAddress, totalOutAmount);
    } else {
      // SwapOperationType.AssetToAsset
      // set lastSwapTime of sell / buy tokens
      pool.setSwapDetailsLastSwapTime(sellTokenAddress, uint32(block.timestamp));
      pool.setSwapDetailsLastSwapTime(buyTokenAddress, uint32(block.timestamp));
      // transfer ERC20 asset from Pool
      pool.transferAssetToSwapOperator(sellTokenAddress, totalOutAmount);
      // convert totalOutAmount (sellAmount + fee) to ETH
      swapValueEth = priceFeedOracle.getEthForAsset(sellTokenAddress, totalOutAmount);
    }
  }

  /// @dev Approve a given order to be executed, by presigning it on CoW protocol's settlement contract
  /// Validates the order before the sellToken is transferred from the Pool to the SwapOperator for the CoW swap operation
  /// Emits OrderPlaced event on success. Only one order can be open at the same time
  /// NOTE: ETH orders are expected to have a WETH address because ETH will be eventually converted to WETH to do the swap
  /// @param order - The order to be placed
  /// @param orderUID - the UID of the of the order to be placed
  function placeOrder(GPv2Order.Data calldata order, bytes calldata orderUID) public onlyController {
    if (orderInProgress()) {
      revert OrderInProgress(currentOrderUID);
    }

    // Order UID and basic CoW params validations
    validateUID(order, orderUID);
    validateBasicCowParams(order);

    IPool pool = _pool();
    IPriceFeedOracle priceFeedOracle = pool.priceFeedOracle();
    uint totalOutAmount = order.sellAmount + order.feeAmount;
    SwapOperationType swapOperationType = getSwapOperationType(order);

    // Perform validations
    performPreSwapValidations(pool, priceFeedOracle, order, swapOperationType, totalOutAmount);

    // Execute swap based on operation type
    uint swapValueEth = executeAssetTransfer(pool, priceFeedOracle, order, swapOperationType, totalOutAmount);

    // Set the swapValue on the pool
    pool.setSwapValue(swapValueEth);

    // Approve cowVaultRelayer contract to spend sellToken totalOutAmount
    order.sellToken.safeApprove(cowVaultRelayer, totalOutAmount);

    // Store the orderUID
    currentOrderUID = orderUID;

    // Sign the Cow order
    cowSettlement.setPreSignature(orderUID, true);

    // Emit OrderPlaced event
    emit OrderPlaced(order);
  }

  /// @dev Close a previously placed order, returning assets to the pool (either fulfilled or not)
  /// Emits OrderClosed event on success
  /// @param order The order to close
  function closeOrder(GPv2Order.Data calldata order) external {
    // Validate there is an order in place
    if (!orderInProgress()) {
      revert NoOrderInPlace();
    }

    // Before validTo, only controller can call this. After it, everyone can call
    if (block.timestamp <= order.validTo && msg.sender != swapController) {
      revert OnlyController();
    }

    validateUID(order, currentOrderUID);

    // Check how much of the order was filled
    uint filledAmount = cowSettlement.filledAmount(currentOrderUID);

    // Invalidate signature, cancel order and unapprove tokens
    cowSettlement.setPreSignature(currentOrderUID, false);
    cowSettlement.invalidateOrder(currentOrderUID);
    order.sellToken.safeApprove(cowVaultRelayer, 0);

    // Clear the current order
    delete currentOrderUID;

    IPool pool = _pool();

    // Withdraw both buyToken and sellToken
    returnAssetToPool(pool, order.buyToken);
    returnAssetToPool(pool, order.sellToken);

    // Set swapValue on pool to 0
    pool.setSwapValue(0);

    // Emit event
    emit OrderClosed(order, filledAmount);
  }

  /// @dev Return a given asset to the pool, either ETH or ERC20
  /// @param asset The asset
  function returnAssetToPool(IPool pool, IERC20 asset) internal {
    uint balance = asset.balanceOf(address(this));

    if (balance == 0) {
      return;
    }

    if (address(asset) == address(weth)) {
      // Unwrap WETH
      weth.withdraw(balance);

      // Transfer ETH to pool
      (bool sent, ) = payable(address(pool)).call{value: balance}("");
      if (!sent) {
        revert TransferFailed(address(pool), balance, ETH);
      }
    } else {
      // Transfer ERC20 to pool
      asset.safeTransfer(address(pool), balance);
    }
  }

  /// @dev General validations on individual order fields
  /// @param order The order
  function validateBasicCowParams(GPv2Order.Data calldata order) internal view {
    uint minValidTo = block.timestamp + MIN_VALID_TO_PERIOD;
    uint maxValidTo = block.timestamp + MAX_VALID_TO_PERIOD;

    if (order.validTo < minValidTo) {
      revert BelowMinValidTo(minValidTo);
    }
    if (order.validTo > maxValidTo) {
      revert AboveMaxValidTo(maxValidTo);
    }
    if (order.receiver != address(this)) {
      revert InvalidReceiver(address(this));
    }
    if (address(order.sellToken) == ETH) {
      // must to be WETH address for ETH swaps
      revert InvalidTokenAddress('sellToken');
    }
    if (address(order.buyToken) == ETH) {
      // must to be WETH address for ETH swaps
      revert InvalidTokenAddress('buyToken');
    }
    if (order.sellTokenBalance != GPv2Order.BALANCE_ERC20) {
      revert UnsupportedTokenBalance('sell');
    }
    if (order.buyTokenBalance != GPv2Order.BALANCE_ERC20) {
      revert UnsupportedTokenBalance('buy');
    }
  }

  /// @dev Validate that a given UID is the correct one for a given order
  /// @param order The order
  /// @param providedOrderUID The UID
  function validateUID(GPv2Order.Data calldata order, bytes memory providedOrderUID) internal view {
    bytes memory calculatedOrderUID = getUID(order);
    if (keccak256(calculatedOrderUID) != keccak256(providedOrderUID)) {
      revert OrderUidMismatch(providedOrderUID, calculatedOrderUID);
    }
  }

  /// @dev Get the Pool's instance through master contract
  /// @return The pool instance
  function _pool() internal view returns (IPool) {
    return IPool(master.getLatestAddress("P1"));
  }


   // @dev Get the SafeTracker's instance through master contract
   // @return The safe tracker instance
  function safeTracker() internal view returns (ISafeTracker) {
    return ISafeTracker(master.getLatestAddress("ST"));
  }

  /// @dev Validates that a given asset is not swapped too fast
  /// @param swapDetails Swap details for the given asset
  function validateSwapFrequency(SwapDetails memory swapDetails) internal view {
    uint minValidSwapTime = swapDetails.lastSwapTime + MIN_TIME_BETWEEN_ORDERS;
    if (block.timestamp < minValidSwapTime) {
      revert InsufficientTimeBetweenSwaps(minValidSwapTime);
    }
  }

  /// @dev Validate that the fee for the order is not higher than the maximum allowed fee, in ether
  /// @param sellToken The sell asset
  /// @param feeAmount The fee (will always be denominated in the sell asset units)
  function validateMaxFee(
    IPriceFeedOracle priceFeedOracle,
    address sellToken,
    uint feeAmount
  ) internal view {
    uint feeInEther = sellToken == address(weth)
      ? feeAmount
      : priceFeedOracle.getEthForAsset(sellToken, feeAmount);
    if (feeInEther > MAX_FEE) {
      revert AboveMaxFee(feeInEther, MAX_FEE);
    }
  }

  /// @dev Exchanges ETH for Enzyme Vault shares with slippage control. Emits `Swapped` on success
  /// @param amountIn Amount of ETH to be swapped for Enzyme Vault shares
  /// @param amountOutMin Minimum Enzyme Vault shares out expected
  function swapETHForEnzymeVaultShare(uint amountIn, uint amountOutMin) external onlyController {

    // Validate there's no current cow swap order going on
    if (orderInProgress()) {
      revert OrderInProgress(currentOrderUID);
    }

    IPool pool = _pool();
    IEnzymeV4Comptroller comptrollerProxy = IEnzymeV4Comptroller(IEnzymeV4Vault(enzymeV4VaultProxyAddress).getAccessor());
    IERC20Detailed toToken = IERC20Detailed(enzymeV4VaultProxyAddress);


    SwapDetails memory swapDetails = pool.getAssetSwapDetails(address(toToken));

    validateTokenIsEnabled(address(toToken), swapDetails);
    validateSwapFrequency(swapDetails);

    {
      // check slippage
      (, uint netShareValue) = enzymeFundValueCalculatorRouter.calcNetShareValue(enzymeV4VaultProxyAddress);

      uint avgAmountOut = amountIn * 1e18 / netShareValue;
      uint maxSlippageAmount = avgAmountOut * swapDetails.maxSlippageRatio / MAX_SLIPPAGE_DENOMINATOR;
      uint minOutOnMaxSlippage = avgAmountOut - maxSlippageAmount;

      validateAmountOut(amountOutMin, minOutOnMaxSlippage);
    }

    uint balanceBefore = toToken.balanceOf(address(pool));
    pool.transferAssetToSwapOperator(ETH, amountIn);

    address denominationAsset = comptrollerProxy.getDenominationAsset();
    if (denominationAsset != address(weth)) {
      revert InvalidDenominationAsset(denominationAsset, address(weth));
    }

    weth.deposit{ value: amountIn }();
    weth.approve(address(comptrollerProxy), amountIn);
    comptrollerProxy.buyShares(amountIn, amountOutMin);

    pool.setSwapDetailsLastSwapTime(address(toToken), uint32(block.timestamp));

    uint amountOut = toToken.balanceOf(address(this));

    validateAmountOut(amountOut, amountOutMin);
    if (balanceBefore >= swapDetails.minAmount) {
      revert InvalidBalance(balanceBefore, swapDetails.minAmount);
    }
    if (balanceBefore + amountOutMin > swapDetails.maxAmount) {
      revert InvalidPostSwapBalance(balanceBefore + amountOutMin, swapDetails.maxAmount);
    }

    uint ethBalanceAfter = address(pool).balance;
    if (ethBalanceAfter < minPoolEth) {
      revert InvalidPostSwapBalance(ethBalanceAfter, minPoolEth);
    }

    transferAssetTo(enzymeV4VaultProxyAddress, address(pool), amountOut);

    emit Swapped(ETH, enzymeV4VaultProxyAddress, amountIn, amountOut);
  }

  /// @dev Exchanges Enzyme Vault shares for ETH with slippage control. Emits `Swapped` on success
  /// @param amountIn Amount of Enzyme Vault shares to be swapped for ETH
  /// @param amountOutMin Minimum ETH out expected
  function swapEnzymeVaultShareForETH(
    uint amountIn,
    uint amountOutMin
  ) external onlyController {

    // Validate there's no current cow swap order going on
    if (orderInProgress()) {
      revert OrderInProgress(currentOrderUID);
    }

    IPool pool = _pool();
    IERC20Detailed fromToken = IERC20Detailed(enzymeV4VaultProxyAddress);

    uint balanceBefore = fromToken.balanceOf(address(pool));
    {

      SwapDetails memory swapDetails = pool.getAssetSwapDetails(address(fromToken));

      validateTokenIsEnabled(address(fromToken), swapDetails);
      validateSwapFrequency(swapDetails);

      uint netShareValue;
      {
        address denominationAsset;
        (denominationAsset, netShareValue) =
        enzymeFundValueCalculatorRouter.calcNetShareValue(enzymeV4VaultProxyAddress);

        if (denominationAsset != address(weth)) {
          revert InvalidDenominationAsset(denominationAsset, address(weth));
        }
      }

      // avgAmountOut in ETH
      uint avgAmountOut = amountIn * netShareValue / (10 ** fromToken.decimals());
      uint maxSlippageAmount = avgAmountOut * swapDetails.maxSlippageRatio / MAX_SLIPPAGE_DENOMINATOR;
      uint minOutOnMaxSlippage = avgAmountOut - maxSlippageAmount;

      // slippage check
      validateAmountOut(amountOutMin, minOutOnMaxSlippage);
      if (balanceBefore <= swapDetails.maxAmount) {
        revert InvalidBalance(balanceBefore, swapDetails.maxAmount);
      }
      if (balanceBefore - amountIn < swapDetails.minAmount) {
        revert InvalidPostSwapBalance(balanceBefore - amountIn, swapDetails.minAmount);
      }
    }

    pool.transferAssetToSwapOperator(address(fromToken), amountIn);

    IEnzymeV4Comptroller comptrollerProxy = IEnzymeV4Comptroller(IEnzymeV4Vault(enzymeV4VaultProxyAddress).getAccessor());
    fromToken.approve(address(comptrollerProxy), amountIn);

    address[] memory payoutAssets = new address[](1);
    uint[] memory payoutAssetsPercentages = new uint[](1);

    payoutAssets[0] = address(weth);
    payoutAssetsPercentages[0] = 10000;

    comptrollerProxy.redeemSharesForSpecificAssets(address(this), amountIn, payoutAssets, payoutAssetsPercentages);

    uint amountOut = weth.balanceOf(address(this));
    weth.withdraw(amountOut);

    pool.setSwapDetailsLastSwapTime(address(fromToken), uint32(block.timestamp));

    validateAmountOut(amountOut, amountOutMin);

    transferAssetTo(ETH, address(pool), amountOut);

    emit Swapped(enzymeV4VaultProxyAddress, ETH, amountIn, amountOut);
  }

  function transferAssetTo (address asset, address to, uint amount) internal {

    if (asset == ETH) {
      (bool ok, /* data */) = to.call{ value: amount }("");
      if (!ok) {
        revert TransferFailed(to, amount, ETH);
      }
      return;
    }

    IERC20 token = IERC20(asset);
    token.safeTransfer(to, amount);
  }


   // @dev Create a request for the transfer to the safe
  function requestAsset(address asset, uint amount) external onlySafe {
    require(allowedSafeTransferAssets[asset] == true, "SwapOp: asset not allowed");
    transferRequest = Request(asset, amount);
  }

  // @dev Transfer request amount of the asset to the safe
  function transferRequestedAsset(address requestedAsset, uint requestedAmount) external onlyController {
    require(transferRequest.amount > 0, "SwapOp: request amount must be greater than 0");

    (address asset, uint amount) = (transferRequest.asset, transferRequest.amount);
    delete transferRequest;

    require(requestedAsset == asset, "SwapOp: request assets need to match");
    require(requestedAmount == amount, "SwapOp: request amounts need to match");

    _pool().transferAssetToSwapOperator(asset, amount);
    transferAssetTo(asset, safe, amount);
    emit TransferredToSafe(asset, amount);
  }

  /// @dev Recovers assets in the SwapOperator to the pool or a specified receiver, ensuring no ongoing CoW swap orders
  /// @param assetAddress Address of the asset to recover
  /// @param receiver Address to receive the recovered assets, if asset is not supported by the pool
  function recoverAsset(address assetAddress, address receiver) public onlyController {

    // Validate there's no current cow swap order going on
    if (orderInProgress()) {
      revert OrderInProgress(currentOrderUID);
    }

    IPool pool = _pool();

    if (assetAddress == ETH) {
      uint ethBalance = address(this).balance;
      if (ethBalance == 0) {
        revert InvalidBalance(ethBalance, 0);
      }

      // We assume ETH is always supported so we directly transfer it back to the Pool
      (bool sent, ) = payable(address(pool)).call{value: ethBalance}("");
      if (!sent) {
        revert TransferFailed(address(pool), ethBalance, ETH);
      }

      return;
    }

    IERC20 asset = IERC20(assetAddress);

    uint balance = asset.balanceOf(address(this));
    if (balance == 0) {
      revert InvalidBalance(balance, 0);
    }

    SwapDetails memory swapDetails = pool.getAssetSwapDetails(assetAddress);

    if (swapDetails.minAmount == 0 && swapDetails.maxAmount == 0) {
      // asset is not supported
      asset.transfer(receiver, balance);
      return;
    }

    asset.transfer(address(pool), balance);
  }

  /// @dev Checks if there is an ongoing order
  /// @return bool True if an order is currently in progress, otherwise false
  function orderInProgress() public view returns (bool) {
    return currentOrderUID.length > 0;
  }
}

