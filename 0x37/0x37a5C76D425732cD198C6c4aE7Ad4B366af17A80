
// File: src/CHWY.sol
/*

                            _ _ _          _   _                _              _    
            __      _____  | (_) | _____  | |_| |__   ___   ___| |_ ___  _ __ | | __
            \ \ /\ / / _ \ | | | |/ / _ \ | __| '_ \ / _ \ / __| __/ _ \| '_ \| |/ /
             \ V  V /  __/ | | |   <  __/ | |_| | | |  __/ \__ \ || (_) | | | |   < 
              \_/\_/ \___| |_|_|_|\_\___|  \__|_| |_|\___| |___/\__\___/|_| |_|_|\_\
            

####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################
#############################%%%%%%%%%%######################%%%%%%%%%%#############################
######################%%%%%%%%%%%%%%%%%%%%#**+=======++*##%%%%%%%%%%%%%%%%%%%%######################
#################%%%%%%%%%%%%%%%%%%%%%%%#*=--------------=*#%%%%%%%%%%%%%%%%%%%%%%%#################
#############%%%%%%%%%%%%%%%%%%%%%%%%#+----------------------+#%%%%%%%%%%%%%%%%%%%%%%%%#############
###########%%%%%%%%%%%%%%@@@@%%%%%%*=--------------------------=*%%%%%%@@@@%%%%%%%%%%%%%%###########
###########%%%%%%%%%%%%%%@@@@@%%%+--------------------------------+%%%@@@@@%%%%%%%%%%%%%%###########
##########%%%%%%%%%%%%%%%%@@@@%*------===-----------------===-------*@@@@@%%%%%%%%%%%%%%%%##########
##########%%%%%%%%%%%%%%%%%@@#------=-::::-=-----------==-::::-=------#@@%%%%%%%%%%%%%%%%%##########
#########%%%%%%%%%%%%%%%%%%@+-----=-::::::::-=--------=-::::::::-=-----+%%%%%%%%%%%%%%%%%%%#########
#########%%%%%%%%%%%%%%%%%%*-----=-::::::::::-=------=:::::::::::-=-----*%%%%%%%%%%%%%%%%%%#########
#########%%%%%%%%%%%%%%%%%%+----=-::::::::::::-=----=:::::::::::::-=----*%%%%%%%%%%%%%%%%%%#########
#########%%%%%%%%%%%%%%%%%%+----=::::::::::::::=---=-::::::::::::::=----+%%%%%%%%%%%%%%%%%%#########
##########%%%%%%%%%%%%%%%%%+---=-::::::::=+++=:-=--=:::::::::=+++=:=----+%%%%%%%%%%%%%%%%%##########
##########%%%%%%%%%%%%%%%%%=---=:::::::=*#%%-:-==--=:::::::=*###::===---=%%%%%%%%%%%%%%%%%##########
##########%%%%%%%%%%%%%%%%#=---=::::::-*#@@@%+**=--=::::::=*#@@@%*#*=---=#%%%%%%%%%%%%%%%%##########
###########%%%%%%%%%%%%%%%#----=::::::-+%@@@@@%*=--=::::::=+%@@@@@%*=----#%%%%%%%%%%%%%%%###########
###########%%%%%%%%%%%%%%%+----=-::::::==%@@@%#*=--=::::::-==%@@@%*+-----+%%%%%%%%%%%%%%%###########
############%%%%%%%%%%%%%*------=:::::::-====+==---=-:::::::==--=+==------*%%%%%%%%%%%%%############
#############%%%%%%%%%%%#=------=-::::::::::::-=----=:::::::::::::-=------=#%%%%%%%%%%%#############
##############%%%%%%%%%#=--------=:::::::::::-=-----==:::::::::::-=--------=#%%%%%%%%%##############
###############%%%%%%#=-----------=-::::::::-=--------=:::::::::-=-----------=#%%%%%%###############
#################*-----------------==:::::-==----------=-:::::-=-----------------=##################
#################+---------------------==-----------------===---------------------*#################
#################=-------------------------::::::::::::::-------------------------+#################
#################=-------------------::::::::::::::::::::::::::-------------------+#################
#################=---------------::::::::::::::::::::::::::::::::::---------------=#################
#################=-------------::::::::::::+#%%%%%%%%%%#+::::::::::::-------------+#################
#################+-----------:::::::::::::=%%%%%%%%%%%%%%=:::::::::::::-----------*#################
##################=---------::::::::::::::-#%%%%%%%%%%%%#-::::::::::::::---------=##################
##################*--------:::::::-:::::::::#%%%%%%%%%%#::::::-::::::::::-------=*##################
###################*-------:::::::--:::::::::-%%%%%%%%-:::::::--:::::::::------=####################
#####################+-----::::::::::::::::::::-*%%*-::::::::::::::::::::----=+#####################
#######################*==-::::---::----::::::::::::::::::::----::---::::-==*#######################
###########################-::::::::-----::::::::::::::::::-----::::::::-###########################
############################-::::::::---:::::::::==:::::::::---::::::::-############################
#############################-::::::::::::::::::+##+::::::::::::::::::-#############################
##############################*-::::::::::::::-*####*-::::::::::::::-*##############################
################################*=::::::::::-*########*-::::::::::=*################################
#####################################**+**#######**#######**+**#####################################
##############################################********##############################################
###########################################**************###########################################
############################################************############################################
#############################################**********#############################################
################################################****################################################
####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################


Social Links:
https://x.com/TheRoaringKitty/status/1806371920495186041

*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;


import {FixedSupplyERC20} from "./ERC20.sol";
import {IUniswapV2Factory} from "v2-core/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Pair} from "v2-core/interfaces/IUniswapV2Pair.sol";


/**
 * @title Efficient Tax Token with Powerful Modifiable Launch Protection Mechanisms
 * @notice The contract's constants owner, tax recipient, supply recipient, 
 *         and various tax and transaction settings.

 * @custom:error NotYetTrading Thrown when an action is attempted before trading is enabled.
 * @custom:error AlreadyTrading Thrown when an action is attempted after trading is already enabled.
 * @custom:error NotOwner Thrown when an action is attempted by an address other than the owner.
 * @custom:error TaxCanOnlyBeLowered Thrown when an attempt is made to increase the tax rate.
**/

contract CHWY is FixedSupplyERC20 {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          ERRORS                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    error NotYetTrading();
    error AlreadyTrading();
    error NotOwner();
    error TaxCanOnlyBeLowered();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          CONSTANTS                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    address constant V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address constant LIQUIDITY_VAULT = 0x9af6deA52E5512CE9DA2547cb24AA96Ff2679c02;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant TAX_RECIPIENT = 0x3DE682867C593ad2fA9b6e49bBDDfd5C5eaEd412;
    address constant OWNER = 0x3DE682867C593ad2fA9b6e49bBDDfd5C5eaEd412;

    IUniswapV2Pair immutable V2_PAIR;
    uint256 immutable MAX_TXN;
    uint256 immutable SWAP_THRESHOLD;

    bool constant IMMEDIATE_LAUNCH = true;
    uint16 constant BIP_DIVISOR = 10_000;
    uint16 constant START_BUY_TAX_BIPS = 0;
    uint16 constant START_SELL_TAX_BIPS = 0;
    uint16 constant INIT_BUY_TAX_BIPS = 0;
    uint16 constant INIT_SELL_TAX_BIPS = 0;
    uint16 constant MAX_TXN_BIPS = 1000;
    uint16 constant SWAP_THRESHOLD_BIPS = 25;
    uint32 constant DYNAMIC_TAX_DURATION = 0;
    uint32 constant MAX_TXN_DURATION = 0;
    uint256 constant TOTAL_SUPPLY = 9282009 * 10 ** 18;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          EVENTS                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    event UpdatedTax(uint256 buyTaxBIPS, uint256 sellTaxBIPS);


    constructor() FixedSupplyERC20(TOTAL_SUPPLY, msg.sender) {
        MAX_TXN = TOTAL_SUPPLY * MAX_TXN_BIPS / BIP_DIVISOR;
        SWAP_THRESHOLD = TOTAL_SUPPLY * SWAP_THRESHOLD_BIPS / BIP_DIVISOR;

        // Inlined from UniswapFactory
        (address token0, address token1) = address(this) < WETH ? (address(this), WETH) : (WETH, address(this));
        V2_PAIR = IUniswapV2Pair(
            address(uint160(uint256(keccak256(abi.encodePacked(
                hex'ff',
                V2_FACTORY,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            )))))
        );

        _slot = _encodeSlot(INIT_BUY_TAX_BIPS, INIT_SELL_TAX_BIPS, IMMEDIATE_LAUNCH ? uint224(block.timestamp) : 0);
        emit UpdatedTax(INIT_BUY_TAX_BIPS, INIT_SELL_TAX_BIPS);
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// Bits Layout of '_slot':
    /// - [0.. 15]    16 bits   'buyTaxBIPS'
    /// - [16..31]    16 bits   'sellTaxBIPS'
    /// - [32..255]  224 bits   'startTime'
    uint256 _slot;

    mapping(bytes32 => uint256) _maxTransaction;


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL FUNCTIONS                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * @dev Decodes the '_slot' into its constituent parts.
     * @return buyTaxBIPS The buy tax in BIPS.
     * @return sellTaxBIPS The sell tax in BIPS.
     * @return startTime The start time.
     */
    function _decodeSlot(uint256 slot) internal pure returns (uint256 buyTaxBIPS, uint256 sellTaxBIPS, uint256 startTime) {
        buyTaxBIPS = uint256(uint16(slot));
        sellTaxBIPS = uint256(uint16(slot >> 16));
        startTime = uint256(slot >> 32);
    }

    /**
     * @dev Encodes the given parameters into a single slot.
     * @param buyTaxBIPS The buy tax in BIPS.
     * @param sellTaxBIPS The sell tax in BIPS.
     * @param startTime The start time.
     * @return slot The encoded slot.
     */
    function _encodeSlot(uint256 buyTaxBIPS, uint256 sellTaxBIPS, uint256 startTime) internal pure returns (uint256) {
        return uint256(uint16(buyTaxBIPS)) | (uint256(uint16(sellTaxBIPS)) << 16) | (startTime << 32);
    }

    /**
     * @dev Releases the accumulated tax by swapping the token balance held by the contract
     *      for WETH through the Uniswap V2 pair. The function checks if the accumulated tax
     *      exceeds the swap threshold or if the current tax is zero and there is any tax buildup.
     *      If either condition is met, it performs the swap and transfers the resulting WETH to
     *      the tax recipient.
     *
     * @param currentTax The current tax amount to be released.
     */
    function _releaseTax(uint currentTax) internal {
        uint256 CACHED_SWAP_THRESHOLD = SWAP_THRESHOLD;
        uint256 taxBuildUp = balanceOf(address(this));

        if (taxBuildUp >= CACHED_SWAP_THRESHOLD || (currentTax == 0 && taxBuildUp > 0)) {
            bool isToken0 = address(this) < WETH;
            uint256 swapAmount = taxBuildUp > CACHED_SWAP_THRESHOLD ? CACHED_SWAP_THRESHOLD : taxBuildUp;

            IUniswapV2Pair pair = V2_PAIR; 
            (uint256 r0, uint256 r1, ) = pair.getReserves();
            (uint256 rIn, uint256 rOut) = isToken0 ? (r0, r1) : (r1, r0);
            // Inlined from UniswapV2Library
            uint amountInWithFee = swapAmount * 997;
            uint numerator = amountInWithFee * rOut;
            uint denominator = rIn * 1000 + amountInWithFee;
            uint amountOut = numerator / denominator;

            super._transfer(address(this), address(pair), swapAmount, false);
            pair.swap(isToken0 ? 0 : amountOut, isToken0 ? amountOut : 0, TAX_RECIPIENT, new bytes(0));
        }
    }

    /**
     * @dev Internal function to handle token transfers, applying taxes and transaction limits.
     *      This function overrides the '_update' function from the parent contract.
     *
     * @param from The address from which tokens are being transferred.
     * @param to The address to which tokens are being transferred.
     * @param amount The amount of tokens being transferred.
     */
    function _transfer(address from, address to, uint256 amount, bool checkAllowance) internal override {
        if (from == TAX_RECIPIENT    || to == TAX_RECIPIENT)    return super._transfer(from, to, amount, checkAllowance);
        if (from == OWNER || to == OWNER) return super._transfer(from, to, amount, checkAllowance);
        if (from == address(this)    || to == address(this))    return super._transfer(from, to, amount, checkAllowance);

        bool isBuy = from == address(V2_PAIR) && 
                        (to != OWNER && 
                         to != LIQUIDITY_VAULT &&
                         to != TAX_RECIPIENT);
                         // when pool sends out tokens for remove liquidity or collect

        bool isSell = to == address(V2_PAIR) && 
                        (from != OWNER &&
                         from != LIQUIDITY_VAULT &&
                         from != TAX_RECIPIENT);
                         // when liquidity is being added


        if (isBuy || isSell) {
            (uint256 buyTaxBIPS, uint256 sellTaxBIPS, uint256 startTime) = _decodeSlot(_slot);
            if (startTime == 0) revert NotYetTrading();

            uint256 startTaxBIPS = isBuy ? START_BUY_TAX_BIPS : START_SELL_TAX_BIPS;
            uint256 taxBIPS = isBuy ? buyTaxBIPS : sellTaxBIPS;
            uint256 elapsedTime = block.timestamp - startTime;

            taxBIPS = elapsedTime >= DYNAMIC_TAX_DURATION ? taxBIPS :
                                startTaxBIPS - (startTaxBIPS - taxBIPS) * elapsedTime / DYNAMIC_TAX_DURATION;

            uint256 tax = amount * taxBIPS / BIP_DIVISOR;
            amount -= tax;

            // Max Txn
            if (isBuy && elapsedTime <= MAX_TXN_DURATION) {
                bytes32 txnHash = keccak256(abi.encodePacked(tx.origin, block.number));
                uint txnTotal = _maxTransaction[txnHash];
                if (txnTotal + amount > MAX_TXN) {
                    if (txnTotal != MAX_TXN) _maxTransaction[txnHash] = MAX_TXN;
                    uint extra = (txnTotal + amount) - MAX_TXN;
                    tax += extra;
                    amount -= extra;
                }
                else _maxTransaction[txnHash] = txnTotal + amount;
            }

            if (isSell) _releaseTax(taxBIPS); /// @dev: We can only do when amountIn is this token due to pair lock

            if (tax > 0) super._transfer(from, address(this), tax, checkAllowance);
            if (amount > 0) super._transfer(from, to, amount, checkAllowance);

        }
        else return super._transfer(from, to, amount, checkAllowance);
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          EXTERNAL                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
    /// @dev Returns the name of the token.
    function name() public view override returns (string memory) {
        return "Chewy";
    }

    /// @dev Returns the symbol of the token.
    function symbol() public view override returns (string memory) {
        return "CHWY";
    }

    /// @dev Returns the amount of tokens in existence.
    function totalSupply() public view override returns (uint256 result) {
        return TOTAL_SUPPLY;
    }

    receive() external payable { revert(); }
    fallback() external payable { revert(); }

    function releaseTax() external {
        (uint256 buyTaxBIPS, uint256 sellTaxBIPS, ) = _decodeSlot(_slot);
        _releaseTax(buyTaxBIPS > sellTaxBIPS ? buyTaxBIPS : sellTaxBIPS);
    }

    ///         THIS IS ALL THE CONTRACT OWNER IS LIMITED TO        ///
    function enableTrading() external {
        if (msg.sender != OWNER) revert NotOwner();

        (uint256 buyTaxBIPS, uint256 sellTaxBIPS, uint256 startTime) = _decodeSlot(_slot);
        if (startTime != 0) revert AlreadyTrading();

        _slot = _encodeSlot(buyTaxBIPS, sellTaxBIPS, block.timestamp);
    }

    function lowerTaxes(uint256 buyTaxBIPS, uint256 sellTaxBIPS) external {
        if (msg.sender != OWNER) revert NotOwner();

        (uint256 curBuyTaxBIPS, uint256 curSellTaxBIPS, uint256 startTime) = _decodeSlot(_slot);
        if (buyTaxBIPS > curBuyTaxBIPS || sellTaxBIPS > curSellTaxBIPS) revert TaxCanOnlyBeLowered();

        _slot = _encodeSlot(buyTaxBIPS, sellTaxBIPS, startTime);
        emit UpdatedTax(buyTaxBIPS, sellTaxBIPS);
    }

}

// File: lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol
pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}


// File: lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol
pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}


// File: src/ERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Simple ERC20 + EIP-2612 implementation.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)
/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)
///
/// @dev Note:
/// - The ERC20 standard allows minting and transferring to and from the zero address,
///   minting and transferring zero tokens, as well as self-approvals.
///   For performance, this implementation WILL NOT revert for such actions.
///   Please add any checks with overrides if desired.
/// - The `permit` function uses the ecrecover precompile (0x1).
///
/// If you are overriding:
/// - NEVER violate the ERC20 invariant:
///   the total sum of all balances must be equal to `totalSupply()`.
/// - Check that the overridden function is actually used in the function you want to
///   change the behavior of. Much of the code has been manually inlined for performance.
abstract contract FixedSupplyERC20 {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       CUSTOM ERRORS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The total supply has overflowed.
    error TotalSupplyOverflow();

    /// @dev The allowance has overflowed.
    error AllowanceOverflow();

    /// @dev The allowance has underflowed.
    error AllowanceUnderflow();

    /// @dev Insufficient balance.
    error InsufficientBalance();

    /// @dev Insufficient allowance.
    error InsufficientAllowance();

    /// @dev The permit is invalid.
    error InvalidPermit();

    /// @dev The permit has expired.
    error PermitExpired();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.
    uint256 private constant _TRANSFER_EVENT_SIGNATURE =
        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;

    /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.
    uint256 private constant _APPROVAL_EVENT_SIGNATURE =
        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    /// @dev The balance slot of `owner` is given by:
    /// ```
    ///     mstore(0x0c, _BALANCE_SLOT_SEED)
    ///     mstore(0x00, owner)
    ///     let balanceSlot := keccak256(0x0c, 0x20)
    /// ```
    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;

    /// @dev The allowance slot of (`owner`, `spender`) is given by:
    /// ```
    ///     mstore(0x20, spender)
    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)
    ///     mstore(0x00, owner)
    ///     let allowanceSlot := keccak256(0x0c, 0x34)
    /// ```
    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;

    /// @dev The nonce slot of `owner` is given by:
    /// ```
    ///     mstore(0x0c, _NONCES_SLOT_SEED)
    ///     mstore(0x00, owner)
    ///     let nonceSlot := keccak256(0x0c, 0x20)
    /// ```
    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CONSTANTS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.
    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;

    /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.
    bytes32 private constant _DOMAIN_TYPEHASH =
        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

    /// @dev `keccak256("1")`.
    bytes32 private constant _VERSION_HASH =
        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;

    /// @dev `keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")`.
    bytes32 private constant _PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       ERC20 METADATA                       */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the name of the token.
    function name() public view virtual returns (string memory);

    /// @dev Returns the symbol of the token.
    function symbol() public view virtual returns (string memory);

    /// @dev Returns the decimals places of the token.
    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERC20                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor(uint256 _totalSupply, address supplyRecipient) {
         assembly {
            let amount := _totalSupply
            // Compute the balance slot and load its value.
            mstore(0x0c, _BALANCE_SLOT_SEED)
            mstore(0x00, supplyRecipient)
            let toBalanceSlot := keccak256(0x0c, 0x20)
            // Add and store the updated balance.
            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
            // Emit the {Transfer} event.
            mstore(0x20, amount)
            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))
        }
    }

    /// @dev Returns the amount of tokens in existence.
    function totalSupply() public view virtual returns (uint256 result);

    /// @dev Returns the amount of tokens owned by `owner`.
    function balanceOf(address owner) public view virtual returns (uint256 result) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x0c, _BALANCE_SLOT_SEED)
            mstore(0x00, owner)
            result := sload(keccak256(0x0c, 0x20))
        }
    }

    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.
    function allowance(address owner, address spender)
        public
        view
        virtual
        returns (uint256 result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x20, spender)
            mstore(0x0c, _ALLOWANCE_SLOT_SEED)
            mstore(0x00, owner)
            result := sload(keccak256(0x0c, 0x34))
        }
    }

    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
    ///
    /// Emits a {Approval} event.
    function approve(address spender, uint256 amount) public virtual returns (bool) {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the allowance slot and store the amount.
            mstore(0x20, spender)
            mstore(0x0c, _ALLOWANCE_SLOT_SEED)
            mstore(0x00, caller())
            sstore(keccak256(0x0c, 0x34), amount)
            // Emit the {Approval} event.
            mstore(0x00, amount)
            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))
        }
        return true;
    }

    /// @dev Transfer `amount` tokens from the caller to `to`.
    ///
    /// Requirements:
    /// - `from` must at least have `amount`.
    ///
    /// Emits a {Transfer} event.
    function transfer(address to, uint256 amount) public virtual returns (bool) {
        _beforeTokenTransfer(msg.sender, to, amount);
        _transfer(msg.sender, to, amount, false); 
        _afterTokenTransfer(msg.sender, to, amount);
        return true;
    }

    /// @dev Transfers `amount` tokens from `from` to `to`.
    ///
    /// Note: Does not update the allowance if it is the maximum uint256 value.
    ///
    /// Requirements:
    /// - `from` must at least have `amount`.
    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.
    ///
    /// Emits a {Transfer} event.
    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {
        _beforeTokenTransfer(from, to, amount);
        _transfer(from, to, amount, true); 
        _afterTokenTransfer(from, to, amount);
        return true;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          EIP-2612                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev For more performance, override to return the constant value
    /// of `keccak256(bytes(name()))` if `name()` will never change.
    function _constantNameHash() internal view virtual returns (bytes32 result) {}

    /// @dev Returns the current nonce for `owner`.
    /// This value is used to compute the signature for EIP-2612 permit.
    function nonces(address owner) public view virtual returns (uint256 result) {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the nonce slot and load its value.
            mstore(0x0c, _NONCES_SLOT_SEED)
            mstore(0x00, owner)
            result := sload(keccak256(0x0c, 0x20))
        }
    }

    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,
    /// authorized by a signed approval by `owner`.
    ///
    /// Emits a {Approval} event.
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        bytes32 nameHash = _constantNameHash();
        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
        /// @solidity memory-safe-assembly
        assembly {
            // Revert if the block timestamp is greater than `deadline`.
            if gt(timestamp(), deadline) {
                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.
                revert(0x1c, 0x04)
            }
            let m := mload(0x40) // Grab the free memory pointer.
            // Clean the upper 96 bits.
            owner := shr(96, shl(96, owner))
            spender := shr(96, shl(96, spender))
            // Compute the nonce slot and load its value.
            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)
            mstore(0x00, owner)
            let nonceSlot := keccak256(0x0c, 0x20)
            let nonceValue := sload(nonceSlot)
            // Prepare the domain separator.
            mstore(m, _DOMAIN_TYPEHASH)
            mstore(add(m, 0x20), nameHash)
            mstore(add(m, 0x40), _VERSION_HASH)
            mstore(add(m, 0x60), chainid())
            mstore(add(m, 0x80), address())
            mstore(0x2e, keccak256(m, 0xa0))
            // Prepare the struct hash.
            mstore(m, _PERMIT_TYPEHASH)
            mstore(add(m, 0x20), owner)
            mstore(add(m, 0x40), spender)
            mstore(add(m, 0x60), value)
            mstore(add(m, 0x80), nonceValue)
            mstore(add(m, 0xa0), deadline)
            mstore(0x4e, keccak256(m, 0xc0))
            // Prepare the ecrecover calldata.
            mstore(0x00, keccak256(0x2c, 0x42))
            mstore(0x20, and(0xff, v))
            mstore(0x40, r)
            mstore(0x60, s)
            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)
            // If the ecrecover fails, the returndatasize will be 0x00,
            // `owner` will be checked if it equals the hash at 0x00,
            // which evaluates to false (i.e. 0), and we will revert.
            // If the ecrecover succeeds, the returndatasize will be 0x20,
            // `owner` will be compared against the returned address at 0x20.
            if iszero(eq(mload(returndatasize()), owner)) {
                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.
                revert(0x1c, 0x04)
            }
            // Increment and store the updated nonce.
            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.
            // Compute the allowance slot and store the value.
            // The `owner` is already at slot 0x20.
            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))
            sstore(keccak256(0x2c, 0x34), value)
            // Emit the {Approval} event.
            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)
            mstore(0x40, m) // Restore the free memory pointer.
            mstore(0x60, 0) // Restore the zero pointer.
        }
    }

    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.
    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {
        bytes32 nameHash = _constantNameHash();
        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.
        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));
        /// @solidity memory-safe-assembly
        assembly {
            let m := mload(0x40) // Grab the free memory pointer.
            mstore(m, _DOMAIN_TYPEHASH)
            mstore(add(m, 0x20), nameHash)
            mstore(add(m, 0x40), _VERSION_HASH)
            mstore(add(m, 0x60), chainid())
            mstore(add(m, 0x80), address())
            result := keccak256(m, 0xa0)
        }
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                INTERNAL TRANSFER FUNCTIONS                 */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Moves `amount` of tokens from `from` to `to`.
    function _transfer(address from, address to, uint256 amount, bool checkAllowance) internal virtual {
        _beforeTokenTransfer(from, to, amount);
        /// @solidity memory-safe-assembly
        assembly {
            let from_ := shl(96, from)

            let checkAllowanceValue := checkAllowance
            if checkAllowanceValue {
                // Compute the allowance slot and load its value.
                mstore(0x20, caller())
                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))
                let allowanceSlot := keccak256(0x0c, 0x34)
                let allowance_ := sload(allowanceSlot)
                // If the allowance is not the maximum uint256 value.
                if add(allowance_, 1) {
                    // Revert if the amount to be transferred exceeds the allowance.
                    if gt(amount, allowance_) {
                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
                        revert(0x1c, 0x04)
                    }
                    // Subtract and store the updated allowance.
                    sstore(allowanceSlot, sub(allowance_, amount))
                }
            }

            // Compute the balance slot and load its value.
            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))
            let fromBalanceSlot := keccak256(0x0c, 0x20)
            let fromBalance := sload(fromBalanceSlot)
            // Revert if insufficient balance.
            if gt(amount, fromBalance) {
                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.
                revert(0x1c, 0x04)
            }
            // Subtract and store the updated balance.
            sstore(fromBalanceSlot, sub(fromBalance, amount))
            // Compute the balance slot of `to`.
            mstore(0x00, to)
            let toBalanceSlot := keccak256(0x0c, 0x20)
            // Add and store the updated balance of `to`.
            // Will not overflow because the sum of all user balances
            // cannot exceed the maximum uint256 value.
            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))
            // Emit the {Transfer} event.
            mstore(0x20, amount)
            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))
        }
        _afterTokenTransfer(from, to, amount);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                INTERNAL ALLOWANCE FUNCTIONS                */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.
    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the allowance slot and load its value.
            mstore(0x20, spender)
            mstore(0x0c, _ALLOWANCE_SLOT_SEED)
            mstore(0x00, owner)
            let allowanceSlot := keccak256(0x0c, 0x34)
            let allowance_ := sload(allowanceSlot)
            // If the allowance is not the maximum uint256 value.
            if add(allowance_, 1) {
                // Revert if the amount to be transferred exceeds the allowance.
                if gt(amount, allowance_) {
                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.
                    revert(0x1c, 0x04)
                }
                // Subtract and store the updated allowance.
                sstore(allowanceSlot, sub(allowance_, amount))
            }
        }
    }

    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.
    ///
    /// Emits a {Approval} event.
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        /// @solidity memory-safe-assembly
        assembly {
            let owner_ := shl(96, owner)
            // Compute the allowance slot and store the amount.
            mstore(0x20, spender)
            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))
            sstore(keccak256(0x0c, 0x34), amount)
            // Emit the {Approval} event.
            mstore(0x00, amount)
            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     HOOKS TO OVERRIDE                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Hook that is called before any transfer of tokens.
    /// This includes minting and burning.
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    /// @dev Hook that is called after any transfer of tokens.
    /// This includes minting and burning.
    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}

