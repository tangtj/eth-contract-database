//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⣾⣿⣷⣾⣿⣿⣿⣿⣶⣾⣿⣿⣶⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠉⢉⡽⢋⣙⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢰⣿⣦⣀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣛⣛⣓⣒⠶⢤⣾⠀⠀⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢸⣿⠳⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⡄⠀⠀⢳⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⣿⡦⠀⠀⠻⠿⣦⣀⡀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⡏⠀⠜⡴⠁⠀⠀⠀⡀⠀⠀⠉⠉⠲⢦⡀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢠⣿⣷⡾⢿⣿⣿⣿⣿⣿⠿⢿⣿⣿⣿⣿⣿⡿⠛⠉⠁⠀⠀⣸⠀⠀⠀⢧⠀⠀⠀⠀⠹⠒⢤⣀⠀⠀⠁⠈⢢⠀
//⠀⠀⠀⠀⠀⠀⠀⠈⣿⣟⠀⠀⠈⠻⣿⠏⢨⠔⢦⠈⢻⣿⡼⠋⢀⣤⣶⣶⣿⣿⣿⣄⢠⣀⡜⠆⠀⢀⡠⠴⠒⠂⠈⢻⢦⡀⠀⠈⡇
//⠀⠀⢀⣶⣿⣷⠀⠀⠘⣿⡄⠀⠐⣶⢬⣇⠉⢣⡸⠀⣰⣿⣁⣴⣿⣿⣿⣿⣿⣿⣟⢿⣽⡛⣧⠔⠒⡏⣀⠀⠀⣀⣀⣾⠀⠑⠢⠤⠃
//⠀⣴⡟⣾⡟⣿⡇⣀⣼⣿⣿⣦⡀⠀⠙⠻⡆⠀⠇⢰⠟⠻⣿⣿⣿⣿⣿⡿⣿⣿⣿⣷⡿⠟⣇⠀⠀⢙⣰⣺⣽⣿⣿⣿⠀⠀⠀⠀⠀
//⢸⡿⢸⡿⣰⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⡴⠃⠀⠀⢸⡀⠀⢹⣿⣿⣿⣿⣿⢹⣿⣿⣯⣀⣀⣀⣭⣏⠁⠀⠀⠈⠻⣿⣿⠀⠀⠀⠀⠀
//⣿⡇⢸⡗⢸⠛⣿⡍⠉⠙⠛⠻⢭⣻⣿⣧⠀⠀⢀⣴⠷⣄⡀⠻⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⣿⡻⡆⠀⠀⠀⠀⠙⠇⠀⠀⠀⠀⠀
//⣿⡇⢸⣷⣽⠶⠛⢷⡀⣠⠤⢤⣾⣿⣿⣽⣞⣿⣭⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡙⢿⣿⠉⠛⢿⣿⣷⡇⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀
//⣿⣇⣼⢿⠁⠀⠀⢠⡷⡇⢠⣶⡽⣿⠋⠉⢻⠿⠛⠋⠉⠉⢹⠉⢻⢻⣿⣿⣿⣿⣿⣷⡶⢏⡠⠿⣿⣷⡞⠛⠙⢳⣦⡀⠀⠀⠀⠀⠀
//⣿⡏⢠⡋⣆⠀⠀⡞⠀⠇⠈⢿⣿⣏⠀⠀⠸⡀⠀⠀⠀⢀⡞⠀⢸⢸⣿⡏⠛⠛⠛⠉⣠⠋⣠⠀⠸⠧⢻⡝⢷⡄⢿⣷⠀⠀⠀⠀⠀
//⢸⣧⠸⡹⡌⢆⣴⣿⡀⠀⠀⠈⠻⠿⣆⠀⠀⠳⣄⣰⣚⠉⠉⠉⠻⣾⣿⡻⣦⣀⣠⣴⠷⠟⣻⠀⠀⠀⢸⡇⢸⣧⢨⣿⠀⠀⠀⠀⠀
//⠀⢿⣇⠓⠃⣼⣇⡈⠻⣄⠀⠰⢦⣀⢀⣷⡄⠀⠀⠀⠈⠉⠓⡤⣄⡈⡿⣿⣷⣶⣶⣶⣾⣿⠟⢀⠆⠀⡾⢷⣾⡇⣼⡟⠀⠀⠀⠀⠀
//⠀⠈⢿⢷⣞⠛⣿⣿⣤⡍⠳⣤⣤⣤⡿⠗⠁⠀⠀⠀⠀⠀⠀⠙⠀⠹⡅⠀⠈⠉⠉⠉⠻⣤⠔⠚⠒⠊⠀⠀⠈⣿⡿⠃⠀⠀⠀⠀⠀
// ███████ █████ ██   ██  ██⣤⣔⡊⣀⠀⠀⡷⠀⠀⠀⢀⣴⠞⠓⠲⠦⣤⡀⠀⠀⣠⡿⠁⠀⠀⠀⠀⠀⠀
// ██         ██ ██   ██ ███⠀⢹⠀⠙⣤⣃⣤⠶⠞⣫⣤⣟⣛⣷⣶⣿⢟⡦⣾⠟⠀⠀⠀⠀⠀⠀⠀⠀
// █████     ██  ███████  ██ ⢸⠀⠀⣿⡏⠾⠿⣶⣿⣿⣿⠿⣛⣽⣾⡿⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ██       ██        ██  ██ ⡇⠀⣠⠏⠉⠛⠳⠶⢶⣶⡿⠿⠟⠊⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ███████  ██        ██  ██⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

// A public demonstration in single-contract dual-token implementations
// with zero-conflict events, and function overloading.
// https://github.com/SJ741/E741-Platform
// https://741.gg   (Get the token telegram link from 'telegram' variable)
// Emerald Token Standard

// WARNING - Fungible NFT specs are universally new, and inherently DANGEROUS
// no systems have been built with these usecases in mind, and there are a number of 
// ways that experimental, complex contracts can lead to unforseen consequences.
// INTERACT WITH EXPERIMENTAL SMART CONTRACTS AT YOUR OWN RISK

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;


// libraries to separate ERC20 and ERC721 events, and certain signature-specific functions
// ERC20 events
library libES20 {
    event Transfer(address indexed from, address indexed to, uint amount);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function emitTransfer(address _from, address _to, uint _amount) internal { emit Transfer(_from, _to, _amount); }
    function emitApproval(address _owner, address _spender, uint _value) internal { emit Approval(_owner, _spender, _value); }
}

// ERC721 events
library libES721 {
    event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
    function emitTransfer(address _from, address _to, uint _tokenId) internal { emit Transfer(_from, _to, _tokenId); }
    function emitApproval(address _owner, address _approve, uint _tokenId) internal { emit Approval(_owner, _approve, _tokenId); }
    function emitApprovalForAll(address _owner, address _operator, bool _approved) internal { emit ApprovalForAll(_owner, _operator, _approved); }
}

// ERC165 https://eips.ethereum.org/EIPS/eip-721
interface IERC165 {
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

// ERC20 https://eips.ethereum.org/EIPS/eip-20
interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function decimals() external view returns (uint);
}

// ERC721 https://eips.ethereum.org/EIPS/eip-721
interface IERC721 is IERC165 {
    function balanceOf(address account) external view returns (uint256);
    function ownerOf(uint256 _tokenId) external view returns (address);
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
    function setApprovalForAll(address _operator, bool _approved) external;
    function getApproved(uint256 _tokenId) external view returns (address);
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
    // payable removed for erc20 etherscan compatibility
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

interface IE741 is IERC20, IERC721 {
    // supportsInterface 0x5a46575f 
    // library transfers can not be included in the interface
    // incorporate them directly with library
    // libES20.Transfer
    // libES20.Approval
    // libES721.Transfer
    // libES721.Approval
    // libES721.ApprovalForAll
    function balanceOf(address account) external override(IERC20, IERC721) view returns (uint256);
    function approve(address spender, uint256 value) external override(IERC20, IERC721) returns (bool);
    function transferFrom(address from, address to, uint256 value) external override(IERC20, IERC721) returns (bool);
}

interface IERC721Metadata {
    function name() external view returns (string memory _name);
    function symbol() external view returns (string memory _symbol);
    function tokenURI(uint256 _tokenId) external view returns (string memory);
}

interface IERC7572 {
    function contractURI() external view returns (string memory);
    event ContractURIUpdated();
}

interface IERC20Metadata {
    function name() external view returns (string memory _name);
    function symbol() external view returns (string memory _symbol);
    function tokenURI(uint256 _tokenId) external view returns (string memory);
}

interface IDevable {
    function initialize(bytes memory encodedParameters) external returns (address);
    function dev() external returns (address dev);
    function setContractURI(string memory newContractURI) external;
    function setBaseURI(string memory newBaseURI) external;
    function changeDev(address newDev) external;
    function toggelNFTinterface() external;
    function withdraw() external;
    function setExtension(string memory newExtension) external;
    function setTelegram(string memory newTelegram) external;
    function setSkipMintingGlobal(bool newSkipMintingGlobal) external;
}

// ERC721 Token Receiver https://eips.ethereum.org/EIPS/eip-721
interface IERC721TokenReceiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);
}

contract ERC721TokenReceiver is IERC721TokenReceiver {
    function onERC721Received(address, address, uint256, bytes memory) external virtual returns(bytes4) {
        return IERC721TokenReceiver.onERC721Received.selector;
    }
}

abstract contract E741V1Base is IDevable, ERC721TokenReceiver, IE741  {

    address public constant BROKEN_ADDRESS = address(0x5e7ec);
    address public constant DEPOSIT_ADDRESS = address(0x0);
    address public constant MINT_ADDRESS = address(0x0);

    string public baseURI;
    string internal _contractURI;
    string public extension;
    string public telegram;
    string internal _name;
    string internal _symbol;
    uint internal _decimals;
    uint internal _totalIds;
    uint internal _totalSupply;
    uint internal ONE; // 1.0 token(s)
    uint internal MAXID; // e.g. 1.00000001 : 1.00007777 is the range for NFT IDs
    uint64 public minted; // number of unique ID mints + ONE
    address public dev;
    bool public supportsNFTinterface;
    bool public skipMintingGlobal = false;

    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(address => mapping(address => uint)) internal _allowance;
    mapping(uint256 tokenId => address) public ownerOf;
    mapping(uint256 => address) private _nftApprovals;
    mapping(address => uint) internal _balanceOf;
    mapping(address => uint64[]) public ownedNFTs; // broken NFTs stored in limbo list are at ownedNFTs[BROKEN_ADDRESS]
    mapping(uint64 => uint256) internal idToIndex; 
    mapping(address => bool) internal skipMintingUser;

    error UnsupportedReceiver();

    modifier onlyDev() {
        require(msg.sender == dev, "Not the developer");
        _;
    }

    constructor() {
        dev = msg.sender;
    }

    function initialize(bytes memory encodedParameters) public override virtual returns (address underlyingToken);
    function deposit(uint[] memory amounts) public virtual;
    function withdraw(uint[] memory amounts) public payable virtual;

    function name() public view virtual returns (string memory) { return _name; }
    function symbol() public view virtual returns (string memory) { return _symbol; }
    function decimals() public view virtual returns (uint) { return _decimals; }
    function totalSupply() public view virtual returns (uint) { return _totalSupply; }
    function maxSupply() public view virtual returns (uint) { return _totalIds * ONE; }
    function balanceOf( address account) public view override returns (uint) { return _balanceOf[account]; }
    function allowance(address owner, address spender) public view override returns (uint) { return _allowance[owner][spender]; }
    function setBaseURI(string memory newBaseURI) public onlyDev override {baseURI = newBaseURI;}
    function setContractURI(string memory newContractURI) public onlyDev override virtual {_contractURI = newContractURI; emit IERC7572.ContractURIUpdated();}
    function setExtension(string memory newExtension) public onlyDev override virtual {extension = newExtension;}
    function setTelegram(string memory newTelegram) public onlyDev virtual {telegram = newTelegram;}
    function changeDev(address newDev) public onlyDev override  {dev = newDev;}//simple function to change developer address, or revoke ownership (with address(0))
    // @DEV toggleNFTinterface is for the small possibility of frontend system changes leading the contract to favor enabling the disabled supportsNFTinterface flag
    // don't waste it, as frontends don't typically change classification of contracts
    // probably never to be used.
    function toggelNFTinterface() public onlyDev override {supportsNFTinterface = !supportsNFTinterface;}
    function tokensOfOwner(address owner) public view returns (uint64[] memory){return ownedNFTs[owner];}
    function nftBalanceOf(address account) public view returns (uint) {return ownedNFTs[account].length;}
    function contractURI() public view virtual returns (string memory) {return _contractURI;}
    function setSkipMintingGlobal(bool newSkipMintingGlobal) public override virtual onlyDev { skipMintingGlobal = newSkipMintingGlobal; } 
    function setSkipMinting(bool newSkipMinting) public virtual { skipMintingUser[msg.sender] = newSkipMinting; }

    function approve(address spender, uint amount) public override returns (bool) {

        // if the amount is greater than one token, and within range of IDs for NFTs 
        // then set NFT approval for the given ID
        if(amount >= ONE && amount <= MAXID) {
            address owner = ownerOf[amount]; // getting the owner of token ID via the `amount` input
            if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert("E741: You are not approved");
            _nftApprovals[amount] = spender; // calling nft approval for the token and spender
            libES721.emitApproval(owner, spender, amount);
            return true;
        }
        
        // else set the ERC20 allowance
        // the NFT ID range being set within a limited subset of ONE token(s)
        // allows for non-clashing interactions
        _allowance[msg.sender][spender] = amount;
        libES20.emitApproval(msg.sender, spender, amount);
        return true;
    }

    function _transfer741(address from, address to, uint amount) internal virtual {
        
        require(_balanceOf[from] >= amount, "E741: transfer amount exceeds balance");
        
        // checking the decimal amount of tokens owned before transaction for both participants
        uint256 fromDecimalsPre = _balanceOf[from] % ONE;
        uint256 toDecimalsPre = _balanceOf[to] % ONE;
        
        // simple erc20 balance operations
        _transfer20(from, to, amount);

        // checking the decimal amount of tokens after transaction for both partcipants
        uint256 fromDecimalsPost = _balanceOf[from] % ONE;
        uint256 toDecimalsPost = _balanceOf[to] % ONE;

        // stores the NFT IDs owned by `from`, enabling NFT management for that address.
        uint64[] storage ownedNFTsArray = ownedNFTs[from];

        // references NFTs marked as "broken", tracking these special state NFTs.
        uint64[] storage brokenIDsArray = ownedNFTs[BROKEN_ADDRESS];
        

        // if sender has higher decimal count after transaction, then they "roll under" and break an NFT
        if (fromDecimalsPre < fromDecimalsPost) {

            if(ownedNFTsArray.length > 0) { // if the sender has an nft to send
                //pushes the last nft in the owned list into the "broken list" for limbo NFTs
                _transfer721Pop(from, BROKEN_ADDRESS, ownedNFTsArray); //transfers the NFT ID ownership to BROKEN address for stewardship
            }
        }

        // if receiver has lower decimal count after transaction then they "roll over" and will "remake" an nft 
        if (toDecimalsPre > toDecimalsPost) {

            if(brokenIDsArray.length > 0) { // recover an id from broken list

                _transfer721Pop(BROKEN_ADDRESS, to, brokenIDsArray);
            }
            else { // mint new id
                _mint(to);
            }
            
        }
        
        // amount of tokens - amount of whole tokens being processed in int
        uint amountInTokens = amount / ONE;

        uint len = ownedNFTsArray.length; //len is the length, or number of NFTs in the addresses's owned array

        // ignore minting nfts from dev when they call -- this allows for gas-efficient team operations
        // @DEV if dev gathers NFTs, use the ERC721 transferFrom method to extract
        // @DEV be careful, don't let the wallet fall to some convoluted transferFrom scam to do something unexpected
        if(skipMintingGlobal || from == DEPOSIT_ADDRESS || skipMintingUser[to] || skipMintingUser[from] || from == dev) {
            //  When skipping minting the nft holder can only send out the tokens they hold (reduce gas)
            amountInTokens = amountInTokens < len ? amountInTokens : len;
        }

        if(amountInTokens > 0) {
            
            len = amountInTokens < len ? amountInTokens : len;
            // transfers owned NFTs from `from` to `to` until either all are transferred or the desired amount is reached
            // Subtracts transferred NFT count from `amountInTokens` to update remaining transfers
            for (uint i = 0; i < len; i++) {
                _transfer721Pop(from, to, ownedNFTsArray); 
            }
            amountInTokens -= len;
            len = brokenIDsArray.length;
            len = amountInTokens < len ? amountInTokens : len;
            
            // recovers NFTs from the broken state to `to`, or mints new ones if not enough broken NFTs are available
            // if any tokens remain to be allocated, it mints new NFTs to `to` for the remaining balance
            for (uint i = 0; i < len; i++) {        
                _transfer721Pop(BROKEN_ADDRESS, to, brokenIDsArray);
            }

            _mintBatch(to, amountInTokens - len);

        }
    }

    function _mintBatch(address to, uint256 amount) internal virtual {
        if(amount == 0) return; // Exit if no NFTs to mint

        if(amount == 1) { // Optimize single mint process
            _mint(to);
            return;
        }
        uint64 id = minted; // Start ID from last minted value
        uint256 ownedLen = ownedNFTs[to].length; // Current number of NFTs owned by 'to'
        for(uint i = 0; i < amount;) {
            unchecked {
                id++; // Increment ID for each new NFT
            }
            ownerOf[id] = to; // Assign new NFT to owner.
            idToIndex[id] = ownedLen; // Map NFT ID to its index in owner's array
            ownedNFTs[to].push(id); // Add new NFT ID to owner's list

            libES721.emitTransfer(MINT_ADDRESS, to, id); // Emit NFT transfer event

            unchecked {
                ownedLen++; // Increment count of owned NFTs
                i++; // Move to next NFT
            }
        }
        unchecked {
            minted += uint64(amount); // Update total minted count
        }
    }


    function _mint(address to) internal virtual returns(uint64 tokenId){
        unchecked {
            minted++; // Increment the total number of minted tokens
        }
        tokenId = minted; // Assign the newly minted token ID

        ownerOf[tokenId] = to; // Set ownership of the new token to 'to'
        idToIndex[tokenId] = ownedNFTs[to].length; // Map the new token ID to its index in the owner's list
        ownedNFTs[to].push(tokenId); // Add the new token ID to the owner's list of owned tokens
        
        libES721.emitTransfer(MINT_ADDRESS, to, tokenId); // Emit an event for the token transfer
    }


    // Updates the mappings and arrays managing ownership and index of NFTs after a transfer
    function _updateOwnedNFTs(address from, address to, uint64 tokenId) internal { 
        uint256 index = idToIndex[tokenId]; // Get current index of the token in the owner's list
        uint64[] storage nftArray = ownedNFTs[from]; // Reference to the list of NFTs owned by 'from'
        uint256 len = nftArray.length; // Current number of NFTs owned by 'from'
        uint64 lastTokenId = nftArray[len - 1]; // Last token in the 'from' array to swap with transferred token
        
        nftArray[index] = lastTokenId; // Replace the transferred token with the last token in the array
        nftArray.pop(); // Remove the last element, effectively deleting the transferred token from 'from'
        
        if(len - 1 != 0){ 
            idToIndex[lastTokenId] = index; // Update the index of the swapped token
        } 
    
        ownedNFTs[to].push(tokenId); // Add the transferred token to the 'to' array
        idToIndex[tokenId] = ownedNFTs[to].length - 1; // Update the index mapping for the transferred token
    }

    // Executes a simple ERC20 token transfer.
    function _transfer20(address from, address to, uint256 amount) internal {
        _balanceOf[from] -= amount; // Deduct the amount from the sender's balance
        unchecked {
            _balanceOf[to] += amount; // Add the amount to the recipient's balance
        }
        libES20.emitTransfer(from, to, amount); // Emit an ERC20 transfer event
    }

    // Handles the transfer of an ERC721 token, ensuring proper ownership and event emission
    function _transfer721(address from, address to, uint64 tokenId) internal virtual {
        require(from == ownerOf[tokenId], "E741: Incorrect owner"); // Ensure 'from' is the current owner
        
        delete _nftApprovals[tokenId]; // Clear any approvals for this token
        ownerOf[tokenId] = to; // Transfer ownership of the token to 'to'
        _updateOwnedNFTs(from, to, tokenId); // Update ownership tracking structures
        libES721.emitTransfer(from, to, tokenId); // Emit an ERC721 transfer event
    }

    // Handles the transfer of an ERC721 token, ensuring proper ownership and event emission
    function _transfer721Pop(address from, address to, uint64[] storage nftArray) internal virtual {
        uint64 tokenId = nftArray[nftArray.length - 1];
        
        delete _nftApprovals[tokenId]; // Clear any approvals for this token
        ownerOf[tokenId] = to; // Transfer ownership of the token to 'to'
        
        // update owned nfts pop edition
        nftArray.pop(); // Remove the last element, effectively deleting the transferred token from 'from'    
        ownedNFTs[to].push(tokenId); // Add the transferred token to the 'to' array
        idToIndex[tokenId] = ownedNFTs[to].length - 1; // Update the index mapping for the transferred token

        libES721.emitTransfer(from, to, tokenId); // Emit an ERC721 transfer event
    }


    // only erc20 calls this
    // if amount is a token id owned my the caller send as an NFT
    // else transfer741
    function transfer(address to, uint amount) public override returns (bool) {
        if(ownerOf[amount] == msg.sender) {
            _transfer721(msg.sender, to, uint64(amount));
            _transfer20(msg.sender, to, ONE);
            return true;
        }
        _transfer741(msg.sender, to, amount);
        return true;
    }

    // erc20 and erc721 call this
    function transferFrom(address from, address to, uint amount) public override returns (bool) {

        //if amount is within the NFT id range, then a simple NFT transfer + token amount (ONE)
        if(amount >= ONE && amount <= MAXID) {
            require(
                //require from is the msg caller, or that caller is approved for that specific NFT, or all NFTs 
                msg.sender == from || msg.sender == getApproved(amount) || isApprovedForAll(from, msg.sender),
                "E741: You don't have the right"
                );

            _transfer721(from, to, uint64(amount));
            _transfer20(from, to, ONE);
            return true;
        }

        _spendAllowance(from, msg.sender, amount);
        _transfer741(from, to, amount);
        return true;

    }

    // erc721
    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override {
        require(
                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),
                "E741: You don't have the right"
            );
        _transfer721(from, to, uint64(tokenId)); 
        _transfer20(from, to, ONE);

        if (
            to.code.length != 0 &&
            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, "") !=
            IERC721TokenReceiver.onERC721Received.selector
        ) {
            revert UnsupportedReceiver();
        }
    }

    // erc721
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable override {
        require(
                msg.sender == from || msg.sender == getApproved(tokenId) || isApprovedForAll(from, msg.sender),
                "E741: You don't have the right"
            );
        _transfer721(from, to, uint64(tokenId)); 
        _transfer20(from, to, ONE);

        if (
            to.code.length != 0 &&
            IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) !=
            IERC721TokenReceiver.onERC721Received.selector
        ) {
            revert UnsupportedReceiver();
        }
    }

    function _spendAllowance(address owner, address spender, uint amount) internal virtual {
        require(_allowance[owner][spender] >= amount, "E741: insufficient allowance");
        _allowance[owner][spender] -= amount;
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        if (ownerOf[tokenId] == address(0)) revert();
        return _nftApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        _operatorApprovals[msg.sender][operator] = approved;
        libES721.emitApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        require(tokenId <= MAXID, "E741: invalid id");
        if (bytes(baseURI).length == 0) {return "";}
        return string(abi.encodePacked(baseURI, toString(tokenId - ONE), extension));
    }

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {return "0";} uint256 temp = value; uint256 digits;
        while (temp != 0) {digits++; temp /= 10;} bytes memory buffer = new bytes(digits);
        while (value != 0) {digits -= 1; buffer[digits] = bytes1(uint8(value % 10) + 48); value /= 10;}
        return string(buffer);
    }

    function withdraw() external onlyDev override {
        (bool success,) = payable(dev).call{value: address(this).balance}("");
        require(success);
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return
            // Even though we support ERC721 and should return true, etherscan wants to treat us as ERC721 instead of ERC20
            // @DEV ERC165 for ERC721 can be toggled on for reasons of frontend/dapp/script implementations, but is very specific
            (supportsNFTinterface && interfaceId == 0x80ac58cd) || // ERC165 interface ID for ERC721
            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165
            interfaceId == 0x36372b07 || // ERC165 interface ID for ERC20
            interfaceId == 0x150b7a02 || // ERC165 interface ID for IERC721TokenReceiver
            interfaceId == 0x5a46575f;   // ERC165 interface ID for IE741
            
    }
}

pragma solidity ^0.8.24;


contract E741V1Wrapped741 is E741V1Base {

    event Deposit(address indexed from, uint amount741Out, uint[] amounts741In);
    event Withdrawal(address indexed to, uint amountUnderlyingOut, uint[] amounts741In);

    address constant EMERALDS = 0x382EDfe4c6168858C81893fE00fCB7b68914d929;
    address public underlying741;
    uint public underlyingWeiPerNft;

    address public feeRecipient;
    uint public withdrawalFees;
    uint internal withdrawalFeesDivisor = 10000;
    uint constant WITHDRAWAL_FEES_MIN = 5; // 0.05%
    uint constant WITHDRAWAL_FEES_MAX = 50; // 0.5%

    function initialize(bytes memory encodedParameters) public virtual override returns (address) {
        require(_decimals == 0, "Already initialized");
        
        {
            // to prevent stack to deep error
            string memory _inputName; 
            string memory _inputSymbol;
            (withdrawalFees, underlying741, _inputName, _inputSymbol, _decimals, baseURI, _contractURI, _totalIds, underlyingWeiPerNft) = 
                abi.decode(encodedParameters, (uint,address,string,string,uint,string,string,uint,uint));

            _name = _inputName;
            _symbol = _inputSymbol;
        }

        {
            address _token = underlying741;
            require(_token != address(0), 'E741V1: ZERO_ADDRESS');
            try IERC165(_token).supportsInterface(0x5a46575f) returns (bool supports741) {
                require(_token == EMERALDS || supports741, "The underlying token does not support e741");
            } catch {
                revert("The underlying token does not support ERC165");
            }
        }

        ONE = 10 ** _decimals;
        MAXID = ONE + _totalIds - 1;
        minted = uint64(ONE) - 1; // start minting from ID ONE-1 so you can get id 0

        feeRecipient = msg.sender; // our factory is always the fee recipient even if dev of token changes

        require(_decimals <= 18 && IERC20(underlying741).decimals() <= 18, "Too many decimals");
        require(_totalIds > 0, "Need at least 1 nft");
        require(withdrawalFees >= WITHDRAWAL_FEES_MIN, "Min fees of 0.05%");
        require(withdrawalFees <= WITHDRAWAL_FEES_MAX, "Max fees of 0.5%");
        require(ONE > _totalIds, "Not enough decimals for NFT count");

        return underlying741;
    }


    // deposit amount of underlying741
    function deposit(uint[] memory _amountsArray) public virtual override {

        uint _len = _amountsArray.length;
        uint _amount741Out;
        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();

        if(_len == 1) {
            if(IE741(underlying741).ownerOf(_amountsArray[0]) != msg.sender) { // not single nft transfer
                _amount741Out = (_amountsArray[0] * ONE) / underlyingWeiPerNft;
            }
            else {
                _amount741Out = (_underlyingONE * ONE) / underlyingWeiPerNft; // _len is 1
            }            
            // use direct from array to transfer the nft id if used
            IE741(underlying741).transferFrom(msg.sender, address(this), _amountsArray[0]);
        }
        else {
            for(uint i = 0; i < _len; i++) {
                // reverts if they deposit unowned or invalid id
                IE741(underlying741).safeTransferFrom(msg.sender, address(this), _amountsArray[i]);
            }
            _amount741Out = ((_len * _underlyingONE) * ONE) / underlyingWeiPerNft;
        }
        // spawn raw tokens
        _balanceOf[DEPOSIT_ADDRESS] += _amount741Out;

        _totalSupply += _amount741Out;

        _transfer741(DEPOSIT_ADDRESS, msg.sender, _amount741Out); // use _transfer741 to give user broken nfts if necessary

        // donating tokens to this wrapper will only make the wrapped token more scarce
        require(underlyingWeiPerNft * _totalIds >=  IERC20(underlying741).balanceOf(address(this)), "NFT capacity reached, wait for someone to withdraw");

        emit Deposit(msg.sender, _amount741Out, _amountsArray);
    }

    // Two modes
    // withdraw([amount])
    // withdraw([id1, id2, id3])
    function withdraw(uint256[] memory _amountsArray741) public virtual override payable {
        uint _arrayLen = _amountsArray741.length;
        require(_arrayLen > 0, "Trying to withdraw nothing");

        uint _amount741; uint _amount741Sum;
        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();

        if (_arrayLen == 1) {
            _amount741 = _amountsArray741[0];
            if (ownerOf[_amount741] == msg.sender) {
                _amount741Sum = ONE; // only record ONE for owned transfer
            } else {
                _amount741Sum = _amount741;
            }
            transfer(DEPOSIT_ADDRESS, _amount741);
        } else {
            for(uint i = 0; i < _arrayLen;) {
                _amount741 = _amountsArray741[i];
                require(ownerOf[_amount741] == msg.sender, "Can only withdraw for nfts you own");
                transfer(DEPOSIT_ADDRESS, _amount741);
                unchecked { i++; }
            }
            _amount741Sum = _arrayLen * ONE; // only record ONE for owned transfer
        }
        // remove raw tokens
        _balanceOf[DEPOSIT_ADDRESS] -= _amount741Sum;
        _totalSupply -= _amount741Sum;

        uint _totalUnderlyingOut = (_amount741Sum * underlyingWeiPerNft) / ONE; // use ONE not _underlyingONE
        uint _totalUnderlyingFees = (_totalUnderlyingOut * withdrawalFees) / withdrawalFeesDivisor;

        IE741(underlying741).transfer(feeRecipient, _totalUnderlyingFees);
        
        IE741(underlying741).transfer(msg.sender, (_totalUnderlyingOut - _totalUnderlyingFees));

        emit Withdrawal(msg.sender, _totalUnderlyingOut, _amountsArray741);
    }
}