
// File: contracts/GelatoRelay1BalanceV2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {IGelatoRelay1BalanceV2} from "./interfaces/IGelatoRelay1BalanceV2.sol";
import {IGelato1BalanceV2} from "./interfaces/IGelato1BalanceV2.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";

/// @title  Gelato Relay V2 contract
/// @notice This contract deals with Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-states-count
contract GelatoRelay1BalanceV2 is IGelatoRelay1BalanceV2, IGelato1BalanceV2 {
    using GelatoCallUtils for address;

    /// @notice Relay call + One Balance payment - with sponsor authentication
    /// @dev    This method can be called directly without passing through the diamond
    /// @dev    The validity of the emitted LogUseGelato1BalanceV2 event must be verified off-chain
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @param _target Relay call target
    /// @param _data Relay call data
    /// @param _correlationId Unique task identifier generated by gelato
    /// Signature is split into `r` and `vs` - See https://eips.ethereum.org/EIPS/eip-2098
    /// @param _r Checker signature
    /// @param _vs Checker signature
    function sponsoredCallV2(
        address _target,
        bytes calldata _data,
        bytes32 _correlationId,
        bytes32 _r,
        bytes32 _vs
    ) external {
        // These parameters are decoded from calldata
        (_correlationId);
        (_r);
        (_vs);

        // INTERACTIONS
        _target.revertingContractCall(_data, "GelatoRelay.sponsoredCallV2:");

        emit LogUseGelato1BalanceV2();
    }
}


// File: contracts/interfaces/IGelato1BalanceV2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

interface IGelato1BalanceV2 {
    event LogUseGelato1BalanceV2();
}


// File: contracts/interfaces/IGelatoRelay1BalanceV2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

interface IGelatoRelay1BalanceV2 {
    function sponsoredCallV2(
        address _target,
        bytes calldata _data,
        bytes32 _correlationId,
        bytes32 _r,
        bytes32 _vs
    ) external;
}


// File: contracts/lib/GelatoBytes.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

library GelatoBytes {
    function calldataSliceSelector(
        bytes calldata _bytes
    ) internal pure returns (bytes4 selector) {
        selector =
            _bytes[0] |
            (bytes4(_bytes[1]) >> 8) |
            (bytes4(_bytes[2]) >> 16) |
            (bytes4(_bytes[3]) >> 24);
    }

    function memorySliceSelector(
        bytes memory _bytes
    ) internal pure returns (bytes4 selector) {
        selector =
            _bytes[0] |
            (bytes4(_bytes[1]) >> 8) |
            (bytes4(_bytes[2]) >> 16) |
            (bytes4(_bytes[3]) >> 24);
    }

    function revertWithError(
        bytes memory _bytes,
        string memory _tracingInfo
    ) internal pure {
        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err
        if (_bytes.length % 32 == 4) {
            bytes4 selector;
            assembly {
                selector := mload(add(0x20, _bytes))
            }
            if (selector == 0x08c379a0) {
                // Function selector for Error(string)
                assembly {
                    _bytes := add(_bytes, 68)
                }
                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));
            } else {
                revert(
                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"))
                );
            }
        } else {
            revert(
                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"))
            );
        }
    }

    function returnError(
        bytes memory _bytes,
        string memory _tracingInfo
    ) internal pure returns (string memory) {
        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err
        if (_bytes.length % 32 == 4) {
            bytes4 selector;
            assembly {
                selector := mload(add(0x20, _bytes))
            }
            if (selector == 0x08c379a0) {
                // Function selector for Error(string)
                assembly {
                    _bytes := add(_bytes, 68)
                }
                return string(abi.encodePacked(_tracingInfo, string(_bytes)));
            } else {
                return
                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"));
            }
        } else {
            return
                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"));
        }
    }
}


// File: contracts/lib/GelatoCallUtils.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {GelatoBytes} from "./GelatoBytes.sol";

library GelatoCallUtils {
    using GelatoBytes for bytes;

    function revertingContractCall(
        address _contract,
        bytes memory _data,
        string memory _errorMsg
    ) internal returns (bytes memory returndata) {
        bool success;
        (success, returndata) = _contract.call(_data);

        // solhint-disable-next-line max-line-length
        // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L177
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(
                    isContract(_contract),
                    string(abi.encodePacked(_errorMsg, "Call to non contract"))
                );
            }
        } else {
            returndata.revertWithError(_errorMsg);
        }
    }

    // solhint-disable-next-line max-line-length
    // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L36
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }
}

