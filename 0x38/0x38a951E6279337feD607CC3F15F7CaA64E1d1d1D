
// File: idLink.sol
// SPDX-License-Identifier: Unknown
// Portions Subject to Copyright 
// Portions Patent Pending
// Contact support@idlinkchain.com for licensing information

pragma solidity 0.8.24;
pragma experimental ABIEncoderV2;

import "idLinkInterface.sol";
import "ERC721Custom.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import "Utility.sol";
import "SignatureVerify.sol";


contract idLinkChain is ERC721, AccessControl, idLinkInterface {

    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant NETWORK_ADMIN_ROLE = keccak256("NETWORK_ADMIN_ROLE");
    bytes32 public constant PARTNERSHIP_ADMIN_ROLE = keccak256("PARTNERSHIP_ADMIN_ROLE");
    bytes32 public constant TREASURER_ROLE = keccak256("TREASURER_ROLE");
    bytes32 public constant READING_CONTRACT = keccak256("READING_CONTRACT");
    bytes32 public constant BRIDGE_ROLE = keccak256("BRIDGE_ROLE");

    struct costStruct {
      uint128 mintCost;
      uint128 identityCost;
    }

    uint256 private _nextTokenId;  

    bytes32[] public _leadingStorage; 

    mapping (string => NetworkStruct) private _networks;
    string[] private _networkKeys;

    mapping(address => IdentitiesStruct[]) private _identities;

    mapping(string => address) private _identityToAddress;
    mapping(string => address[]) private _identityToAddresses;

    mapping(bytes32 => bytes32) private _avatar;
    mapping(bytes32 => bytes32) private _pgp;

    mapping(address => string) private _idBaseTag;
    mapping(string => address) private _tagToAddress;

    mapping(address => bool) private _authorizedVerifiersUniversal;
    mapping(address => NetworkVerifier) private _authorizedVerifiersNetwork;

    mapping(address => bool) private _authorizedWithdrawal;

    costStruct private _cost;
    
    mapping(IERC20 => costStruct) private _exchangeableTokens;

    bool _paused = false;

    event IdentityAdded(address indexed account, string identity, string network);
    event IdentityDeleted(address indexed account, string identity, string network);
    event IdBaseNameAdded(address indexed account, string name);
    event IdBaseNameDeleted(address indexed account, string name);

    error InsufficientFee(uint sent, uint required);
    error InvalidSignature();

    constructor(address defaultAdmin) ERC721("idLinkChain", "IDLINK") {
        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);
        _grantRole(MANAGER_ROLE, defaultAdmin);
        _grantRole(MINTER_ROLE, defaultAdmin);
        _grantRole(NETWORK_ADMIN_ROLE, defaultAdmin);
        _grantRole(PARTNERSHIP_ADMIN_ROLE, defaultAdmin);
        _grantRole(TREASURER_ROLE, defaultAdmin);

        // Set cost values
        _cost.mintCost =  1110000000000000 wei; //0.00111 ether;
        _cost.identityCost = 111000000000000 wei; //0.000111 ether;

        _authorizedVerifiersUniversal[0x37a34426d7d21C0037fB8Cfb78BfD3845bf47b7c] = true;

        // bafybei
        _leadingStorage.push(0x0170122000000000000000000000000000000000000000000000000000000000);
        // bafkrei
        _leadingStorage.push(0x0155122000000000000000000000000000000000000000000000000000000000);
        // bafyrei
        _leadingStorage.push(0x0171122000000000000000000000000000000000000000000000000000000000);

        /*
        struct NetworkStruct {
          string name;
          string defaultModifier;
          bool storeReverse;
          bool available;
          bool allowUniveral;
        }
        */
        _networks["x"] = NetworkStruct("X (Twitter)", "@", true, true, true);
        _networkKeys.push("x");

        _networks["dc"] = NetworkStruct("Discord", "@", true, true, true);
        _networkKeys.push("dc");

        _networks["tg"] = NetworkStruct("Telegram", "@", true, true, true);
        _networkKeys.push("tg");

        _networks["insta"] = NetworkStruct("Instagram", "@", true, true, true);
        _networkKeys.push("insta");

        _networks["in"] = NetworkStruct("LinkedIn", "@", true, true, true);
        _networkKeys.push("in");

        _networks["git"] = NetworkStruct("Github", "@", true, true, true);
        _networkKeys.push("git");

        _networks["tw"] = NetworkStruct("Twitch", "@", true, true, true);
        _networkKeys.push("tw");

        _networks["yt"] = NetworkStruct("YouTube", "@", true, true, true);
        _networkKeys.push("yt");

        _networks["tt"] = NetworkStruct("TikTok", "", true, true, true);
        _networkKeys.push("tt");

        _networks["sm"] = NetworkStruct("Signal", "", true, true, true);
        _networkKeys.push("sm");

        _networks["web"] = NetworkStruct("Website", "", true, true, true);
        _networkKeys.push("web");

        _networks["email"] = NetworkStruct("Email", "", true, true, true);
        _networkKeys.push("email");

        _networks["ph"] = NetworkStruct("Phone", "", true, true, true);
        _networkKeys.push("ph");

        _networks["sol"] = NetworkStruct("Solana", "", true, true, true);
        _networkKeys.push("sol");

        _networks["btc"] = NetworkStruct("Bitcoin", "", true, true, true);
        _networkKeys.push("btc");

        _networks["r"] = NetworkStruct("Residency", "", false, false, false);
        _networkKeys.push("r");

        _networks["c"] = NetworkStruct("Citizenship", "", false, false, false);
        _networkKeys.push("c");

        _grantRole(READING_CONTRACT, 0x01D01dEEa6C2620c4E93725937Ec088A1eAE2A6d);
    }

    modifier whenNotPaused {
      require(_paused == false);
      _;
    }

// INTERFACE ACCESS
    function _addressToToken(address lookup) public view onlyRole(READING_CONTRACT) returns (uint256) {
      return ERC721.addressToToken(lookup);
    }

    function _balanceOf(address lookup) public view onlyRole(READING_CONTRACT) returns (uint256) {
      return ERC721.balanceOf(lookup);
    }

    function _getAvatar(bytes32 lookup) public view onlyRole(READING_CONTRACT) returns (bytes32) {
      return _avatar[lookup];
    }

    function _getPgp(bytes32 lookup) public view onlyRole(READING_CONTRACT) returns (bytes32) {
      return _pgp[lookup];
    }

    function _getIdBaseTag(address lookup) public view onlyRole(READING_CONTRACT) returns (string memory) {
      return _idBaseTag[lookup];
    }

    function _getIdentities(address lookup) public view onlyRole(READING_CONTRACT) returns (IdentitiesStruct[] memory) {
      return _identities[lookup];
    }

    function _getIdentityToAddressMultiple(string calldata identity) public view onlyRole(READING_CONTRACT) returns (address, address[] memory) {
      return (_identityToAddress[identity], _identityToAddresses[identity]);
    } 

    function _getLeadingStorage() public view onlyRole(READING_CONTRACT) returns (bytes32[] memory) {
      return _leadingStorage;
    }

    function _getNetwork(string calldata abbreviation) public view onlyRole(READING_CONTRACT) returns (NetworkStruct memory) {
      return _networks[abbreviation];
    }

    function _getNetworkKeys() public view onlyRole(READING_CONTRACT) returns (string[] memory) {
      return _networkKeys;
    }

    function _getNetworkVerifier(address verifier) public view onlyRole(READING_CONTRACT) returns (NetworkVerifier memory) {
      return _authorizedVerifiersNetwork[verifier];
    }
    
    function _getTagToAddress(string calldata lookup) public view onlyRole(READING_CONTRACT) returns (address) {
      return _tagToAddress[lookup];
    }
    
// ADMINISTRATIVE FUNCTIONS
    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) {
        _paused = true;
    }

    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) {
      _paused = false;
    }

    function grantRole(bytes32 role, address account) override public {
      if (!(
        (role == MANAGER_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == MINTER_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == NETWORK_ADMIN_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == PARTNERSHIP_ADMIN_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == TREASURER_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == DEFAULT_ADMIN_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == READING_CONTRACT && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)))) {
          revert AccessControlBadConfirmation();
        }
      
      _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) override public {
      if (!(
        (role == MANAGER_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == MINTER_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == NETWORK_ADMIN_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == PARTNERSHIP_ADMIN_ROLE && hasRole(MANAGER_ROLE, msg.sender)) ||
        (role == TREASURER_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == READING_CONTRACT && hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) ||
        (role == DEFAULT_ADMIN_ROLE && hasRole(DEFAULT_ADMIN_ROLE, msg.sender) && msg.sender != account))) {
          revert AccessControlBadConfirmation();
        }
      
      _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public override {
      require(role != DEFAULT_ADMIN_ROLE, "Cannot revoke");
      super.renounceRole(role, account);
    }

     function setEthCost(uint128 mintCost, uint128 idCost) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _cost.mintCost = mintCost;
        _cost.identityCost = idCost;
    }

    function setExchangeableToken(IERC20 token, uint128 mintCost, uint128 identityCost) public onlyRole(DEFAULT_ADMIN_ROLE) {
       costStruct memory costs;
       costs.identityCost = identityCost;
       costs.mintCost = mintCost;
       _exchangeableTokens[token] = costs;
    }

    function removeExchangeableToken(IERC20 token) public onlyRole(DEFAULT_ADMIN_ROLE) {
       delete _exchangeableTokens[token];
    }

    function authorizedWithdrawalAddress(address receiver, bool allowed) public onlyRole(DEFAULT_ADMIN_ROLE) {
      _authorizedWithdrawal[receiver] = allowed;
    }

    function setBaseTokenURI(string memory uri) public onlyRole(DEFAULT_ADMIN_ROLE) {
        ERC721._baseURI = uri;
    }

    function addleadingStorage(bytes32 lead) public onlyRole(DEFAULT_ADMIN_ROLE) {
      _leadingStorage.push(lead);
    }
  
    function addNetwork(string calldata abbreviation, string calldata name, string calldata defaultModifier, bool storeReverse, bool allowUniveral) public onlyRole(NETWORK_ADMIN_ROLE) {
      require(bytes(_networks[abbreviation].name).length == 0, "Exists");
      _networks[abbreviation] = NetworkStruct(name, defaultModifier, storeReverse, true, allowUniveral);
      _networkKeys.push(abbreviation);
    }

    function updateNetwork(string calldata abbreviation, string calldata name, string calldata defaultModifier, bool storeReverse, bool available, bool allowUniversal) public onlyRole(NETWORK_ADMIN_ROLE) {
      require(bytes(_networks[abbreviation].name).length != 0, "Invalid");
      _networks[abbreviation] = NetworkStruct(name, defaultModifier, storeReverse, available, allowUniversal);
    }

    function addUniversalVerifier(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {
      _authorizedVerifiersUniversal[account] = true;
    }

    function removeUniversalVerifier(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {
      delete _authorizedVerifiersUniversal[account];
    }

    function addNetworkVerifier(address account, string calldata networkAbbreviation, string calldata name, string calldata contact, bool active) public onlyRole(PARTNERSHIP_ADMIN_ROLE) {
      _authorizedVerifiersNetwork[account] = NetworkVerifier(networkAbbreviation, name, contact, active);
    }

    function updateNetworkVerifier(address account, string calldata networkAbbreviation, string calldata name, string calldata contact, bool active) public onlyRole(PARTNERSHIP_ADMIN_ROLE) {
      _authorizedVerifiersNetwork[account] = NetworkVerifier(networkAbbreviation, name, contact, active);
    }

// INTERNAL FUNCTIONS
    function _safeMintInternal(address to, SaveIdentityStruct[] memory data, string calldata tag, address signer, bytes calldata signature, uint256 timestamp, bool crossChain) private returns (uint256 tokenId) {
      // Do not allow mint if the address already has a token
      require(ERC721.balanceOf(to) == 0, "Id exists");
      require(signer != address(0) || bytes(tag).length > 0, "No data");
      tokenId = ++_nextTokenId;
      _safeMint(to, tokenId);
      if (data.length > 0) {
        if (crossChain == false) {
          _checkSigning(to, data, signer, signature, timestamp);
        }
        _addIdentitiesInternal(to, data, signer);
      }
      if (bytes(tag).length > 0) {
        _updateTagInternal(to, tag);
      }
    }

    function _checkSigning(address account, SaveIdentityStruct[] memory dataArray, address signer, bytes calldata signature, uint256 timestamp) private view {
      if (signer != address(0)) {
          _checkSignature(account, dataArray, signer, signature, timestamp);
        } else {
          _checkSignatures(account, dataArray);
        }
    }

    function _checkSignature(address account, SaveIdentityStruct[] memory data, address signer, bytes calldata signature, uint256 timestamp) private view {
      if (!_authorizedVerifiersUniversal[signer]) {
          revert InvalidSignature();
      }
      if (!SignatureVerify.associateAddressWithSocialCredentials(
                            signer, 
                            account,                                             
                            signature,
                            timestamp,
                            data)) {
          revert InvalidSignature();
      }
    }

    function _checkSignatures(address account, SaveIdentityStruct[] memory data) private view {
      for (uint i = 0; i < data.length; i++) {
        SaveIdentityStruct memory currentData = data[i]; 
        if (keccak256(bytes(_authorizedVerifiersNetwork[currentData.signer].networkAbbreviation)) != keccak256(bytes(currentData.networkAbbreviation))) {
          revert InvalidSignature();
        }
        
        NetworkStruct memory thisNetwork = _networks[currentData.networkAbbreviation];
        if (thisNetwork.allowUniveral == false && keccak256(bytes(_authorizedVerifiersNetwork[currentData.signer].networkAbbreviation)) != keccak256(bytes(currentData.networkAbbreviation))) {
          revert InvalidSignature();
        }
        
        if (!SignatureVerify.associateAddressWithSocialCredential(currentData.signer, account, currentData.identity, currentData.lcaseIdentity, 
                    currentData.networkAbbreviation, currentData.timestamp, currentData.expires, currentData.signature)) {
                      revert InvalidSignature();
        }
      }
    }

    function _addIdentitiesInternal(address account, SaveIdentityStruct[] memory data, address signer) private {
      uint dataLength = data.length;
      for (uint i = 0; i < dataLength; i++) {
        SaveIdentityStruct memory currentData = data[i];
        bool obscured = currentData.obscured;
        string memory identity = currentData.identity;
        string memory networkAbbreviation = currentData.networkAbbreviation;
        string memory lcaseIdentity = currentData.lcaseIdentity;
        address thisSigner = signer == address(0) ? currentData.signer : signer;
        uint64 expires = currentData.expires;

        string memory newIdentityData = encodeNetwork(networkAbbreviation, identity, obscured);
        NetworkStruct memory thisNetwork = _networks[networkAbbreviation];
        require(thisNetwork.available == true, string(abi.encodePacked(thisNetwork.name, " unavailable")));
        
        _identities[account].push(IdentitiesStruct(thisSigner, expires, newIdentityData));

        if (!obscured && thisNetwork.storeReverse) {
          string memory lowercaseIdentityData = encodeNetwork(networkAbbreviation, lcaseIdentity, false);
          address storedAddress = _identityToAddress[lowercaseIdentityData];
          if (storedAddress == address(0)) {
              _identityToAddress[lowercaseIdentityData] = account;
          } else if (storedAddress != account) {
            address[] storage addresses = _identityToAddresses[lowercaseIdentityData];
            uint addressesLength = _identityToAddresses[lowercaseIdentityData].length;
            bool exists = false;
            for (uint j = 0; j < addressesLength; j++) {
                    if (addresses[j] == account) {
                        exists = true;
                        break;
                    }
                }
            if (!exists) {
                _identityToAddresses[lowercaseIdentityData].push(account);
            }
          }
        }
        emit IdentityAdded(account, data[i].identity,  data[i].networkAbbreviation); 
      }
    }

    function _removeIdentitiesInternal(address account, string[] memory removeArray) private {
      require(ERC721.balanceOf(account) != 0, "No id");

      uint identitiesLength = _identities[account].length;
      for (uint i = 0; i < removeArray.length; i++) {
        bytes32 remove = keccak256(bytes(removeArray[i]));
        for (uint j = 0; j < identitiesLength; j++) {
          if (keccak256(bytes(_identities[account][j].identityData)) == remove) {
            _identities[account][j] = _identities[account][_identities[account].length - 1];
            _identities[account].pop();
            identitiesLength--;
            break;
          }
        }
        // Remove the address from the identity data
        (string memory networkAbbreviation, string memory identity,, bool obscured) = decodeNetwork(removeArray[i]);
        if (!obscured && _networks[networkAbbreviation].storeReverse == true) {
          string memory lowercaseIdentity = encodeNetwork(networkAbbreviation, Utility._toLowercase(identity, false), false);
          address storedAddress = _identityToAddress[lowercaseIdentity];
          if (storedAddress == account) {
            uint addressesLength = _identityToAddresses[lowercaseIdentity].length;
            if (addressesLength > 0) {
              _identityToAddress[lowercaseIdentity] = _identityToAddresses[lowercaseIdentity][addressesLength - 1];
              _identityToAddresses[lowercaseIdentity].pop();
              if (addressesLength == 1) {
                delete _identityToAddresses[lowercaseIdentity];
              }
            } else {
              delete _identityToAddress[lowercaseIdentity];
            }
          } else {
            address[] storage addresses = _identityToAddresses[lowercaseIdentity];
            uint addressesLength = _identityToAddresses[lowercaseIdentity].length;
            for (uint j = 0; j < addressesLength; j++) {
              if (addresses[j] == account) {
                addresses[j] = addresses[addressesLength - 1];
                addresses.pop();
                if (addressesLength == 1) {
                  delete _identityToAddresses[lowercaseIdentity];
                } 
                break;
              }
            }
          }
        }
        emit IdentityDeleted(account, identity, networkAbbreviation);
      }
    }

    function _manageAvatarInternal(address account, bytes32 avatar, uint8 leadingPointer) private {
      require(ERC721.balanceOf(account) != 0, "No id");

      bytes32 addressBytes = bytes32(uint256(uint160(account))) << 96;

      // Perform delete operation
      for (uint i = 0; i < _leadingStorage.length; i++) {
          bytes32 lookupDelete = addressBytes | bytes32(i);
          if (_avatar[lookupDelete] != 0) {
            delete _avatar[lookupDelete];
          }
      }

      if (avatar != bytes32(0)) {
        bytes32 lookup = addressBytes | bytes32(uint256(leadingPointer));
        _avatar[lookup] = avatar;
      }
    }

    function _managePgpInternal(address account, bytes32 pgpIpfs, uint8 leadingPointer) private {
      require(ERC721.balanceOf(account) != 0, "No id");

      bytes32 addressBytes = bytes32(uint256(uint160(account))) << 96;

      // Perform delete operation
      for (uint i = 0; i < _leadingStorage.length; i++) {
          bytes32 lookupDelete = addressBytes | bytes32(i);
          if (_pgp[lookupDelete] != 0) {
            delete _pgp[lookupDelete];
          }
      }

      if (pgpIpfs != bytes32(0)) {
        bytes32 lookup = addressBytes | bytes32(uint256(leadingPointer));
        _pgp[lookup] = pgpIpfs;
      }
    }

    function _updateTagInternal(address account, string calldata tag) private {
      string memory lowercaseTag = Utility._toLowercase(tag, true);
      string memory currentTag = _idBaseTag[account];
      require(_tagToAddress[lowercaseTag] == address(0) || _tagToAddress[lowercaseTag] == account, "Name already exists");
      
      // If changing tags or clearing the tag, remove the old entry from the mapping
      if (bytes(currentTag).length != 0 && keccak256(bytes(currentTag)) != keccak256(bytes(tag))) {
          string memory lowercaseCurrentTag = Utility._toLowercase(currentTag, false);
          delete _tagToAddress[lowercaseCurrentTag];
          emit IdBaseNameDeleted(account, currentTag);
      }
      if (bytes(tag).length != 0) {
        _idBaseTag[account] = tag;
        _tagToAddress[lowercaseTag] = account;
        emit IdBaseNameAdded(account, tag);
      } 
      else {
        delete _idBaseTag[account];
      }
    }

    function encodeNetwork(string memory abbreviation, string memory identity, bool obscured) public view returns (string memory) {
      require(bytes(_networks[abbreviation].name).length != 0, "Network not available");
      if (obscured) {
        return string(abi.encodePacked("*", abbreviation, ":", identity));
      } else {
        return string(abi.encodePacked(abbreviation, ":", identity));
      }
    }

    function decodeNetwork(string memory encoded) public view returns (string memory abbreviation, string memory identity, string memory networkName, bool obscured) {
      string memory stringManipulate;
      if (keccak256(bytes(Utility._substring(encoded, 0, 1))) == keccak256(bytes("*"))) {
        stringManipulate = Utility._substring(encoded, 1, bytes(encoded).length);
        obscured = true;
      } else {
        stringManipulate = string(Utility.copyBytes(bytes(encoded)));
        obscured = false;
      }
      int colonPosition = Utility._findColon(stringManipulate);
      require(colonPosition != -1, "Invalid");

      // Extract abbreviation
      abbreviation = Utility._substring(stringManipulate, 0, uint(colonPosition));
      require(bytes(_networks[abbreviation].name).length != 0, "No network");
      networkName = _networks[abbreviation].name;
      
      // Extract identity
      identity = Utility._substring(stringManipulate, uint(colonPosition) + 1, bytes(stringManipulate).length);
      
      return (abbreviation, identity, networkName, obscured);
    }

    
// Public callable functions

    function getMintCost() public view returns (uint256) {
      return _cost.mintCost;
    }

    function getIdentityCost() public view returns (uint256) {
      return _cost.identityCost;
    }

    function getMintActionCost(uint length, string calldata tag) public view returns (uint256) {
      uint256 totalCost = _cost.mintCost + (length * _cost.identityCost);
      if (bytes(tag).length == 0) {
        totalCost -= _cost.identityCost;  
      }
      return totalCost;
    }

    function getIdentityActionCost(uint length, string calldata tag) public view returns (uint256) {
      uint256 totalCost = (length * _cost.identityCost);
      if (bytes(tag).length > 0) {
        totalCost += _cost.identityCost;  
      }
      return totalCost;
    }

    function getMintCostToken(IERC20 token) external view returns (uint256) {
      return uint256(_exchangeableTokens[token].mintCost);
    }

    function getIdentityCostToken(IERC20 token) external view returns (uint256) {
      return uint256(_exchangeableTokens[token].identityCost);
    }

// Functionality to add, remove, and update identity data limited to MINTER_ROLE
    function mintAdmin(address to, SaveIdentityStruct[] memory data, string calldata tag, address signer, bytes calldata signature, uint256 timestamp, bytes32 avatar, uint8 leadingPointer, bytes32 pgpIpfs, uint8 pgpLeadingPointer) public returns (uint256 tokenId) {
      bool crossChain = false;
      if (!hasRole(MINTER_ROLE, msg.sender)) {
        if (hasRole(BRIDGE_ROLE, msg.sender)) {
          crossChain = true;
        } else {
          revert InvalidSignature(); 
        }
      }
      tokenId = _safeMintInternal(to, data, tag, signer, signature, timestamp, crossChain);
      if (avatar != bytes32(0)) {
        _manageAvatarInternal(to, avatar, leadingPointer);
      }
      if (pgpIpfs != bytes32(0)) {
        _managePgpInternal(to, pgpIpfs, pgpLeadingPointer);
      }
    }   

    function addIdentitiesAdmin(address account, SaveIdentityStruct[] calldata data, address signer, bytes calldata signature, uint256 timestamp) public onlyRole(MINTER_ROLE) {
      require(ERC721.balanceOf(account) != 0, "No id");
      require(data.length > 0, "No data");
      _checkSignature(account, data, signer, signature, timestamp);
      _addIdentitiesInternal(account, data, signer);
    }

    function removeIdentitiesAdmin(address account, string[] calldata dataArray) public onlyRole(MINTER_ROLE) {
      _removeIdentitiesInternal(account, dataArray);
    }

    function updatePgpAdmin(address account, bytes32 pgpIpfs, uint8 leadingPointer) public onlyRole(MINTER_ROLE) {
      _managePgpInternal(account, pgpIpfs, leadingPointer);
    }

    function updateAvatarAdmin(address account, bytes32 avatar, uint8 leadingPointer) public onlyRole(MINTER_ROLE) {
      _manageAvatarInternal(account, avatar, leadingPointer);
    }

    function setIdBaseNameAdmin(address account, string calldata name) public onlyRole(MINTER_ROLE) {
      _updateTagInternal(account, name);
    }

// User callable functions
    function mint(SaveIdentityStruct[] calldata dataArray, string calldata tag, address signer, bytes calldata signature, uint256 timestamp) public payable whenNotPaused returns (uint256 tokenId) {
      uint256 totalCost = getMintActionCost(dataArray.length, tag);
      if (msg.value < totalCost) {
        revert InsufficientFee({sent: msg.value, required: totalCost});
      }
      tokenId = _safeMintInternal(msg.sender, dataArray, tag, signer, signature, timestamp, false);
      return tokenId;
    }

    function addIdentities(SaveIdentityStruct[] calldata dataArray, string calldata tag, address signer, bytes calldata signature, uint256 timestamp) public payable whenNotPaused {
      uint256 totalCost = getIdentityActionCost(dataArray.length, tag);
      if (msg.value < totalCost) {
        revert InsufficientFee({sent: msg.value, required: _cost.identityCost * dataArray.length});
      }
      if (dataArray.length > 0) { 
        _checkSigning(msg.sender, dataArray, signer, signature, timestamp);    
        _addIdentitiesInternal(msg.sender, dataArray, signer);
      }
      if (bytes(tag).length > 0) {
        _updateTagInternal(msg.sender, tag);
      }
    }

/*  
  To remove identities, an owner may call this function with an array of the identities
  to remove in the format of networkAbbreviation:identity for non-obscured identities and
  and *networkAbbreviation:obscuredIdentity for obscured identities.  You can also use the 
  encodeNetwork function to create this value.
*/
    function removeIdentities(string[] memory dataArray) public whenNotPaused {
      _removeIdentitiesInternal(msg.sender, dataArray);
    }

/*  
  To set an avatar for your idLink, call this function.  The helper function ipfsToBytes
  in the idLinkChainHelper contract will produce the values to call this function and
  set an avatar to an IPFS hash.  To delete an avatar, call with an empty bytes32 for
  avatar.
*/
    function updateAvatar(bytes32 avatar, uint8 leadingPointer) public payable whenNotPaused {
      if (msg.value < _cost.identityCost) {
        revert InsufficientFee({sent: msg.value, required: _cost.identityCost});
      }
      _manageAvatarInternal(msg.sender, avatar, leadingPointer);
    }


/*  
  To set a PGP/GPG public key for your idLink, call this function.  The helper function 
  ipfsToBytes in the idLinkChainHelper contract will produce the values to call this 
  function and set a PGP/GPG public key to an IPFS hash.  To delete a PGP/GPG key, call 
  with an empty bytes32 for pgpIpfs.
*/
    function updatePgp(bytes32 pgpIpfs, uint8 leadingPointer) public payable whenNotPaused {
      if (msg.value < _cost.identityCost) {
        revert InsufficientFee({sent: msg.value, required: _cost.identityCost});
      }
      _managePgpInternal(msg.sender, pgpIpfs, leadingPointer);
    }

/*
  Function to set your idLink name tag.  To delete your idLink name tag call with 
  an empty string.
*/
    function setIdLinkName(string calldata name) public payable whenNotPaused {
      if (bytes(name).length > 0 && msg.value < _cost.identityCost) {
        revert InsufficientFee({sent: msg.value, required: _cost.identityCost});
      }
      _updateTagInternal(msg.sender, name);
    }

/* 
  Function to completely delete all identities for an address.  Callable by owner.
*/
    function burn() public {
      uint256 tokenId = ERC721.addressToToken(msg.sender);
      string[] memory dataArray = new string[](_identities[msg.sender].length);
    
      for (uint i = 0; i < _identities[msg.sender].length; i++) {
        dataArray[i] = _identities[msg.sender][i].identityData;
      }

      _removeIdentitiesInternal(msg.sender, dataArray);
      _manageAvatarInternal(msg.sender, bytes32(0), 0);
      _managePgpInternal(msg.sender, bytes32(0), 0);
      if (bytes(_idBaseTag[msg.sender]).length != 0) {
        string memory lowercaseTag = Utility._toLowercase(_idBaseTag[msg.sender], false);
        delete _tagToAddress[lowercaseTag];
        delete _idBaseTag[msg.sender];
      }
      _update(address(0), tokenId, _msgSender());
      }

    // The following functions are overrides required by Solidity.
    
    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function withdraw(address payable recipient, uint256 amount) external onlyRole(TREASURER_ROLE) {
        if (_authorizedWithdrawal[recipient] != true) {
          revert AccessControlBadConfirmation();
        }
        recipient.transfer(amount);
    }

    function withdrawToken(address token, address recipient, uint256 amount) external onlyRole(TREASURER_ROLE) {
        if (_authorizedWithdrawal[recipient] != true) {
          revert AccessControlBadConfirmation();
        }
        IERC20(token).transfer(recipient, amount);
    }
}

// File: SignatureVerify.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.24;

// import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
// import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import "signature.sol";
import "idLinkInterface.sol";

library SignatureVerify {
    

    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
        }
    }

    function checkHash(bytes32 message, bytes memory signature, address signerAddress) internal pure returns (bool) {
        bytes32 messageHash = toEthSignedMessageHash(message);
        return Signature.signerMatches(messageHash, signature, signerAddress);
    }

    function associateAddressWithSocialCredentials(address signerAddress, 
                                                   address user,                                             
                                                   bytes memory signature,
                                                   uint256 timestamp,
                                                  idLinkInterface.SaveIdentityStruct[] memory identityData
                                                  ) internal pure returns (bool) {
        uint identityDataLength = identityData.length;
        bytes memory message = abi.encodePacked(user, timestamp);
        for (uint i = 0; i < identityDataLength; i++) {
            idLinkInterface.SaveIdentityStruct memory identity = identityData[i];
            message = abi.encodePacked(message, identity.identity, identity.lcaseIdentity, identity.networkAbbreviation, identity.expires);
        }
        return checkHash(keccak256(message), signature, signerAddress);
    }

    function associateAddressWithSocialCredential(address signerAddress, 
                                                   address user, 
                                                   string memory identity, 
                                                   string memory lcaseIdentity,
                                                   string memory networkAbbreviation, 
                                                   uint256 timestamp, 
                                                   uint64 expires,
                                                   bytes memory signature
                                                  ) internal pure returns (bool) {
        // Hash the message
        bytes32 message = keccak256(abi.encodePacked(user, identity, lcaseIdentity, networkAbbreviation, timestamp, expires));
        return checkHash(message, signature, signerAddress); 
    }

}

// File: Utility.sol
// SPDX-License-Identifier: UNKNOWN
// For licensing contact licensing@idba.se

pragma solidity 0.8.24;

library Utility {

    bytes16 private constant HEX_DIGITS = "0123456789abcdef";

    function _substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {
        bytes memory strBytes = bytes(str);
        bytes memory result = new bytes(endIndex - startIndex);
        for(uint i = startIndex; i < endIndex; i++) {
            result[i - startIndex] = strBytes[i];
        }
        return string(result);
    }

    function _findColon(string memory source) internal pure returns (int) {
        bytes memory sourceBytes = bytes(source);
        for (uint i = 0; i < sourceBytes.length; i++) {
            if (sourceBytes[i] == ':') {
                return int(i);
            }
        }
        return -1;  // Return -1 if no colon is found
    }

    function copyBytes(bytes memory _bytes) internal pure returns (bytes memory) {
        bytes memory copy = new bytes(_bytes.length);
        uint256 max = _bytes.length + 31;
        for (uint256 i=32; i<=max; i+=32)
        {
            assembly { mstore(add(copy, i), mload(add(_bytes, i))) }
        }
        return copy;
    }

    function _toLowercase(string memory inputNonModifiable, bool checkFlag) internal pure returns (string memory) {
        bytes memory bytesInput = copyBytes(bytes(inputNonModifiable));

        for (uint i = 0; i < bytesInput.length; i++) {
            uint8 char = uint8(bytesInput[i]);
            // checks for valid ascii characters // will allow unicode after building a string library
            if (checkFlag) {
                require(
                    (char > 47 && char < 58) || // '0'-'9'
                    (char > 64 && char < 91) || // 'A'-'Z'
                    (char > 96 && char < 123) || // 'a'-'z'
                    char == 95 || // '_'
                    char == 45 || // '-'
                    char == 46,  // '.'
                    "Invalid character in tag"
                );
            } else {
                require (char > 31 && char < 127, "Only ASCII characters");
            }
            // Uppercase character...
            if (char > 64 && char < 91) {
                // add 32 to make it lowercase
                bytesInput[i] = bytes1(char + 32);
            }
        }
        return string(bytesInput);
    }
/*
    function toString(address _addr) internal pure returns (string memory) {
        bytes32 value = bytes32(uint256(uint160(_addr)));
        bytes memory alphabet = "0123456789abcdef";
         
        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
         
        for (uint256 i = 0; i < 20; i++) {
            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
         
        return string(str);
    }
    */
    function toString(uint256 value) internal pure returns (string memory) {
        // If the value is 0, return "0" directly
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

}

// File: @openzeppelin/contracts/access/AccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)

pragma solidity ^0.8.20;

import {IAccessControl} from "./IAccessControl.sol";
import {Context} from "../utils/Context.sol";
import {ERC165} from "../utils/introspection/ERC165.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```solidity
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```solidity
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
 * to enforce additional security measures for this role.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address account => bool) hasRole;
        bytes32 adminRole;
    }

    mapping(bytes32 role => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with an {AccessControlUnauthorizedAccount} error including the required role.
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view virtual returns (bool) {
        return _roles[role].hasRole[account];
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
     * is missing `role`.
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert AccessControlUnauthorizedAccount(account, role);
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address callerConfirmation) public virtual {
        if (callerConfirmation != _msgSender()) {
            revert AccessControlBadConfirmation();
        }

        _revokeRole(role, callerConfirmation);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
        if (!hasRole(role, account)) {
            _roles[role].hasRole[account] = true;
            emit RoleGranted(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
        if (hasRole(role, account)) {
            _roles[role].hasRole[account] = false;
            emit RoleRevoked(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }
}


// File: ERC721Custom.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)

pragma solidity ^0.8.20;

import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {IERC721Metadata} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import {Context} from "@openzeppelin/contracts/utils/Context.sol";
import "Utility.sol";
import {IERC165, ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IERC721Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {
//    using Strings for uint256;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    string internal _baseURI = "";

    mapping(uint256 tokenId => address) private _owners;

    // CHANGE: Limited to one token per address, use _balances for token ID
    mapping(address owner => uint256) private _ownerToToken;

    mapping(uint256 tokenId => address) private _tokenApprovals;

    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view virtual returns (uint256) {
        if (owner == address(0)) {
            revert ERC721InvalidOwner(address(0));
        }
        if (_ownerToToken[owner] != 0) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view virtual returns (address) {
        return _requireOwned(tokenId);
    }

    function addressToToken(address check) public view returns (uint256) {
        return _ownerToToken[check];
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        _requireOwned(tokenId);

        return string.concat(_baseURI, Utility.toString(tokenId));
    }
    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
     /*
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }
    */
    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual {
        _approve(to, tokenId, _msgSender());
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view virtual returns (address) {
        _requireOwned(tokenId);

        return _getApproved(tokenId);
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(address from, address to, uint256 tokenId) public virtual {
        if (to == address(0)) {
            revert ERC721InvalidReceiver(address(0));
        }
        // Setting an "auth" arguments enables the `_isAuthorized` check which verifies that the token exists
        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.
        address previousOwner = _update(to, tokenId, _msgSender());
        if (previousOwner != from) {
            revert ERC721IncorrectOwner(from, tokenId, previousOwner);
        }
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {
        transferFrom(from, to, tokenId);
        _checkOnERC721Received(from, to, tokenId, data);
    }

    /**
     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
     *
     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the
     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances
     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by
     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.
     */
    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
        return _owners[tokenId];
    }

    /**
     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.
     */
    function _getApproved(uint256 tokenId) internal view virtual returns (address) {
        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in
     * particular (ignoring whether it is owned by `owner`).
     *
     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this
     * assumption.
     */
    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {
        return
            spender != address(0) &&
            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);
    }

    /**
     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.
     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets
     * the `spender` for the specific `tokenId`.
     *
     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this
     * assumption.
     */
    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {
        if (!_isAuthorized(owner, spender, tokenId)) {
            if (owner == address(0)) {
                revert ERC721NonexistentToken(tokenId);
            } else {
                revert ERC721InsufficientApproval(spender, tokenId);
            }
        }
    }

    /**
     * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
     *
     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that
     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.
     *
     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the
     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership
     * remain consistent with one another.
     */
     // REMOVED AS TOKEN OWNERSHIP LIMITED TO ONE TOKEN
    /*
    function _increaseBalance(address account, uint128 value) internal virtual {
        unchecked {
            _balances[account] += value;
        }
    }
    */

    /**
     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner
     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.
     *
     * The `auth` argument is optional. If the value passed is non 0, then this function will check that
     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).
     *
     * Emits a {Transfer} event.
     *
     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.
     */
    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {
        address from = _ownerOf(tokenId);

        require(
            from == address(0) || to == address(0),
            "Prohibited"
        );
        
        // Perform (optional) operator check
        if (auth != address(0)) {
            _checkAuthorized(from, auth, tokenId);
        }

        // Execute the update
        if (from != address(0)) {
            // Clear approval. No need to re-authorize or emit the Approval event
            _approve(address(0), tokenId, address(0), false);

            // CHANGE
            delete _ownerToToken[from];
            /*
            unchecked {
                _balances[from] -= 1;
            }
            */
        }

        if (to != address(0)) {
            // CHANGE
            _ownerToToken[to] = tokenId;
            /*
            unchecked {
                _balances[to] += 1;
            }
            */
        }

        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        return from;
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal {
        if (to == address(0)) {
            revert ERC721InvalidReceiver(address(0));
        }
        address previousOwner = _update(to, tokenId, address(0));
        if (previousOwner != address(0)) {
            revert ERC721InvalidSender(address(0));
        }
    }

    /**
     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
        _mint(to, tokenId);
        _checkOnERC721Received(address(0), to, tokenId, data);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     * This is an internal function that does not check if the sender is authorized to operate on the token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal {
        address previousOwner = _update(address(0), tokenId, address(0));
        if (previousOwner == address(0)) {
            revert ERC721NonexistentToken(tokenId);
        }
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address from, address to, uint256 tokenId) internal {
        if (to == address(0)) {
            revert ERC721InvalidReceiver(address(0));
        }
        address previousOwner = _update(to, tokenId, address(0));
        if (previousOwner == address(0)) {
            revert ERC721NonexistentToken(tokenId);
        } else if (previousOwner != from) {
            revert ERC721IncorrectOwner(from, tokenId, previousOwner);
        }
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients
     * are aware of the ERC721 standard to prevent tokens from being forever locked.
     *
     * `data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is like {safeTransferFrom} in the sense that it invokes
     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `tokenId` token must exist and be owned by `from`.
     * - `to` cannot be the zero address.
     * - `from` cannot be the zero address.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(address from, address to, uint256 tokenId) internal {
        _safeTransfer(from, to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
        _transfer(from, to, tokenId);
        _checkOnERC721Received(from, to, tokenId, data);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is
     * either the owner of the token, or approved to operate on all tokens held by this owner.
     *
     * Emits an {Approval} event.
     *
     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
     */
    function _approve(address to, uint256 tokenId, address auth) internal {
        _approve(to, tokenId, auth, true);
    }

    /**
     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not
     * emitted in the context of transfers.
     */
    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {
        // Avoid reading the owner unless necessary
        if (emitEvent || auth != address(0)) {
            address owner = _requireOwned(tokenId);

            // We do not use _isAuthorized because single-token approvals should not be able to call approve
            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {
                revert ERC721InvalidApprover(auth);
            }

            if (emitEvent) {
                emit Approval(owner, to, tokenId);
            }
        }

        _tokenApprovals[tokenId] = to;
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Requirements:
     * - operator can't be the address zero.
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
        if (operator == address(0)) {
            revert ERC721InvalidOperator(operator);
        }
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).
     * Returns the owner.
     *
     * Overrides to ownership logic should be done to {_ownerOf}.
     */
    function _requireOwned(uint256 tokenId) internal view returns (address) {
        address owner = _ownerOf(tokenId);
        if (owner == address(0)) {
            revert ERC721NonexistentToken(tokenId);
        }
        return owner;
    }

    /**
     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the
     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param data bytes optional data to send along with the call
     */

     
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
                if (retval != IERC721Receiver.onERC721Received.selector) {
                    revert ERC721InvalidReceiver(to);
                }
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert ERC721InvalidReceiver(to);
                } else {
                    /// @solidity memory-safe-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        }
    }
    
}


// File: idLinkInterface.sol
// SPDX-License-Identifier: Unknown
pragma solidity 0.8.24;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface idLinkInterface {
    struct IdentitiesStruct { 
      address signer;
      uint64 expires;
      string identityData;
    }

    struct NetworkStruct {
      string name;
      string defaultModifier;
      bool storeReverse;
      bool available;
      bool allowUniveral;
    }

    struct NetworkVerifier {
      string networkAbbreviation;
      string name;
      string contact;
      bool active;
    }

    struct SaveIdentityStruct {
      string networkAbbreviation;
      string identity;
      string lcaseIdentity;
      bool obscured;
      uint64 expires;
      bytes signature;
      address signer;
      uint256 timestamp;
    }

    function _addressToToken(address) external view returns (uint256);
    function _balanceOf(address) external view returns (uint256);
    function _getAvatar(bytes32) external view returns (bytes32);
    function _getPgp(bytes32) external view returns (bytes32);
    function _getIdBaseTag(address) external view returns (string memory);
    function _getIdentities(address) external view returns (IdentitiesStruct[] memory);
    function _getIdentityToAddressMultiple(string calldata identity) external view returns (address, address[] memory);
    function _getLeadingStorage() external view returns (bytes32[] memory); 
    function _getNetwork(string calldata) external view returns (NetworkStruct memory);
    function _getNetworkKeys() external view returns (string[] memory);
    function _getNetworkVerifier(address verifier) external view returns (NetworkVerifier memory);
    function _getTagToAddress(string calldata) external view returns (address);

    function decodeNetwork(string memory encoded) external view returns (string memory abbreviation, string memory identity, string memory networkName, bool obscured);
    function encodeNetwork(string memory abbreviation, string memory identity, bool obscured) external view returns (string memory);

    function getMintCostToken(IERC20 token) external view returns (uint256);
    function getIdentityCostToken(IERC20 token) external view returns (uint256);
    
    function mintAdmin(address to, SaveIdentityStruct[] memory data, string calldata tag, address signer, bytes calldata signature, uint256 timestamp, bytes32 avatar, uint8 leadingPointer, bytes32 pgpIpfs, uint8 pgpLeadingPointer) external returns (uint256 tokenId);
    function addIdentitiesAdmin(address account, SaveIdentityStruct[] calldata data, address signer, bytes calldata signature, uint256 timestamp) external;
    function updateAvatarAdmin(address account, bytes32 avatar, uint8 leadingPointer) external;
    function setIdBaseNameAdmin(address account, string calldata name) external;

}


// File: signature.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.24;

library Signature {

    function signerMatches(bytes32 _ethSignedMessageHash,
        bytes memory _signature, address signer) internal pure returns (bool) {
            address signed = recoverSigner(_ethSignedMessageHash, _signature);
            return (signed == signer);
        }

    function recoverSigner(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) internal pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(bytes memory sig)
        internal
        pure
        returns (bytes32 r, bytes32 s, uint8 v)
    {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
            First 32 bytes stores the length of the signature

            add(sig, 32) = pointer of sig + 32
            effectively, skips first 32 bytes of signature

            mload(p) loads next 32 bytes starting at the memory address p into memory
            */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        // implicitly return (r, s, v)
    }

}

// File: @openzeppelin/contracts/interfaces/draft-IERC6093.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
pragma solidity ^0.8.20;

/**
 * @dev Standard ERC20 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
 */
interface IERC20Errors {
    /**
     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);

    /**
     * @dev Indicates a failure with the token `sender`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC20InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token `receiver`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC20InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     * @param allowance Amount of tokens a `spender` is allowed to operate with.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);

    /**
     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC20InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC20InvalidSpender(address spender);
}

/**
 * @dev Standard ERC721 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
 */
interface IERC721Errors {
    /**
     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
     * Used in balance queries.
     * @param owner Address of the current owner of a token.
     */
    error ERC721InvalidOwner(address owner);

    /**
     * @dev Indicates a `tokenId` whose `owner` is the zero address.
     * @param tokenId Identifier number of a token.
     */
    error ERC721NonexistentToken(uint256 tokenId);

    /**
     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param tokenId Identifier number of a token.
     * @param owner Address of the current owner of a token.
     */
    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);

    /**
     * @dev Indicates a failure with the token `sender`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC721InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token `receiver`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC721InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param tokenId Identifier number of a token.
     */
    error ERC721InsufficientApproval(address operator, uint256 tokenId);

    /**
     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC721InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC721InvalidOperator(address operator);
}

/**
 * @dev Standard ERC1155 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 */
interface IERC1155Errors {
    /**
     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     * @param tokenId Identifier number of a token.
     */
    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);

    /**
     * @dev Indicates a failure with the token `sender`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC1155InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token `receiver`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC1155InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param owner Address of the current owner of a token.
     */
    error ERC1155MissingApprovalForAll(address operator, address owner);

    /**
     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC1155InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC1155InvalidOperator(address operator);

    /**
     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
     * Used in batch transfers.
     * @param idsLength Length of the array of token identifiers
     * @param valuesLength Length of the array of token amounts
     */
    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)

pragma solidity ^0.8.20;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

pragma solidity ^0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    function _contextSuffixLength() internal view virtual returns (uint256) {
        return 0;
    }
}


// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.20;

import {IERC721} from "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.20;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be
     * reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or
     *   {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the address zero.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: @openzeppelin/contracts/access/IAccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)

pragma solidity ^0.8.20;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev The `account` is missing a role.
     */
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);

    /**
     * @dev The caller of a function is not the expected one.
     *
     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
     */
    error AccessControlBadConfirmation();

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     */
    function renounceRole(bytes32 role, address callerConfirmation) external;
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

