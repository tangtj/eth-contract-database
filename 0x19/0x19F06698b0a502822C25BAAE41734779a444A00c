
// File: contracts/RequestHandling.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;
import "./ApproveRequest.sol";

/// @title Vountain – RequestHandling
/// @notice Managing different requests

contract RequestHandling is ApproveRequest {
  constructor(address configurationContract, address connectContract)
    ApproveRequest(configurationContract, connectContract)
  {}

  event ExecutedRequest(
    uint256 indexed violinId_,
    address indexed sender,
    uint256 requestId
  );

  /// @dev managing the states which the violin can have
  /// @param affectedRole available roles OWNER_ROLE, VOUNTAIN, INSTRUMENT_MANAGER_ROLE, MUSICIAN_ROLE, VIOLIN_MAKER_ROLE
  /// @param metadata passing the instanciated ViolineMetadata
  /// @param violinId_ id of the violin
  /// @param targetAccount_ receiver account
  function setViolinState(
    RCLib.Role affectedRole,
    IViolineMetadata metadata,
    uint256 violinId_,
    address targetAccount_
  ) internal {
    if ((affectedRole) == (RCLib.Role.MUSICIAN_ROLE)) {
      metadata.setTokenArtist(violinId_, targetAccount_);
    } else if ((affectedRole == RCLib.Role.INSTRUMENT_MANAGER_ROLE)) {
      metadata.setTokenManager(violinId_, targetAccount_);
    } else if ((affectedRole == (RCLib.Role.VIOLIN_MAKER_ROLE))) {
      metadata.setTokenViolinMaker(violinId_, targetAccount_);
    } else if ((affectedRole == (RCLib.Role.EXHIBITOR_ROLE))) {
      metadata.setExhibitor(violinId_, targetAccount_);
    } else if ((affectedRole == (RCLib.Role.OWNER_ROLE))) {
      metadata.setTokenOwner(violinId_, targetAccount_);
    }
  }

  /// @dev executing the request from requestByViolinId mapping (RequestCreation.sol)
  /// @param violinId_ id of the violin
  function executeRequest(uint256 violinId_, uint256 requestId_) external {
    // Inherited Contracts
    IAccessControl accessControl = getAccessControlContractInterface(violinId_);
    IViolines violin = IViolines(connectContract.violinAddress());
    IViolineMetadata violinMetadata = getViolinMetadata(violinId_);

    // requestByViolinId is created in RequestCreation.sol
    RCLib.Request storage request = requestByViolinIdAndRequestId[violinId_][requestId_];
    require(request.canBeApproved, "there is nothing to execute!"); //wenn der request auf executed steht, dann gibt es nichts zu approven...
    require(request.approvalCount >= request.approvalsNeeded, "you need more approvals!"); //wenn noch nicht genug approvals existieren, dann kann nicht approved werden
    require(request.requestValidUntil > block.timestamp, "request expired.");

    requestChecks(violinId_, request.targetAccount, request.approvalType);

    request.canBeApproved = false;
    request.requestValidUntil = block.timestamp;
    delete (approvedAddresses[violinId_][requestId_]);

    RCLib.TaskCluster currentTask = configurationContract.checkTasks(
      request.approvalType
    );

    if (RCLib.TaskCluster.MINTING == currentTask) {
      violin.mintViolin(request.violinId, request.mintTarget);
      violinMetadata.setViolinLocation(request.violinId, request.targetAccount);
    }
    if (
      request.approvalType == RCLib.Tasks.CHANGE_METADATA_VIOLIN ||
      RCLib.TaskCluster.MINTING == currentTask
    ) {
      violinMetadata.changeMetadata(
        request.newMetadata.name,
        request.newMetadata.description,
        request.newMetadata.longDescription,
        request.newMetadata.image,
        request.newMetadata.media,
        request.newMetadata.model3d,
        request.newMetadata.attributeNames,
        request.newMetadata.attributeValues,
        request.violinId
      );
    }

    if (request.approvalType == RCLib.Tasks.CHANGE_METADATA_ACCESSCONTROL) {
      accessControl.changeMetadata(
        request.violinId,
        request.newMetadata.description,
        request.newMetadata.image
      );
    }

    if (
      RCLib.TaskCluster.CREATION ==
      configurationContract.checkTasks(request.approvalType) ||
      RCLib.TaskCluster.MINTING == currentTask
    ) {
      require(
        !accessControl.checkIfAddressHasAccess(
          request.targetAccount,
          request.affectedRole,
          request.violinId
        ),
        "you already have that role!"
      );

      string memory metadataImage = request.newMetadata.image;

      // Check if optionalOwnerImage is not empty
      if (
        bytes(request.newMetadata.optionalOwnerImage).length > 0 &&
        RCLib.TaskCluster.MINTING == currentTask
      ) {
        metadataImage = request.newMetadata.optionalOwnerImage;
      }

      accessControl.mintRole(
        request.targetAccount,
        request.affectedRole,
        request.contractValidUntil,
        violinId_,
        metadataImage,
        request.newMetadata.description
      );

      setViolinState(
        request.affectedRole,
        violinMetadata,
        violinId_,
        request.targetAccount
      );
    } else if (
      RCLib.TaskCluster.CHANGE_DURATION == currentTask
    ) //Change the validity in AccessControl Contract
    {
      accessControl.setTimestamp(
        request.violinId,
        request.contractValidUntil,
        request.targetAccount,
        request.affectedRole
      );
    } else if (RCLib.TaskCluster.DELISTING == currentTask) {
      accessControl.burnTokens(
        request.targetAccount,
        request.affectedRole,
        request.violinId
      );

      setViolinState(request.affectedRole, violinMetadata, violinId_, address(0));
    } else if (RCLib.TaskCluster.DELEGATING == currentTask) {
      violinMetadata.setViolinLocation(violinId_, request.targetAccount);
    } else if (RCLib.TaskCluster.EVENTS == currentTask) {
      violinMetadata.createNewEvent(
        request.requestId,
        request.newEvent.name,
        request.newEvent.description,
        request.newEvent.role,
        request.newEvent.attendee,
        request.newEvent.eventStartTimestamp,
        request.newEvent.eventEndTimestamp,
        request.newEvent.link,
        request.newEvent.geolocation,
        request.newEvent.file,
        request.approvalType,
        request.violinId
      );
    } else if (RCLib.TaskCluster.DOCUMENTS == currentTask) {
      violinMetadata.createNewDocument(
        request.requestId,
        request.newDocument.docType,
        request.newDocument.date,
        request.newDocument.cid,
        request.newDocument.title,
        request.newDocument.description,
        request.newDocument.source,
        request.newDocument.value,
        request.newDocument.valueOriginalCurrency,
        request.newDocument.originalCurrency,
        request.violinId
      );
    }

    emit ExecutedRequest(violinId_, msg.sender, request.requestId);
  }
}


// File: contracts/ApproveRequest.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;
import "@openzeppelin/contracts/access/Ownable.sol";
import "./RequestCreation.sol";

/// @title Vountain – ApproveRequest
/// @notice Contract for the approval of requests.

contract ApproveRequest is RequestCreation {
  constructor(address configurationContract, address connectContract)
    RequestCreation(configurationContract, connectContract)
  {}

  event ApprovedRequest(
    uint256 indexed violinId_,
    address indexed sender,
    uint256 indexed requestId
  );

  /// @dev Function [approveRequest]
  /// Function reads the request in storage, because it has to modify the request count.
  /// Several checks are performed to check if the approver is elligible.
  /// @param violinId_ a violin id for which the request should be approved
  function approveRequest(uint256 violinId_, uint256 requestId_) external {
    RCLib.Request storage request = requestByViolinIdAndRequestId[violinId_][requestId_];

    require(request.canBeApproved, "there is nothing to approve!");
    require(request.requestValidUntil > block.timestamp, "request expired.");

    bool alreadyApproved = false;
    for (uint256 i = 0; i < approvedAddresses[violinId_][requestId_].length; i++) {
      if (msg.sender == approvedAddresses[violinId_][requestId_][i]) {
        alreadyApproved = true;
        break;
      }
    }
    require(!alreadyApproved, "you already approved!");

    require(
      checkRole(
        request.approvalType,
        violinId_,
        RCLib.PROCESS_TYPE.IS_APPROVE_PROCESS,
        request.targetAccount,
        request.requesterRole
      ),
      "sorry you have insufficient rights to approve!"
    );

    request.approvalCount = request.approvalCount + 1;
    approvedAddresses[violinId_][requestId_].push(msg.sender);
    request.approvedAddresses = approvedAddresses[violinId_][requestId_];
    emit ApprovedRequest(violinId_, msg.sender, request.requestId);
  }
}


// File: contracts/RequestCreation.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./CheckRights.sol";
import "./TypeLibrary.sol";

/// @title Vountain – RequestCreation
/// @notice For different purposes different requests can be created.
///         The request types differ in the fields filled, but not in the structure.

contract RequestCreation is CheckRights {
  mapping(uint256 => mapping(uint256 => address[])) internal approvedAddresses;
  mapping(uint256 => mapping(uint256 => RCLib.Request))
    internal requestByViolinIdAndRequestId;
  uint256 public requestId;
  uint256 public mintCounter;

  event NewRequestCreated(
    uint256 indexed violinId_,
    address indexed sender,
    uint256 indexed requestId
  );

  constructor(address configurationContract, address connectContract)
    CheckRights(configurationContract, connectContract)
  {}

  function getRoleForTask(RCLib.Tasks task) internal pure returns (RCLib.Role) {
    if (task == RCLib.Tasks.DELEGATE_INSTRUMENT_MANAGER_ROLE) {
      return RCLib.Role.INSTRUMENT_MANAGER_ROLE;
    } else if (task == RCLib.Tasks.DELEGATE_MUSICIAN_ROLE) {
      return RCLib.Role.MUSICIAN_ROLE;
    } else if (task == RCLib.Tasks.DELEGATE_EXHIBITOR_ROLE) {
      return RCLib.Role.EXHIBITOR_ROLE;
    } else if (task == RCLib.Tasks.DELEGATE_VIOLIN_MAKER_ROLE) {
      return RCLib.Role.VIOLIN_MAKER_ROLE;
    } else if (task == RCLib.Tasks.DELEGATE_OWNER_ROLE) {
      return RCLib.Role.OWNER_ROLE;
    } else {
      revert("Invalid task");
    }
  }

  function requestChecks(
    uint256 violinId_,
    address targetAccount_,
    RCLib.Tasks requestType_
  ) internal view {
    address metadataContract = connectContract.getMetadataContract(violinId_);
    IViolineMetadata metadata = IViolineMetadata(metadataContract);

    IAccessControl accessControl = getAccessControlContractInterface(violinId_);
    RCLib.TaskCluster taskCluster = configurationContract.checkTasks(requestType_);

    if (
      RCLib.TaskCluster.DELISTING == taskCluster &&
      metadata.readLocation(violinId_) == targetAccount_
    ) {
      revert("Can't delist active location");
    }

    if (RCLib.TaskCluster.DELEGATING == taskCluster) {
      RCLib.Role targetCheck = getRoleForTask(requestType_);

      if (targetAccount_ == metadata.readLocation(violinId_)) {
        revert("Can't delegate to yourself");
      }

      if (
        !accessControl.checkIfAddressHasAccess(targetAccount_, targetCheck, violinId_)
      ) {
        revert("Can't delegate to wrong address");
      }
    }
  }

  /// @dev create new request
  /// @param violinId_ ID of violin
  /// @param contractValidUntil_ date for the ending of the contract
  /// @param targetAccount_ Affected Target Account
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  function createNewRequest(
    uint256 violinId_,
    uint256 contractValidUntil_,
    address targetAccount_,
    RCLib.Tasks requestType_,
    RCLib.Role requesterRole_
  ) public {
    RCLib.TaskCluster taskCluster = configurationContract.checkTasks(requestType_);

    require(
      RCLib.TaskCluster.CHANGE_DURATION == taskCluster ||
        RCLib.TaskCluster.DELISTING == taskCluster ||
        RCLib.TaskCluster.DELEGATING == taskCluster,
      "wrong request type"
    );

    if (RCLib.TaskCluster.DELEGATING == taskCluster) {
      if (targetAccount_ == msg.sender) revert("Can't delegate to yourself");
    }

    requestChecks(violinId_, targetAccount_, requestType_);

    createRequest(
      violinId_,
      contractValidUntil_,
      targetAccount_,
      requestType_,
      requesterRole_
    );
  }

  /// @dev create new request
  /// @param violinId_ ID of violin
  /// @param contractValidUntil_ date for the ending of the contract
  /// @param targetAccount_ Affected Target Account
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  function createRequest(
    uint256 violinId_,
    uint256 contractValidUntil_,
    address targetAccount_,
    RCLib.Tasks requestType_,
    RCLib.Role requesterRole_
  ) internal returns (uint256) {
    require(
      checkRole(
        requestType_,
        violinId_,
        RCLib.PROCESS_TYPE.IS_CREATE_PROCESS,
        targetAccount_,
        requesterRole_
      ),
      "you have the wrong role..."
    );

    requestId = requestId + 1;

    requestByViolinIdAndRequestId[violinId_][requestId].requestId = requestId;
    requestByViolinIdAndRequestId[violinId_][requestId].violinId = violinId_;
    requestByViolinIdAndRequestId[violinId_][requestId].approvalType = requestType_;
    requestByViolinIdAndRequestId[violinId_][requestId].creator = msg.sender;
    requestByViolinIdAndRequestId[violinId_][requestId].targetAccount = targetAccount_;
    requestByViolinIdAndRequestId[violinId_][requestId].mintTarget = targetAccount_;
    requestByViolinIdAndRequestId[violinId_][requestId].canBeApproved = true;
    requestByViolinIdAndRequestId[violinId_][requestId]
      .affectedRole = configurationContract
      .returnRoleConfig(violinId_, requestType_)
      .affectedRole;
    requestByViolinIdAndRequestId[violinId_][requestId].canApprove = configurationContract
      .returnRoleConfig(violinId_, requestType_)
      .canApprove;
    requestByViolinIdAndRequestId[violinId_][requestId]
      .approvalsNeeded = configurationContract
      .returnRoleConfig(violinId_, requestType_)
      .approvalsNeeded;
    requestByViolinIdAndRequestId[violinId_][requestId].approvalCount = 0;
    requestByViolinIdAndRequestId[violinId_][requestId].requestValidUntil =
      block.timestamp +
      (configurationContract.returnRoleConfig(violinId_, requestType_).validity *
        1 hours);
    requestByViolinIdAndRequestId[violinId_][requestId]
      .contractValidUntil = contractValidUntil_;
    requestByViolinIdAndRequestId[violinId_][requestId].requesterRole = requesterRole_;
    delete (approvedAddresses[violinId_][requestId]);

    emit NewRequestCreated(violinId_, msg.sender, requestId);
    return requestId;
  }

  /// @dev create new request
  /// @param violinId_ ID of violin
  /// @param requestValidUntil_ check valdity of contract with date
  /// @param targetAccount_ Affected Target Account
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  /// @param mintTarget_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  /// @param metadata_ request metadata (specified in TypeLibrary.sol)
  ///                  string name;
  ///                  string description;
  ///                  string longdescription;
  ///                  string image;
  ///                  string model3d;
  ///                  string[] attributes;
  ///                  string[] metadataValues;
  function createNewMintOrRoleRequest(
    uint256 violinId_,
    uint256 requestValidUntil_,
    address targetAccount_,
    RCLib.Tasks requestType_,
    address mintTarget_,
    RCLib.Metadata memory metadata_,
    RCLib.Role requesterRole_
  ) public {
    IAccessControl accessControl = getAccessControlContractInterface(violinId_);
    RCLib.RequestConfig memory config = configurationContract.returnRoleConfig(
      violinId_,
      requestType_
    );

    require(
      RCLib.TaskCluster.CREATION == configurationContract.checkTasks(requestType_) ||
        RCLib.TaskCluster.MINTING == configurationContract.checkTasks(requestType_),
      "only for new roles"
    );

    require(
      metadata_.attributeNames.length == metadata_.attributeValues.length,
      "attributes length differ"
    );
    if (
      RCLib.TaskCluster.MINTING == configurationContract.checkTasks(requestType_) &&
      mintTarget_ == address(0)
    ) {
      revert("target is null address");
    }

    require(
      !accessControl.roleAlreadyActive(violinId_, config.affectedRole),
      "role already active"
    );

    if (RCLib.TaskCluster.MINTING == configurationContract.checkTasks(requestType_)) {
      requestValidUntil_ = 32472144000;
      mintCounter += 1;
      violinId_ = mintCounter;
    }

    uint256 createdRequestId = createRequest(
      violinId_,
      requestValidUntil_,
      targetAccount_,
      requestType_,
      requesterRole_
    );
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .name = metadata_.name;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .description = metadata_.description;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .longDescription = metadata_.longDescription;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .image = metadata_.image;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .optionalOwnerImage = metadata_.optionalOwnerImage;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .media = metadata_.media;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .model3d = metadata_.model3d;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .attributeNames = metadata_.attributeNames;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .attributeValues = metadata_.attributeValues;
    requestByViolinIdAndRequestId[violinId_][createdRequestId].mintTarget = mintTarget_;
  }

  /// @param violinId_ ID of violin
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  /// @param metadata_ request metadata (specified in TypeLibrary.sol)
  ///                  string name;
  ///                  string description;
  ///                  string longdescription;
  ///                  string image;
  ///                  string model3d;
  ///                  string[] attributes;
  ///                  string[] metadataValues;
  function createMetadataRequest(
    uint256 violinId_,
    RCLib.Tasks requestType_,
    RCLib.Metadata memory metadata_,
    RCLib.Role requesterRole_
  ) public {
    require(
      RCLib.TaskCluster.METADATA == configurationContract.checkTasks(requestType_),
      "only for changing metadata."
    );
    require(
      metadata_.attributeNames.length == metadata_.attributeValues.length,
      "attributes length differ"
    );
    uint256 createdRequestId = createRequest(
      violinId_,
      0,
      msg.sender,
      requestType_,
      requesterRole_
    );
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .name = metadata_.name;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .description = metadata_.description;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .longDescription = metadata_.longDescription;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .image = metadata_.image;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .media = metadata_.media;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .model3d = metadata_.model3d;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .attributeNames = metadata_.attributeNames;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newMetadata
      .attributeValues = metadata_.attributeValues;
  }

  /// @param violinId_ ID of violin
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  /// @param name_ name of the event
  /// @param description_ description of the event
  /// @param eventStartTimestamp_ when did the event happen
  /// @param eventStartTimestamp_ how long did it last
  function createNewEventRequest(
    uint256 violinId_,
    RCLib.Tasks requestType_,
    string memory name_,
    string memory description_,
    uint256 eventStartTimestamp_,
    uint256 eventEndTimestamp_,
    string memory link,
    string memory geolocation,
    string[] memory file,
    RCLib.Role requesterRole_
  ) public {
    require(
      RCLib.TaskCluster.EVENTS == configurationContract.checkTasks(requestType_),
      "only for adding events."
    );

    require(
      eventEndTimestamp_ == 0 || eventStartTimestamp_ <= eventEndTimestamp_,
      "wrong dates submitted"
    );

    if (requestType_ == RCLib.Tasks.ADD_REPAIR) {
      require(eventStartTimestamp_ <= block.timestamp, "only date in past allowed");
    }

    uint256 createdRequestId = createRequest(
      violinId_,
      eventStartTimestamp_,
      msg.sender,
      requestType_,
      requesterRole_
    ); //request will be created

    requestByViolinIdAndRequestId[violinId_][createdRequestId].newEvent.name = name_;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newEvent
      .description = description_;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newEvent
      .role = configurationContract
      .returnRoleConfig(violinId_, requestType_)
      .affectedRole;
    requestByViolinIdAndRequestId[violinId_][createdRequestId].newEvent.attendee = msg
      .sender;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newEvent
      .eventStartTimestamp = eventStartTimestamp_;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newEvent
      .eventEndTimestamp = eventEndTimestamp_;
    requestByViolinIdAndRequestId[violinId_][createdRequestId].newEvent.link = link;
    requestByViolinIdAndRequestId[violinId_][createdRequestId]
      .newEvent
      .geolocation = geolocation;
    requestByViolinIdAndRequestId[violinId_][createdRequestId].newEvent.file = file;
  }

  /// @param violinId_ ID of violin
  /// @param requestType_ specify a type e.g CREATE_MANAGER
  ///                     see Configuration.sol Contract for Details of roles
  /// @param eventStartTimestamp_ timestamp of the event
  /// @param document the document object
  function createNewDocumentRequest(
    uint256 violinId_,
    RCLib.Tasks requestType_,
    RCLib.Role requesterRole_,
    uint256 eventStartTimestamp_,
    RCLib.Documents memory document
  ) public {
    require(
      RCLib.TaskCluster.DOCUMENTS == configurationContract.checkTasks(requestType_),
      "only for adding documents."
    );
    require(document.date < int256(block.timestamp), "only date in past allowed");

    uint256 createdRequestId = createRequest(
      violinId_,
      eventStartTimestamp_,
      msg.sender,
      requestType_,
      requesterRole_
    ); //request will be created

    {
      requestByViolinIdAndRequestId[violinId_][createdRequestId].newDocument = document;
    }
  }

  function returnRequestByViolinIdAndRequestId(uint256 violinId_, uint256 request_)
    public
    view
    returns (RCLib.Request memory)
  {
    return (requestByViolinIdAndRequestId[violinId_][request_]);
  }
}


// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: contracts/CheckRights.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./ConnectContract.sol";

/// @title Vountain – CheckRights
/// @notice Contract for checking the rights for the request and approval logic.
///         Reads the config and applies the rules.

contract CheckRights is Ownable {
  IConfigurationContract configurationContract;
  IConnectContract connectContract;

  constructor(address configurationContract_, address connectContract_) {
    configurationContract = IConfigurationContract(configurationContract_);
    connectContract = IConnectContract(connectContract_);
  }

  function getAccessControlContractInterface(uint256 violinId_)
    internal
    view
    returns (IAccessControl)
  {
    address accessControlContract = connectContract.getAccessControlContract(violinId_);
    IAccessControl accessControl = IAccessControl(accessControlContract);
    return accessControl;
  }

  function getViolinMetadata(uint256 violinId_) internal view returns (IViolineMetadata) {
    IViolineMetadata violinMetadata = IViolineMetadata(
      connectContract.getMetadataContract(violinId_)
    );
    return violinMetadata;
  }

  function checkRole(
    RCLib.Tasks requestType_,
    uint256 violinId_,
    RCLib.PROCESS_TYPE approve,
    address targetAccount,
    RCLib.Role requesterRole_
  ) public view returns (bool) {
    IAccessControl accessControl = getAccessControlContractInterface(violinId_);
    IViolineMetadata violinMetadata = getViolinMetadata(violinId_);
    IViolines violin = IViolines(connectContract.violinAddress());

    RCLib.Role[] memory _role;

    if (approve == RCLib.PROCESS_TYPE.IS_APPROVE_PROCESS) {
      _role = configurationContract.returnRoleConfig(violinId_, requestType_).canApprove;

      if (
        RCLib.TaskCluster.CREATION == configurationContract.checkTasks(requestType_) ||
        RCLib.TaskCluster.MINTING == configurationContract.checkTasks(requestType_)
      ) {
        return (msg.sender == targetAccount);
      }
    } else {
      _role = configurationContract.returnRoleConfig(violinId_, requestType_).canInitiate;

      if (
        RCLib.TaskCluster.DELEGATING == configurationContract.checkTasks(requestType_)
      ) {
        return (msg.sender == violinMetadata.readLocation(violinId_));
      }
    }

    for (uint256 i = 0; i < _role.length; i++) {
      if (approve == RCLib.PROCESS_TYPE.IS_APPROVE_PROCESS && _role[i] == requesterRole_)
        continue;
      if (approve != RCLib.PROCESS_TYPE.IS_APPROVE_PROCESS && _role[i] != requesterRole_)
        continue;

      if (_role[i] == RCLib.Role.CUSTODIAL && violin.ownerOf(violinId_) == msg.sender)
        return true;
      if (_role[i] == RCLib.Role.VOUNTAIN && msg.sender == owner()) return true;
      if (accessControl.checkIfAddressHasAccess(msg.sender, _role[i], violinId_))
        return true;
    }
    return false;
  }
}


// File: contracts/TypeLibrary.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

abstract contract IConnectContract {
  function getContractsForVersion(uint256 violinID_)
    public
    view
    virtual
    returns (RCLib.ContractCombination memory cc);

  function violinAddress() public view virtual returns (address violinAddress);

  function getControllerContract(uint256 violinID_)
    public
    view
    virtual
    returns (address controllerContract);

  function getMoveRoleContract(uint256 violinID_)
    public
    view
    virtual
    returns (address moveRoleContract);

  function getAccessControlContract(uint256 violinID_)
    public
    view
    virtual
    returns (address accessControlContract);

  function getMetadataContract(uint256 violinID_)
    public
    view
    virtual
    returns (address metadataContract);

  function versionIsActive(uint256 version) external view virtual returns (bool);
}

abstract contract IConfigurationContract {
  function getConfigForVersion(uint256 version_)
    public
    view
    virtual
    returns (RCLib.RequestConfig[] memory);

  function checkTasks(RCLib.Tasks task_)
    public
    pure
    virtual
    returns (RCLib.TaskCluster cluster);

  function returnRoleConfig(uint256 version_, RCLib.Tasks configId_)
    public
    view
    virtual
    returns (RCLib.RequestConfig memory);

  function violinToVersion(uint256 tokenId) external view virtual returns (uint256);
}

abstract contract IViolines {
  function mintViolin(uint256 tokenId_, address addr_) external virtual;

  function ownerOf(uint256 tokenId) public view virtual returns (address);

  function balanceOf(address owner) public view virtual returns (uint256);
}

abstract contract IViolineMetadata {
  struct EventType {
    string name;
    string description;
    string role;
    address attendee;
    uint256 eventTimestamp;
  }

  function createNewDocument(
    uint256 requestId_,
    string memory docType_,
    int256 date_,
    string memory cid_,
    string memory title_,
    string memory description_,
    string memory source_,
    uint256 value_,
    uint256 value_original_currency_,
    string memory currency_,
    uint256 tokenID_
  ) external virtual;

  function changeMetadata(
    string memory name_,
    string memory description_,
    string memory longDescription_,
    string memory image_,
    string[] memory media_,
    string[] memory model3d_,
    string[] memory attributeNames_,
    string[] memory attributeValues_,
    uint256 tokenId_
  ) external virtual;

  function readManager(uint256 tokenID_) public view virtual returns (address);

  function readLocation(uint256 tokenID_) public view virtual returns (address);

  function setTokenManager(uint256 tokenID_, address manager_) external virtual;

  function setTokenArtist(uint256 tokenID_, address artist_) external virtual;

  function setTokenOwner(uint256 tokenID_, address owner_) external virtual;

  function setExhibitor(uint256 tokenID_, address exhibitor_) external virtual;

  function setTokenViolinMaker(uint256 tokenID_, address violinMaker_) external virtual;

  function setViolinLocation(uint256 tokenID_, address violinLocation_) external virtual;

  function createNewEvent(
    uint256 requestId_,
    string memory name_,
    string memory description_,
    RCLib.Role role_,
    address attendee_,
    uint256 eventStartTimestamp_,
    uint256 eventEndTimestamp_,
    string memory link,
    string memory geolocation,
    string[] memory file,
    RCLib.Tasks eventType_,
    uint256 tokenID_
  ) external virtual;
}

abstract contract IAccessControl {
  function mintRole(
    address assignee_,
    RCLib.Role role_,
    uint256 contractValidUntil_,
    uint256 violinID_,
    string memory image,
    string memory description
  ) external virtual;

  function roleAlreadyActive(uint256 violinId_, RCLib.Role role_)
    public
    virtual
    returns (bool);

  function changeMetadata(
    uint256 tokenId_,
    string memory description_,
    string memory image_
  ) public virtual;

  function checkIfAddressHasAccess(
    address addr_,
    RCLib.Role role_,
    uint256 violinID_
  ) public view virtual returns (bool);

  function setTimestamp(
    uint256 violinID_,
    uint256 timestamp_,
    address targetAccount_,
    RCLib.Role role_
  ) external virtual;

  function burnTokens(
    address targetAccount,
    RCLib.Role affectedRole,
    uint256 violinId
  ) external virtual;

  function administrativeCleanup(uint256 violinId) external virtual;

  function returnCorrespondingTokenID(
    address addr_,
    RCLib.Role role_,
    uint256 violinID_
  ) public view virtual returns (uint256);

  function administrativeMove(
    address from,
    address to,
    uint256 violinId,
    uint256 tokenId
  ) public virtual;
}

library RCLib {
  enum Role {
    OWNER_ROLE, //0
    VOUNTAIN, //1
    INSTRUMENT_MANAGER_ROLE, //2
    MUSICIAN_ROLE, //3
    VIOLIN_MAKER_ROLE, //4
    CUSTODIAL, //5
    EXHIBITOR_ROLE //6
  }

  enum TaskCluster {
    CREATION,
    CHANGE_DURATION,
    DELISTING,
    DELEGATING,
    EVENTS,
    DOCUMENTS,
    METADATA,
    MINTING
  }

  enum Tasks {
    CREATE_INSTRUMENT_MANAGER_ROLE, // 0
    CREATE_MUSICIAN_ROLE, // 1
    CREATE_VIOLIN_MAKER_ROLE, // 2
    CREATE_OWNER_ROLE, // 3
    CREATE_EXHIBITOR_ROLE, // 4
    CHANGE_DURATION_MUSICIAN_ROLE, // 4
    CHANGE_DURATION_INSTRUMENT_MANAGER_ROLE, // 6
    CHANGE_DURATION_VIOLIN_MAKER_ROLE, // 7
    CHANGE_DURATION_OWNER_ROLE, // 8
    CHANGE_DURATION_EXHIBITOR_ROLE, // 9
    DELIST_INSTRUMENT_MANAGER_ROLE, // 10
    DELIST_MUSICIAN_ROLE, // 11
    DELIST_VIOLIN_MAKER_ROLE, // 12
    DELIST_OWNER_ROLE, // 13
    DELIST_EXHIBITOR_ROLE, // 14
    DELEGATE_INSTRUMENT_MANAGER_ROLE, // 15
    DELEGATE_MUSICIAN_ROLE, // 16
    DELEGATE_VIOLIN_MAKER_ROLE, // 17
    DELEGATE_EXHIBITOR_ROLE, // 18
    DELEGATE_OWNER_ROLE, // 19
    ADD_CONCERT, // 20
    ADD_EXHIBITION, // 21
    ADD_REPAIR, // 22
    ADD_DOCUMENT, // 23
    MINT_NEW_VIOLIN, // 24
    CHANGE_METADATA_VIOLIN, // 25
    CHANGE_METADATA_ACCESSCONTROL // 26
  }

  struct TokenAttributes {
    address owner;
    address manager;
    address artist;
    address violinMaker;
    address violinLocation;
    address exhibitor;
    RCLib.CreatedEvent[] concert;
    RCLib.CreatedEvent[] exhibition;
    RCLib.CreatedEvent[] repair;
    RCLib.CreatedDocument[] document;
    RCLib.Metadata metadata;
  }

  struct RequestConfig {
    uint256 approvalsNeeded; //Amount of Approver
    RCLib.Role affectedRole; //z.B. MUSICIAN_ROLE
    RCLib.Role[] canApprove;
    RCLib.Role[] canInitiate;
    uint256 validity; //has to be in hours!!!
  }

  struct RoleNames {
    Role role;
    string[] names;
  }

  enum PROCESS_TYPE {
    IS_APPROVE_PROCESS,
    IS_CREATE_PROCESS
  }

  struct Request {
    uint256 requestId;
    uint256 violinId;
    uint256 contractValidUntil; //Timestamp
    address creator; //Initiator
    address targetAccount; //Get Role
    bool canBeApproved; //Is it already approved
    RCLib.Role affectedRole; //Role in AccessControl Contract
    Role[] canApprove; //Rollen, who can approve
    RCLib.Tasks approvalType; //e.g. CREATE_INSTRUMENT_MANAGER_ROLE
    uint256 approvalsNeeded; //Amount of approval needed
    uint256 approvalCount; //current approvals
    uint256 requestValidUntil; //how long is the request valid?
    address mintTarget; //optional for minting
    address[] approvedAddresses; //approvers
    RCLib.Event newEvent;
    RCLib.Documents newDocument;
    RCLib.Metadata newMetadata;
    RCLib.Role requesterRole;
  }

  struct AccessToken {
    string image;
    RCLib.Role role;
    uint256 violinID;
    uint256 contractValidUntil;
    string name;
    string description;
  }

  struct Event {
    string name;
    string description;
    RCLib.Role role;
    address attendee;
    uint256 eventStartTimestamp;
    uint256 eventEndTimestamp;
    string link;
    string geolocation;
    string[] file;
  }

  struct CreatedEvent {
    string name;
    string description;
    RCLib.Role role;
    address attendee;
    uint256 eventStartTimestamp;
    uint256 eventEndTimestamp;
    string link;
    string geolocation;
    string[] file;
    uint256 requestId;
  }

  struct Documents {
    string docType;
    int256 date;
    string cid;
    string title;
    string description;
    string source;
    uint256 value;
    uint256 valueOriginalCurrency;
    string originalCurrency;
  }

  struct CreatedDocument {
    string docType;
    int256 date;
    string cid;
    string title;
    string description;
    string source;
    uint256 value;
    uint256 valueOriginalCurrency;
    string originalCurrency;
    uint256 requestId;
  }

  struct Metadata {
    string name;
    string description;
    string longDescription;
    string image;
    string optionalOwnerImage;
    string[] media;
    string[] model3d;
    string[] attributeNames;
    string[] attributeValues;
  }

  struct ContractCombination {
    address controllerContract;
    address accessControlContract;
    address metadataContract;
    address moveRoleContract;
  }

  struct LatestMintableVersion {
    uint256 versionNumber;
    address controllerContract;
  }
}


// File: contracts/ConnectContract.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;
import "@openzeppelin/contracts/access/Ownable.sol";
import "./TypeLibrary.sol";

/// @title Vountain – ConnectContract
/// @notice Connecting violin, metadata, access controls and

contract ConnectContract is Ownable {
  address public violinAddress;

  mapping(uint256 => RCLib.ContractCombination) public versionToContractCombination;
  mapping(uint256 => uint256) public violinToContractVersion;
  mapping(uint256 => bool) public versionIsActive;
  mapping(uint256 => bool) public freezeConfigVersion;

  RCLib.LatestMintableVersion public latest;

  constructor() {}

  /**
   * @dev after deployment the ConnectContract and the violin contract are tied together forever
   * @param violinAddress_ the address of the violin contract
   */
  function setViolinAddress(address violinAddress_) public onlyOwner {
    //once and forever
    require(violinAddress == address(0), "already initialized");
    violinAddress = violinAddress_;
  }

  /**
   * @dev Vountain can add a contract combination for the application. Itś not possible to change a contract combination once the version was set to active
   * @param id_ the version of the contract combination
   * @param controllerContract_  the request handling logic contract
   * @param accessControlContract_  the role token contract
   * @param metadataContract_  the metadata contract
   */
  function setContractConfig(
    uint256 id_,
    address controllerContract_,
    address accessControlContract_,
    address metadataContract_,
    address moveRoleContract_
  ) public onlyOwner {
    require(!freezeConfigVersion[id_], "don't change active versions");
    versionToContractCombination[id_].controllerContract = controllerContract_;
    versionToContractCombination[id_].accessControlContract = accessControlContract_;
    versionToContractCombination[id_].metadataContract = metadataContract_;
    versionToContractCombination[id_].moveRoleContract = moveRoleContract_;
  }

  /**
   * @dev Vountain can set a version to active. All contracts has to be initialized.
   * @dev The version is frozen and can not be changed later
   * @dev The latest version is set if the config has a higher number than the last latest version
   * @param version_ the version to set active
   */
  function setVersionActive(uint256 version_) public onlyOwner {
    RCLib.ContractCombination memory contracts = versionToContractCombination[version_];

    require(
      contracts.controllerContract != address(0) &&
        contracts.accessControlContract != address(0) &&
        contracts.metadataContract != address(0) &&
        contracts.moveRoleContract != address(0),
      "initialize contracts first"
    );
    versionIsActive[version_] = true;
    freezeConfigVersion[version_] = true;
    if (version_ >= latest.versionNumber) {
      latest.versionNumber = version_;
      latest.controllerContract = versionToContractCombination[version_]
        .controllerContract;
    }
  }

  /**
   * @dev function to set a version inactive
   * @param version_ the version to set inactive
   */
  function setVersionInactive(uint256 version_) public onlyOwner {
    versionIsActive[version_] = false;
  }

  /**
   * @dev an owner of the violin can set a version to active.
   * @dev it is not possible to choose an inactive version
   * @dev a downgrade is not possible
   * @param violinID_ the violin to change the combination
   * @param version_ the version to activate
   */
  function setViolinToContractVersion(uint256 violinID_, uint256 version_) public {
    IAccessControl accessControl = IAccessControl(getAccessControlContract(violinID_));
    require(
      accessControl.checkIfAddressHasAccess(
        msg.sender,
        RCLib.Role.OWNER_ROLE,
        violinID_
      ) || msg.sender == violinAddress,
      "account is not the owner"
    );
    require(versionIsActive[version_], "version not active");
    require(version_ >= violinToContractVersion[violinID_], "no downgrade possible");
    violinToContractVersion[violinID_] = version_;
  }

  /**
   * @dev returns the contract combination for a version
   * @param violinID_ the violin to check
   */
  function getContractsForVersion(uint256 violinID_)
    public
    view
    returns (RCLib.ContractCombination memory cc)
  {
    return versionToContractCombination[violinToContractVersion[violinID_]];
  }

  /**
   * @dev returns the controller contract for the violin
   * @param violinID_ the violin to check
   */
  function getControllerContract(uint256 violinID_)
    public
    view
    returns (address controllerContract)
  {
    RCLib.ContractCombination memory contracts = getContractsForVersion(violinID_);
    return contracts.controllerContract;
  }

  /**
   * @dev returns the moveRole contract for the violin
   * @param violinID_ the violin to check
   */
  function getMoveRoleContract(uint256 violinID_)
    public
    view
    returns (address moveRoleContract)
  {
    RCLib.ContractCombination memory contracts = getContractsForVersion(violinID_);
    return contracts.moveRoleContract;
  }

  /**
   * @dev returns the access control contract for the violin
   * @param violinID_ the violin to check
   */
  function getAccessControlContract(uint256 violinID_)
    public
    view
    returns (address accessControlContract)
  {
    RCLib.ContractCombination memory contracts = getContractsForVersion(violinID_);
    return contracts.accessControlContract;
  }

  /**
   * @dev returns the metadata contract for the violin
   * @param violinID_ the violin to check
   */
  function getMetadataContract(uint256 violinID_)
    public
    view
    returns (address metadataContract)
  {
    RCLib.ContractCombination memory contracts = getContractsForVersion(violinID_);
    return contracts.metadataContract;
  }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

