
// File: src/EnsAuctions.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

//                     ░▒▓████████▓▒░▒▓███████▓▒░ ░▒▓███████▓▒░
//                     ░▒▓█▓▒░      ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒░       
//                     ░▒▓█▓▒░      ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒░       
//                     ░▒▓██████▓▒░ ░▒▓█▓▒  ▒▓█▓▒  ▒▓██████▓▒░ 
//                     ░▒▓█▓▒░      ░▒▓█▓▒  ▒▓█▓▒░      ░▒▓█▓▒░
//                     ░▒▓█▓▒░      ░▒▓█▓▒  ▒▓█▓▒░      ░▒▓█▓▒░
//                     ░▒▓████████▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓███████▓▒  
//
//                        ___________
//                        \         /
//                         )_______(
//                         |"""""""|_.-._,.---------.,_.-._
//                         |       | | |               | | ''-.
//                         |       |_| |_             _| |_..-'
//                         |_______| '-' `'---------'` '-'
//                         )"""""""(
//                        /_________\
//                        `'-------'`
//                      .-------------.
//                     /_______________\
//    
//   ░▒▓██████▓▒  ▒▓█▓▒  ▒▓█▓▒  ▒▓██████▓▒░▒▓████████▓▒░▒▓█▓▒  ▒▓██████▓▒  ▒▓███████▓▒░  
//  ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ 
//  ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ 
//  ░▒▓████████▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ 
//  ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ 
//  ░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░▒▓█▓▒  ▒▓█▓▒░ 
//  ░▒▓█▓▒  ▒▓█▓▒  ▒▓██████▓▒░ ░▒▓██████▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒  ▒▓██████▓▒  ▒▓█▓▒  ▒▓█▓▒░ 
//  v1.2                                                             https://ens.auction

import "solady/src/auth/Ownable.sol";
import "./IEnsAuctions.sol";
import "./IFeeCalculator.sol";
import "./IBaseRegistrar.sol";
import "./INameWrapper.sol";

contract EnsAuctions is IEnsAuctions, Ownable {
    enum Status {
        Active,
        BuyNow,
        Claimed,
        Unclaimable,
        Abandoned
    }

    struct Seller {
        uint24 totalAuctions;
        uint24 totalSold;
        uint24 totalUnclaimable;
        uint24 totalBidderAbandoned;
    }

    struct Token {
        uint256 tokenId;
        bool isWrapped;
    }

    struct Auction {
        Status status;
        uint64 startTime;
        uint64 endTime;
        address seller;
        address highestBidder;
        uint256 highestBid;
        uint256 startingPrice;
        uint256 buyNowPrice;
        uint256 tokenCount;
        mapping(uint256 => Token) tokens;
    }

    IFeeCalculator public feeCalculator;
    IBaseRegistrar public immutable ensRegistrar;
    INameWrapper   public immutable ensNameWrapper;
    
    address public feeRecipient;
    uint256 public nextAuctionId = 1;
    uint256 public minStartingPrice = 0.01 ether;
    uint256 public minBuyNowPrice = 0.05 ether;
    uint256 public minBidIncrement = 0.01 ether;
    uint256 public settlementDuration = 7 days;
    uint256 public antiSnipeDuration = 15 minutes;
    uint256 public maxTokens = 20;
    uint256 public eventStartDay = 5;
    uint256 public eventStartTime = 16 hours;
    uint256 public eventEndDay = 1;
    uint256 public eventEndTime = 0 hours;
    
    mapping(address => Seller) public sellers;
    mapping(address => uint256) public balances;
    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => bool) public tokenOnAuction;

    constructor(
        address registrar_,
        address nameWrapper_,
        address feeCalculator_,
        address feeRecipient_
    ) {
        _initializeOwner(msg.sender);
        feeRecipient = feeRecipient_;
        feeCalculator = IFeeCalculator(feeCalculator_);
        ensRegistrar = IBaseRegistrar(registrar_);
        ensNameWrapper = INameWrapper(nameWrapper_);
    }

    /**
     *
     * EXTERNAL FUNCTIONS
     *
     */

    /**
     * startAuction - Starts an auction for one or more ENS tokens
     *
     * @param startingPrice - The starting price for the auction
     * @param buyNowPrice - The buy now price for the auction
     * @param tokenIds - The token ids to auction
     * @param wrapped - Whether the tokens are wrapped
     * @param useDiscount - Whether to check for discounts
     *
     * Note: due to extra gas costs when checking token ownership or balances, we let 
     * the frontend check for discounts offchain and decide whether to check for discounts or not.
     */

    function startAuction(
        uint256 startingPrice,
        uint256 buyNowPrice,
        uint256[] calldata tokenIds,
        bool[] calldata wrapped,
        bool useDiscount
    ) external payable {
        uint256 tokenCount = tokenIds.length;

        if (calculateFee(msg.sender, useDiscount) != msg.value) revert InvalidFee();
        if (tokenCount > maxTokens) revert MaxTokensPerTxReached();
        if (startingPrice < minStartingPrice) revert StartPriceTooLow();
        if (buyNowPrice < minBuyNowPrice || buyNowPrice <= startingPrice) revert BuyNowTooLow();
        if (tokenCount == 0 || tokenCount != wrapped.length) revert InvalidLengthOfTokenIds();

        uint64 _eventStartTime = getNextEventStartTime();
        uint64 _eventEndTime = getNextEventEndTime();

        _validateTokens(tokenIds, wrapped, _eventEndTime);

        Auction storage auction = auctions[nextAuctionId];
        auction.seller = msg.sender;
        auction.tokenCount = tokenCount;
        auction.buyNowPrice = buyNowPrice;
        auction.startTime = _eventStartTime;
        auction.endTime = _eventEndTime;
        auction.startingPrice = startingPrice;

        for (uint256 i; i < tokenCount; ++i) {
            auction.tokens[i] = Token(tokenIds[i], wrapped[i]);
        }

        emit Started(
            nextAuctionId,
            msg.sender,
            startingPrice,
            buyNowPrice,
            auction.startTime,
            auction.endTime,
            tokenCount
        );

        unchecked {
            ++nextAuctionId;
            ++sellers[msg.sender].totalAuctions;
        }

        (bool success, ) = payable(feeRecipient).call{value: msg.value}("");
        if (!success) revert TransferFailed();
    }

    /**
     *
     * bid - Places a bid on an auction
     *
     * @param auctionId - The id of the auction to bid on
     *
     */
    function bid(uint256 auctionId, uint256 bidAmount) external payable {
        Auction storage auction = auctions[auctionId];
        uint256 minimumBid;

        if (auction.status != Status.Active) revert InvalidStatus();
        if (block.timestamp < auction.startTime) revert AuctionBuyNowPeriod();
        if (block.timestamp > auction.endTime) revert AuctionEnded();
        if (msg.sender == auction.seller) revert SellerCannotBid();

        if (block.timestamp >= auction.endTime - antiSnipeDuration) {
            auction.endTime += uint64(antiSnipeDuration);
        }

        if (auction.highestBid == 0) {
            minimumBid = auction.startingPrice;
        } else {
            unchecked {
                minimumBid = auction.highestBid + minBidIncrement;
            }
        }

        if (bidAmount < minimumBid) revert BidTooLow();

        _processPayment(bidAmount);

        address prevHighestBidder = auction.highestBidder;
        uint256 prevHighestBid = auction.highestBid;

        auction.highestBidder = msg.sender;
        auction.highestBid = bidAmount;

        if (prevHighestBidder != address(0)) {
            unchecked {
                balances[prevHighestBidder] += prevHighestBid;
            }
        }

        emit Bid(auctionId, msg.sender, bidAmount);
    }

    /**
     *
     * buyNow - Buy now phase occurs *before* auction bidding begins
     *
     * @param auctionId - The id of the auction to buy
     *
     */
    function buyNow(uint256 auctionId) external payable {
        Auction storage auction = auctions[auctionId];

        if (auction.status != Status.Active) revert InvalidStatus();
        if (block.timestamp > auction.startTime) revert BuyNowUnavailable();
        if (msg.sender == auction.seller) revert SellerCannotBid();

        _processPayment(auction.buyNowPrice);
        
        auction.status = Status.BuyNow;
        auction.highestBidder = msg.sender;
        auction.highestBid = auction.buyNowPrice;

        unchecked {
            balances[auction.seller] += auction.buyNowPrice;
            ++sellers[auction.seller].totalSold;
        }

        emit BuyNow(auctionId, msg.sender, auction.buyNowPrice);

        _transferTokens(auction);
    }

    /**
     *
     * claim - Claims the tokens from an auction
     *
     * @param auctionId - The id of the auction to claim
     *
     */
    function claim(uint256 auctionId) external {
        Auction storage auction = auctions[auctionId];

        if (auction.status != Status.Active) revert InvalidStatus();
        if (block.timestamp < auction.endTime) revert AuctionNotEnded();
        if (auction.highestBidder == address(0)) revert AuctionHasNoBids();
        
        auction.status = Status.Claimed;

        unchecked {
            balances[auction.seller] += auction.highestBid;
            ++sellers[auction.seller].totalSold;
        }

        emit Claimed(auctionId, auction.highestBidder);

        _transferTokens(auction);
    }

    /**
     *
     * abandon - Mark unclaimed auctions as abandoned after the settlement period
     *
     * @param auctionId - The id of the auction to mark abandoned
     *
     */
    function markAbandoned(uint256 auctionId) external {
        Auction storage auction = auctions[auctionId];

        if (auction.status != Status.Active) revert InvalidStatus();
        if (msg.sender != auction.seller) revert NotAuthorized();
        if (block.timestamp < auction.endTime + settlementDuration) revert SettlementPeriodNotExpired();
        if (auction.highestBidder == address(0)) revert AuctionHasNoBids();

        auction.status = Status.Abandoned;

        unchecked {
            balances[auction.highestBidder] += auction.highestBid;
            ++sellers[auction.seller].totalBidderAbandoned;
        }

        _resetTokens(auction);

        emit Abandoned(auctionId);
    }

    /**
     *
     * abandon - Buyer can mark auction unclaimable during the settlement period
     *
     * @param auctionId - The id of the auction to abandon
     *
     */
    function markUnclaimable(uint256 auctionId) external {
        Auction storage auction = auctions[auctionId];
        
        if (auction.status != Status.Active) revert InvalidStatus();
        if (block.timestamp > auction.endTime + settlementDuration) revert SettlementPeriodEnded();
        if (msg.sender != auction.highestBidder) revert NotHighestBidder();
        if (_isClaimable(auction)) revert AuctionIsClaimable();

        auction.status = Status.Unclaimable;

        unchecked {
            balances[auction.highestBidder] += auction.highestBid;
            ++sellers[auction.seller].totalUnclaimable;
        }
        
        _resetTokens(auction);

        emit Unclaimable(auctionId);
    }

    /**
     *
     * withdrawBalance - Withdraws your complete balance from the contract
     *
     */
    function withdrawBalance() external {
        uint256 balance = balances[msg.sender];

        balances[msg.sender] = 0;

        emit Withdrawn(msg.sender, balance);

        (bool success, ) = payable(msg.sender).call{value: balance}("");
        if (!success) revert TransferFailed();
    }

    /**
     *
     * PUBLIC VIEWS
     *
     */

    /**
     *
     * calculateFee - Calculates the auction fee based on seller history
     *
     * @param sellerAddress - Address of seller
     * @param useDiscount - Whether to check for discounts
     *
     * Dynamic fees are designed to encourage sellers to:
     *
     *  a) use Starting Price / Buy Now prices that reflect market conditions
     *  b) list high quality names
     *  c) prevent listing spam
     *  d) make sure all auctions remain claimable
     * 
     */
    function calculateFee(address sellerAddress, bool useDiscount) public view returns (uint256) {
        Seller storage seller = sellers[sellerAddress];

        return feeCalculator.calculateFee(
            _getActiveAuctionCount(),
            sellerAddress,
            seller.totalAuctions,
            seller.totalSold,
            seller.totalUnclaimable,
            seller.totalBidderAbandoned,
            useDiscount
        );
    }

    /**
     * getAuctionTokens - Get the token ids of an auction
     *
     * @param auctionId - The id of the auction
     *
     */
    function getAuctionTokens(uint256 auctionId) external view returns (uint256[] memory) {
        Auction storage auction = auctions[auctionId];

        uint256[] memory tokenIds = new uint256[](auction.tokenCount);

        uint256 tokenCount = auction.tokenCount;

        for (uint256 i; i < tokenCount; ++i) {
            tokenIds[i] = auction.tokens[i].tokenId;
        }

        return tokenIds;
    }

    function getNextEventStartTime() public view returns (uint64) {
        return _getEventTime(eventStartDay, eventStartTime);
    }

    function getNextEventEndTime() public view returns (uint64) {
        uint64 startTime = _getEventTime(eventStartDay, eventStartTime);
        uint64 endTime = _getEventTime(eventEndDay, eventEndTime);

        if (startTime >= endTime) {
            endTime += 7 days;
        }

        return endTime;
    }

    function _getEventTime(uint256 dayOfWeek, uint256 time) internal view returns (uint64) {
        uint256 daysUntilNextEvent;
        uint256 nextEventTime;

        unchecked {
            daysUntilNextEvent = (7 + dayOfWeek - (block.timestamp / 1 days + 4) % 7) % 7;
            nextEventTime = (block.timestamp / 1 days + daysUntilNextEvent) * 1 days + time;

            if (daysUntilNextEvent == 0 && block.timestamp % 1 days > time) {
                nextEventTime += 7 days;
            }
        }

        return uint64(nextEventTime);
    }

    /**
     *
     * SETTERS
     *
     */

    function setFeeCalculator(address feeCalculator_) external onlyOwner {
        feeCalculator = IFeeCalculator(feeCalculator_);
        emit FeeCalculatorUpdated(feeCalculator_);
    }

    function setFeeRecipient(address feeRecipient_) external onlyOwner {
        feeRecipient = feeRecipient_;
        emit FeeRecipientUpdated(feeRecipient_);
    }

    function setMaxTokens(uint256 maxTokens_) external onlyOwner {
        maxTokens = maxTokens_;
        emit MaxTokensUpdated(maxTokens_);
    }

    function setMinBuyNowPrice(uint256 minBuyNowPrice_) external onlyOwner {
        minBuyNowPrice = minBuyNowPrice_;
        emit MinBuyNowPriceUpdated(minBuyNowPrice_);
    }

    function setMinStartingBid(uint256 minStartingPrice_) external onlyOwner {
        minStartingPrice = minStartingPrice_;
        emit MinStartingBidUpdated(minStartingPrice_);
    }

    function setMinBidIncrement(uint256 minBidIncrement_) external onlyOwner {
        minBidIncrement = minBidIncrement_;
        emit MinBidIncrementUpdated(minBidIncrement_);
    }

    function setSettlementDuration(uint256 settlementDuration_) external onlyOwner {
        settlementDuration = settlementDuration_;
        emit SettlementDurationUpdated(settlementDuration_);
    }

    function setAntiSnipeDuration(uint256 antiSnipeDuration_) external onlyOwner {
        antiSnipeDuration = antiSnipeDuration_;
        emit AntiSnipeDurationUpdated(antiSnipeDuration_);
    }

    function setEventSchedule(
        uint256 startDayOfWeek,
        uint256 startTime,
        uint256 endDayOfWeek,
        uint256 endTime
    ) external onlyOwner {
        if (startDayOfWeek >= 7 || 
            startTime >= 24 hours || 
            endDayOfWeek >= 7 || 
            endTime >= 24 hours) {
            revert InvalidEventSchedule();
        }
        
        eventStartDay = startDayOfWeek;
        eventStartTime = startTime;
        eventEndDay = endDayOfWeek;
        eventEndTime = endTime;

        emit EventScheduleUpdated(startDayOfWeek, startTime, endDayOfWeek, endTime);
    }

    /**
     *
     * INTERNAL FUNCTIONS
     *
     */


    /**
     * _validateTokens - Validates tokens before an auction starts
     *
     * @param tokenIds - The token ids to auction
     * @param wrapped - Whether the tokens are wrapped
     * @param endTime - The end time of the auction
     *
     */
    function _validateTokens(uint256[] calldata tokenIds, bool[] calldata wrapped, uint64 endTime) internal {
        uint256 length = tokenIds.length;
        uint64 minExpiry = uint64(endTime + settlementDuration);

        for (uint256 i; i < length; ++i) {
            uint256 tokenId = tokenIds[i];

            if (tokenOnAuction[tokenId]) revert TokenAlreadyInAuction();

            tokenOnAuction[tokenId] = true;

            if (wrapped[i]) {
                (address _owner, uint32 fuses, uint64 expiry) = ensNameWrapper.getData(tokenId);
                if (_owner != msg.sender) revert TokenNotOwned();
                if (expiry < minExpiry) revert TokenExpired();
                if (fuses & CANNOT_TRANSFER != 0) revert TokenNotTransferrable();
            } else {
                if (ensRegistrar.ownerOf(tokenId) != msg.sender) revert TokenNotOwned();
                if (ensRegistrar.nameExpires(tokenId) < minExpiry) revert TokenExpired();
            }
        }
    }

    /**
     * processPayment - Process payment for a bid. If a bidder has a balance, use that first.
     *
     * @param paymentDue - The total amount due
     *
     */
    function _processPayment(uint256 paymentDue) internal {
        uint256 balance = balances[msg.sender];
        uint256 paymentFromBalance;
        uint256 paymentFromMsgValue;

        if (balance >= paymentDue) {
            paymentFromBalance = paymentDue;
            paymentFromMsgValue = 0;
        } else {
            paymentFromBalance = balance;
            paymentFromMsgValue = paymentDue - balance;
        }

        if (msg.value != paymentFromMsgValue) revert InvalidValue();

        balances[msg.sender] -= paymentFromBalance;
    }

    /**
     * _transferTokens - Transfer auction tokens to the highest bidder
     *
     * @param auction - The auction to transfer tokens from
     *
     * note: we save some gas by not checking if an auction has any bids as
     * Registrar (ERC721) / NameWrapper (ERC1155) will both revert for transfer
     * attempts to address(0).
     */
    function _transferTokens(Auction storage auction) internal {
        address seller = auction.seller;
        uint256 tokenCount = auction.tokenCount;
        address highestBidder = auction.highestBidder;
        
        _resetTokens(auction);

        for (uint256 i; i < tokenCount; ++i) {
            uint256 tokenId = auction.tokens[i].tokenId;

            if (auction.tokens[i].isWrapped) {
                ensNameWrapper.safeTransferFrom(seller, highestBidder, tokenId, 1, "");
            } else {
                ensRegistrar.transferFrom(seller, highestBidder, tokenId);
            }
        }
    }

    function _getActiveAuctionCount() internal view returns (uint256) {
        uint256 count = 0;

        for (uint256 i = nextAuctionId - 1; i > 0; ) {
            Auction storage auction = auctions[i];

            if (auction.status == Status.Active && block.timestamp < auction.endTime) {
                unchecked {
                    ++count;
                }
            } else if (block.timestamp >= auction.endTime) {
                break;
            }

            unchecked {
                --i;
            }
        }

        return count;
    }

    /**
     * _isClaimable - Internal check if an auction is claimable in case user c
     *
     * @param auction - The auction to check
     *
     */
    function _isClaimable(Auction storage auction) internal view returns (bool) {
        bool isApprovedForAllWrapped = false;
        bool isApprovedForAllUnwrapped = false;
        bool checkApprovedForAllWrapped = false;
        bool checkApprovedForAllUnwrapped = false;

        for (uint256 i; i < auction.tokenCount; ++i) {
            Token memory token = auction.tokens[i];

            if (token.isWrapped) {
                if (!checkApprovedForAllWrapped) {
                    checkApprovedForAllWrapped = true;
                    isApprovedForAllWrapped = ensNameWrapper.isApprovedForAll(auction.seller, address(this));
                }

                if (!isApprovedForAllWrapped && ensNameWrapper.getApproved(token.tokenId) != address(this)) {
                    return false;
                }

                (address _owner, uint32 fuses, ) = ensNameWrapper.getData(token.tokenId);

                if (_owner != auction.seller || fuses & CANNOT_TRANSFER != 0) {
                    return false;
                }
            } else {
                if (!checkApprovedForAllUnwrapped) {
                    checkApprovedForAllUnwrapped = true;
                    isApprovedForAllUnwrapped = ensRegistrar.isApprovedForAll(auction.seller, address(this));
                }

                if (!isApprovedForAllUnwrapped && ensRegistrar.getApproved(token.tokenId) != address(this)) {
                    return false;
                }

                if (ensRegistrar.ownerOf(token.tokenId) != auction.seller) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * _resetTokens - Reset auction tokens so they can be auctioned again if needed
     *
     * @param auction - The auction to reset
     *
     */
    function _resetTokens(Auction storage auction) internal {
        uint256 tokenCount = auction.tokenCount;

        for (uint256 i; i < tokenCount; ++i) {
            tokenOnAuction[auction.tokens[i].tokenId] = false;
        }
    }
}



// File: lib/solady/src/auth/Ownable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/// @notice Simple single owner authorization mixin.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)
///
/// @dev Note:
/// This implementation does NOT auto-initialize the owner to `msg.sender`.
/// You MUST call the `_initializeOwner` in the constructor / initializer.
///
/// While the ownable portion follows
/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,
/// the nomenclature for the 2-step ownership handover may be unique to this codebase.
abstract contract Ownable {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       CUSTOM ERRORS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The caller is not authorized to call the function.
    error Unauthorized();

    /// @dev The `newOwner` cannot be the zero address.
    error NewOwnerIsZeroAddress();

    /// @dev The `pendingOwner` does not have a valid handover request.
    error NoHandoverRequest();

    /// @dev Cannot double-initialize.
    error AlreadyInitialized();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.
    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be
    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),
    /// despite it not being as lightweight as a single argument event.
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);

    /// @dev An ownership handover to `pendingOwner` has been requested.
    event OwnershipHandoverRequested(address indexed pendingOwner);

    /// @dev The ownership handover to `pendingOwner` has been canceled.
    event OwnershipHandoverCanceled(address indexed pendingOwner);

    /// @dev `keccak256(bytes("OwnershipTransferred(address,address)"))`.
    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =
        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;

    /// @dev `keccak256(bytes("OwnershipHandoverRequested(address)"))`.
    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =
        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;

    /// @dev `keccak256(bytes("OwnershipHandoverCanceled(address)"))`.
    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =
        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                          STORAGE                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The owner slot is given by:
    /// `bytes32(~uint256(uint32(bytes4(keccak256("_OWNER_SLOT_NOT")))))`.
    /// It is intentionally chosen to be a high value
    /// to avoid collision with lower slots.
    /// The choice of manual storage layout is to enable compatibility
    /// with both regular and upgradeable contracts.
    bytes32 internal constant _OWNER_SLOT =
        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;

    /// The ownership handover slot of `newOwner` is given by:
    /// ```
    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))
    ///     let handoverSlot := keccak256(0x00, 0x20)
    /// ```
    /// It stores the expiry timestamp of the two-step ownership handover.
    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     INTERNAL FUNCTIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.
    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}

    /// @dev Initializes the owner directly without authorization guard.
    /// This function must be called upon initialization,
    /// regardless of whether the contract is upgradeable or not.
    /// This is to enable generalization to both regular and upgradeable contracts,
    /// and to save gas in case the initial owner is not the caller.
    /// For performance reasons, this function will not check if there
    /// is an existing owner.
    function _initializeOwner(address newOwner) internal virtual {
        if (_guardInitializeOwner()) {
            /// @solidity memory-safe-assembly
            assembly {
                let ownerSlot := _OWNER_SLOT
                if sload(ownerSlot) {
                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.
                    revert(0x1c, 0x04)
                }
                // Clean the upper 96 bits.
                newOwner := shr(96, shl(96, newOwner))
                // Store the new value.
                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))
                // Emit the {OwnershipTransferred} event.
                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)
            }
        } else {
            /// @solidity memory-safe-assembly
            assembly {
                // Clean the upper 96 bits.
                newOwner := shr(96, shl(96, newOwner))
                // Store the new value.
                sstore(_OWNER_SLOT, newOwner)
                // Emit the {OwnershipTransferred} event.
                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)
            }
        }
    }

    /// @dev Sets the owner directly without authorization guard.
    function _setOwner(address newOwner) internal virtual {
        if (_guardInitializeOwner()) {
            /// @solidity memory-safe-assembly
            assembly {
                let ownerSlot := _OWNER_SLOT
                // Clean the upper 96 bits.
                newOwner := shr(96, shl(96, newOwner))
                // Emit the {OwnershipTransferred} event.
                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)
                // Store the new value.
                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))
            }
        } else {
            /// @solidity memory-safe-assembly
            assembly {
                let ownerSlot := _OWNER_SLOT
                // Clean the upper 96 bits.
                newOwner := shr(96, shl(96, newOwner))
                // Emit the {OwnershipTransferred} event.
                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)
                // Store the new value.
                sstore(ownerSlot, newOwner)
            }
        }
    }

    /// @dev Throws if the sender is not the owner.
    function _checkOwner() internal view virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // If the caller is not the stored owner, revert.
            if iszero(eq(caller(), sload(_OWNER_SLOT))) {
                mstore(0x00, 0x82b42900) // `Unauthorized()`.
                revert(0x1c, 0x04)
            }
        }
    }

    /// @dev Returns how long a two-step ownership handover is valid for in seconds.
    /// Override to return a different value if needed.
    /// Made internal to conserve bytecode. Wrap it in a public function if needed.
    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {
        return 48 * 3600;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  PUBLIC UPDATE FUNCTIONS                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Allows the owner to transfer the ownership to `newOwner`.
    function transferOwnership(address newOwner) public payable virtual onlyOwner {
        /// @solidity memory-safe-assembly
        assembly {
            if iszero(shl(96, newOwner)) {
                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.
                revert(0x1c, 0x04)
            }
        }
        _setOwner(newOwner);
    }

    /// @dev Allows the owner to renounce their ownership.
    function renounceOwnership() public payable virtual onlyOwner {
        _setOwner(address(0));
    }

    /// @dev Request a two-step ownership handover to the caller.
    /// The request will automatically expire in 48 hours (172800 seconds) by default.
    function requestOwnershipHandover() public payable virtual {
        unchecked {
            uint256 expires = block.timestamp + _ownershipHandoverValidFor();
            /// @solidity memory-safe-assembly
            assembly {
                // Compute and set the handover slot to `expires`.
                mstore(0x0c, _HANDOVER_SLOT_SEED)
                mstore(0x00, caller())
                sstore(keccak256(0x0c, 0x20), expires)
                // Emit the {OwnershipHandoverRequested} event.
                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())
            }
        }
    }

    /// @dev Cancels the two-step ownership handover to the caller, if any.
    function cancelOwnershipHandover() public payable virtual {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute and set the handover slot to 0.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, caller())
            sstore(keccak256(0x0c, 0x20), 0)
            // Emit the {OwnershipHandoverCanceled} event.
            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())
        }
    }

    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.
    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.
    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute and set the handover slot to 0.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, pendingOwner)
            let handoverSlot := keccak256(0x0c, 0x20)
            // If the handover does not exist, or has expired.
            if gt(timestamp(), sload(handoverSlot)) {
                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.
                revert(0x1c, 0x04)
            }
            // Set the handover slot to 0.
            sstore(handoverSlot, 0)
        }
        _setOwner(pendingOwner);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   PUBLIC READ FUNCTIONS                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Returns the owner of the contract.
    function owner() public view virtual returns (address result) {
        /// @solidity memory-safe-assembly
        assembly {
            result := sload(_OWNER_SLOT)
        }
    }

    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.
    function ownershipHandoverExpiresAt(address pendingOwner)
        public
        view
        virtual
        returns (uint256 result)
    {
        /// @solidity memory-safe-assembly
        assembly {
            // Compute the handover slot.
            mstore(0x0c, _HANDOVER_SLOT_SEED)
            mstore(0x00, pendingOwner)
            // Load the handover slot.
            result := sload(keccak256(0x0c, 0x20))
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         MODIFIERS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Marks a function as only callable by the owner.
    modifier onlyOwner() virtual {
        _checkOwner();
        _;
    }
}


// File: src/IEnsAuctions.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

interface IEnsAuctions {
    function startAuction(
        uint256 startingPrice,
        uint256 buyNowPrice,
        uint256[] calldata tokenIds,
        bool[] calldata wrapped,
        bool useDiscount
    ) external payable;

    function bid(uint256 auctionId, uint256 bidAmount) external payable;
    function buyNow(uint256 auctionId) external payable;
    function claim(uint256 auctionId) external;
    function markAbandoned(uint256 auctionId) external;
    function markUnclaimable(uint256 auctionId) external;
    function withdrawBalance() external;

    function calculateFee(address sellerAddress, bool useDiscount) external view returns (uint256);
    function getAuctionTokens(uint256 auctionId) external view returns (uint256[] memory);
    function getNextEventStartTime() external view returns (uint64);
    function getNextEventEndTime() external view returns (uint64);

    function setMaxTokens(uint256 maxTokens_) external;
    function setMinBuyNowPrice(uint256 minBuyNowPrice_) external;
    function setMinStartingBid(uint256 minStartingPrice_) external;
    function setMinBidIncrement(uint256 minBidIncrement_) external;
    function setSettlementDuration(uint256 settlementDuration_) external;
    function setAntiSnipeDuration(uint256 antiSnipeDuration_) external;
    function setFeeCalculator(address feeCalculator_) external;
    function setFeeRecipient(address feeRecipient_) external;
    function setEventSchedule(
        uint256 startDayOfWeek,
        uint256 startTime,
        uint256 endDayOfWeek,
        uint256 endTime
    ) external;

    event Started(
        uint256 auctionId,
        address seller,
        uint256 startingPrice,
        uint256 buyNowPrice,
        uint64 startTime,
        uint64 endTime,
        uint256 tokenCount
    );
    event BuyNow(uint256 indexed auctionId, address buyer, uint256 value);
    event Bid(uint256 indexed auctionId, address bidder, uint256 value);
    event Claimed(uint256 indexed auctionId, address winner);
    event Abandoned(uint256 indexed auctionId);
    event Unclaimable(uint256 indexed auctionId);
    event Withdrawn(address indexed recipient, uint256 amount);
    event FeeCalculatorUpdated(address feeCalculator);
    event FeeRecipientUpdated(address feeRecipient);
    event MinStartingBidUpdated(uint256 minStartingBid);
    event MinBuyNowPriceUpdated(uint256 minBuyNowPrice);
    event MinBidIncrementUpdated(uint256 minBidIncrement);
    event AuctionDurationUpdated(uint256 auctionDuration);
    event SettlementDurationUpdated(uint256 settlementDuration);
    event AntiSnipeDurationUpdated(uint256 antiSnipeDuration);
    event MaxTokensUpdated(uint256 maxTokens);
    event EventScheduleUpdated(
        uint256 startDayOfWeek,
        uint256 startTime,
        uint256 endDayOfWeek,
        uint256 endTime
    );
    
    error AuctionBuyNowPeriod();
    error AuctionEnded();
    error AuctionHasNoBids();
    error AuctionIsClaimable();
    error AuctionNotEnded();
    error BidTooLow();
    error BuyNowTooLow();
    error BuyNowUnavailable();
    error InvalidEventSchedule();
    error InvalidFee();
    error InvalidLengthOfTokenIds();
    error InvalidStatus();
    error InvalidValue();
    error MaxTokensPerTxReached();
    error NotApproved();
    error NotAuthorized();
    error NotHighestBidder();
    error SellerCannotBid();
    error SettlementPeriodNotExpired();
    error SettlementPeriodEnded();
    error StartPriceTooLow();
    error TokenAlreadyInAuction();
    error TokenExpired();
    error TokenNotOwned();
    error TokenNotTransferrable();
    error TransferFailed();
}


// File: src/IFeeCalculator.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

interface IFeeCalculator {
    function calculateFee(
        uint256 totalAuctionCount,
        address seller,
        uint24 auctionCount,
        uint24 soldCount,
        uint24 unclaimableCount,
        uint24 abandonedCount,
        bool checkForDiscounts
    ) external view returns (uint256);
}


// File: src/IBaseRegistrar.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

interface IBaseRegistrar is IERC721 {
    function nameExpires(uint256 id) external view returns (uint256);
}

// File: src/INameWrapper.sol
//SPDX-License-Identifier: MIT
pragma solidity ~0.8.25;

import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

uint32 constant CANNOT_TRANSFER = 4;
uint32 constant CANNOT_APPROVE = 64;

interface INameWrapper is IERC1155 {
    function ownerOf(uint256 id) external view returns (address owner);
    function getApproved(uint256 tokenId) external view returns (address);
    function getData(uint256 id) external view returns (address, uint32, uint64);
}

// File: lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or
     *   {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the address zero.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the value of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] calldata accounts,
        uint256[] calldata ids
    ) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.
     *
     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.
     * Ensure to follow the checks-effects-interactions pattern and consider employing
     * reentrancy guards when interacting with untrusted contracts.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `value` amount.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.
     * Ensure to follow the checks-effects-interactions pattern and consider employing
     * reentrancy guards when interacting with untrusted contracts.
     *
     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.
     *
     * Requirements:
     *
     * - `ids` and `values` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external;
}


// File: lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

