
// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)

pragma solidity ^0.8.20;

import {Context} from "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * The initial owner is set to the address provided by the deployer. This can
 * later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    /**
     * @dev The caller account is not authorized to perform an operation.
     */
    error OwnableUnauthorizedAccount(address account);

    /**
     * @dev The owner is not a valid owner account. (eg. `address(0)`)
     */
    error OwnableInvalidOwner(address owner);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
     */
    constructor(address initialOwner) {
        if (initialOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(initialOwner);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        if (owner() != _msgSender()) {
            revert OwnableUnauthorizedAccount(_msgSender());
        }
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the value of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] calldata accounts,
        uint256[] calldata ids
    ) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.
     *
     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.
     * Ensure to follow the checks-effects-interactions pattern and consider employing
     * reentrancy guards when interacting with untrusted contracts.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `value` amount.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     *
     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.
     * Ensure to follow the checks-effects-interactions pattern and consider employing
     * reentrancy guards when interacting with untrusted contracts.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `values` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external;
}


// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Interface that must be implemented by smart contracts in order to receive
 * ERC-1155 token transfers.
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a `safeBatchTransferFrom` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)

pragma solidity ^0.8.20;

import {IERC165, ERC165} from "../../../utils/introspection/ERC165.sol";
import {IERC1155Receiver} from "../IERC1155Receiver.sol";

/**
 * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 */
abstract contract ERC1155Holder is ERC165, IERC1155Receiver {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the value of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the value of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves a `value` amount of tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 value) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
     * caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 value) external returns (bool);

    /**
     * @dev Moves a `value` amount of tokens from `from` to `to` using the
     * allowance mechanism. `value` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.20;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or
     *   {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
     *   a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the address zero.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.20;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be
     * reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)

pragma solidity ^0.8.20;

import {IERC721Receiver} from "../IERC721Receiver.sol";

/**
 * @dev Implementation of the {IERC721Receiver} interface.
 *
 * Accepts all token transfers.
 * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or
 * {IERC721-setApprovalForAll}.
 */
abstract contract ERC721Holder is IERC721Receiver {
    /**
     * @dev See {IERC721Receiver-onERC721Received}.
     *
     * Always returns `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {
        return this.onERC721Received.selector;
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)

pragma solidity ^0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)

pragma solidity ^0.8.20;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)

pragma solidity ^0.8.20;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;

    uint256 private _status;

    /**
     * @dev Unauthorized reentrant call.
     */
    error ReentrancyGuardReentrantCall();

    constructor() {
        _status = NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be NOT_ENTERED
        if (_status == ENTERED) {
            revert ReentrancyGuardReentrantCall();
        }

        // Any calls to nonReentrant after this point will fail
        _status = ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * `nonReentrant` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == ENTERED;
    }
}


// File: contracts/Marketplace/IMarketplace.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IMarketplace {
    event NewListing(
        uint256 _listingId,
        address _assetContract,
        address indexed _seller,
        uint256 _tokenId,
        uint256 _quantity,
        uint256 _deadline,
        bool _isDeadline,
        uint256 _price,
        uint8 _currency
    );

    event CanceledListing(
        uint _listingId,
        address _assetContract,
        address indexed _seller,
        uint256 _tokenId,
        uint256 _quantity
    );

    event NewSale(
        uint256 _listingId,
        address _assetContract,
        address indexed _buyer,
        address indexed _seller,
        uint256 _tokenId,
        uint256 _quantity,
        uint256 _price
    );

    event UpdatedListingPrice(uint256 _listingId, uint256 _newPrice);

    event IncreasedListDeadline(uint256 _listingId, uint256 _newDeadline);

    event UpdatedReservedBuyer(uint256 _listingId, address _newReservedBuyer);

    function listItem(
        address _assetContract,
        uint256 _tokenId,
        uint256 _quantity,
        uint256 _deadline,
        bool _isDeadline,
        uint256 _price,
        uint8 _currency,
        address _reservedBuyer
    ) external;

    enum TokenType {
        ERC721,
        ERC1155
    }

    enum Currency {
        ETH,
        BLOOM
    }

    /**
     * @notice The Marketplace Fees
     *
     * @param rate The % of sales collected as marketplace fees.
     * @param receiver address who will receive marketplace fees.
     * @param ethCollected Amount of Ether collected as fees.
     * @param bloomCollected Amount of token BLOOM collected as fees.
     */
    struct Fee {
        uint16 rate;
        address receiver;
        uint256 ethCollected;
        uint256 bloomCollected;
    }

    /**
     *  @notice The information stored for a listing.
     *
     *  @param collectionContract collection sc address.
     *  @param feeIsActive marketplace fees is active.
     *  @param royaltiesRate The % of sales collected as royalties.
     *  @param receivers The receivers of royalty.
     *  @param shares The % of royalty collected by each receivers.
     *  @param tokenType The type of token listed (ERC-721 or ERC-1155)
     */
    struct CollectionInfo {
        address collectionContract;
        bool feeIsActive;
        uint16 royaltiesRate;
        address[] receivers;
        mapping(address => uint16) shares;
        TokenType tokenType;
    }

    /**
     *  @notice The information stored for a listing.
     *
     *  @param listingId The unique ID of the listing.
     *  @param seller The creator of the listing.
     *  @param assetContract The address of the smart contract of the NFTs being listed.
     *  @param tokenId The tokenId of the NFTs being listed.
     *  @param quantity The quantity of NFTs being listed. This must be non-zero, and is expected to
     *                  be `1` for ERC-721 NFTs.
     *  @param deadline The UNIX timestamp at and after which NFTs cannot be bought from the listing.
     *  @param price The price to pay for NFTs listed.
     *  @param isDeadline The deadline is active
     *  @param isSold NFT is sold
     *  @param isCanceled Listing is canceled
     *  @param tokenType The type of token listed (ERC-721 or ERC-1155)
     *  @param currency The currency in which the price must be paid when buying the listed NFTs.
     */

    struct Listing {
        uint256 listingId;
        address seller;
        address assetContract;
        uint256 tokenId;
        uint256 quantity;
        uint256 deadline;
        uint256 price;
        bool isDeadline;
        bool isSold;
        bool isCanceled;
        TokenType tokenType;
        Currency currency;
    }

    function purchaseListing(uint256 _listingId) external payable;

    function batchPurchaseListing(uint256[] calldata _listings) external payable;

    function cancelList(uint256 _listingId) external;

    function updateListPrice(uint256 _listingId, uint8 _currency, uint256 _newPrice) external;

    function increaseListDeadline(uint256 _listingId, uint256 _secondsToAdd) external;

    function updateListReservation(uint256 _listingId, address _reservedBuyer) external;

    function claimRoyalties() external;

    function getTotalListings() external view returns (uint256);

    function getTotalListingsByCollection(
        address _collectionContract
    ) external view returns (uint256);

    function getActiveListings(uint256 _from, uint256 _to) external view returns (uint256[] memory);

    function getActiveListingsByCollection(
        address _collectionContract,
        uint256 _from,
        uint256 _to
    ) external view returns (uint256[] memory);

    function getTotalListingsByUser(address _user) external view returns (uint256);

    function getActiveListingsByUser(
        address _user,
        uint256 _from,
        uint256 _to
    ) external view returns (uint256[] memory);

    function getCollectionRoyalties(
        address _collectionContract
    )
        external
        view
        returns (uint16 royaltiesRate, address[] memory receivers, uint16[] memory shares);

    function addCollectionToWhitelist(
        address _collectionContract,
        bool _feeIsActive,
        uint16 _royaltiesRate,
        address[] memory _receivers,
        uint16[] memory _shares
    ) external;

    function updateCollectionFee(address _collectionContract, bool _feeIsActive) external;

    function removeCollectionFromWhitelist(address _collectionContract) external;

    function setTokenContract(address _tokenContract) external;

    function setMarketplaceFeeRate(uint16 _rate) external;

    function setMarketplaceFeeReceiver(address _receiver) external;

    function refundListings(uint256 _from, uint256 _to) external;

    function setCollectionRoyalties(
        address _collectionContract,
        uint16 _royaltiesRate,
        address[] memory _receivers,
        uint16[] memory _shares
    ) external;

    function collectionIsWhitelisted(address _assetContract) external view returns (bool);
}


// File: contracts/Marketplace/Marketplace.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

import "./IMarketplace.sol";

contract Marketplace is IMarketplace, Ownable, ERC1155Holder, ERC721Holder, ReentrancyGuard {
    IERC20 public tokenContract;

    uint256 private _listingIds;

    /// @dev Max rate
    uint256 private constant MAX_RATE = 10_000;

    Fee public marketplaceFees;

    mapping(address => CollectionInfo) public collectionWhitelist;

    mapping(uint => Listing) public listingById;

    mapping(address => uint256[]) public listingsByAddress;

    mapping(address => uint256[]) public listingsByCollection;

    /// @dev The address of reserved buyer for each listing
    mapping(uint => address) reservedBuyerByListing;

    mapping(address => uint256) public receiversAmounts;
    mapping(address => uint256) public receiversBloomAmounts;

    constructor(address _tokenContract, uint16 _rate, address _receiver) Ownable(msg.sender) {
        tokenContract = IERC20(_tokenContract);
        marketplaceFees.rate = _rate;
        marketplaceFees.receiver = _receiver;
    }

    /* ********************************** */
    /*               Modifiers            */
    /* ********************************** */

    // @notice Basic requirements for update listing
    modifier listingUpdateRequirements(uint256 _listingId) {
        require(
            listingById[_listingId].seller == msg.sender,
            "Should be the owner of the listing."
        );
        require(listingById[_listingId].isCanceled != true, "Offer already canceled.");
        require(listingById[_listingId].isSold != true, "Already sold.");
        _;
    }

    /* ********************************** */
    /*               Listings             */
    /* ********************************** */

    function listItem(
        address _assetContract,
        uint256 _tokenId,
        uint256 _quantity,
        uint256 _deadline,
        bool _isDeadline,
        uint256 _price,
        uint8 _currency,
        address _reservedBuyer
    ) external nonReentrant {
        require(
            collectionWhitelist[_assetContract].collectionContract == _assetContract,
            "This collection is not whitelisted"
        );

        require(_quantity > 0, "Quantity can't be 0");
        require(_price > 0, "Price can't be 0");

        _transferItems(
            _assetContract,
            collectionWhitelist[_assetContract].tokenType,
            msg.sender,
            address(this),
            _tokenId,
            _quantity
        );

        uint newListingId = _listingIds;

        listingById[newListingId] = Listing(
            newListingId,
            msg.sender,
            _assetContract,
            _tokenId,
            _quantity,
            block.timestamp + _deadline,
            _price,
            _isDeadline,
            false,
            false,
            collectionWhitelist[_assetContract].tokenType,
            Currency(_currency)
        );

        reservedBuyerByListing[newListingId] = _reservedBuyer;

        listingsByAddress[msg.sender].push(newListingId); // TODO : To review, maybe use another idea to avoid limitGas
        listingsByCollection[_assetContract].push(newListingId); // TODO : To review, maybe use another idea to avoid limitGas

        _listingIds++;

        emit NewListing(
            newListingId,
            _assetContract,
            msg.sender,
            _tokenId,
            _quantity,
            _deadline,
            _isDeadline,
            _price,
            _currency
        );
    }

    function purchaseListing(uint256 _listingId) external payable nonReentrant {
        _checkListingValidity(_listingId);

        if (listingById[_listingId].currency == Currency.ETH) {
            require(
                msg.value >= listingById[_listingId].price,
                "You don't have enough funds to purchase this item"
            );
        } else {
            require(
                tokenContract.balanceOf(msg.sender) >= listingById[_listingId].price,
                "You don't have enough tokens to purchase this item"
            );
        }

        _executeSale(_listingId);
    }

    function batchPurchaseListing(uint256[] calldata _listings) external payable nonReentrant {
        uint totalSaleEthPrice = 0;
        uint totalSaleBloomPrice = 0;

        for (uint i = 0; i < _listings.length; i++) {
            _checkListingValidity(_listings[i]);

            if (listingById[_listings[i]].currency == Currency.ETH) {
                totalSaleEthPrice += listingById[_listings[i]].price;
            } else {
                totalSaleBloomPrice += totalSaleBloomPrice + listingById[_listings[i]].price;
            }
        }

        require(
            msg.value >= totalSaleEthPrice,
            "You don't have enough funds to purchase this items"
        );
        require(
            tokenContract.balanceOf(msg.sender) >= totalSaleBloomPrice,
            "You don't have enough tokens to purchase this items"
        );

        for (uint i = 0; i < _listings.length; i++) {
            _executeSale(_listings[i]);
        }
    }

    function cancelList(
        uint256 _listingId
    ) external nonReentrant listingUpdateRequirements(_listingId) {
        listingById[_listingId].isCanceled = true;

        address assetContract = listingById[_listingId].assetContract;

        TokenType tokenType = _getTokenType(assetContract);

        // @notice send back the tokens to the seller
        _transferItems(
            assetContract,
            tokenType,
            address(this),
            msg.sender,
            listingById[_listingId].tokenId,
            listingById[_listingId].quantity
        );

        emit CanceledListing(
            _listingId,
            assetContract,
            listingById[_listingId].seller,
            listingById[_listingId].tokenId,
            listingById[_listingId].quantity
        );
    }

    function updateListPrice(
        uint256 _listingId,
        uint8 _currency,
        uint256 _newPrice
    ) external listingUpdateRequirements(_listingId) {
        require(_newPrice > 0, "Price can't be 0.");
        listingById[_listingId].currency = Currency(_currency);
        listingById[_listingId].price = _newPrice;

        emit UpdatedListingPrice(_listingId, _newPrice);
    }

    function increaseListDeadline(
        uint256 _listingId,
        uint256 _secondsToAdd
    ) external listingUpdateRequirements(_listingId) {
        require(listingById[_listingId].isDeadline == true, "No deadline set.");
        require(_secondsToAdd > 0, "Seconds to add can't be 0.");

        listingById[_listingId].deadline = listingById[_listingId].deadline + _secondsToAdd;

        emit IncreasedListDeadline(_listingId, _secondsToAdd);
    }

    function updateListReservation(
        uint256 _listingId,
        address _reservedBuyer
    ) external listingUpdateRequirements(_listingId) {
        reservedBuyerByListing[_listingId] = _reservedBuyer;

        emit UpdatedReservedBuyer(_listingId, _reservedBuyer);
    }

    function getTotalListings() external view returns (uint256) {
        return _listingIds;
    }

    function getTotalListingsByCollection(
        address _collectionContract
    ) external view returns (uint256) {
        return listingsByCollection[_collectionContract].length;
    }

    function getActiveListings(
        uint256 _from,
        uint256 _to
    ) external view returns (uint256[] memory) {
        require(_from <= _to && _to < _listingIds, "Invalid range");

        uint256[] memory tmpList = new uint256[](_to - _from + 1);

        uint activeListingCount = 0;

        for (uint i = _from; i <= _to; i++) {
            if (listingById[i].isSold == false && listingById[i].isCanceled == false) {
                tmpList[activeListingCount] = i;
                activeListingCount++;
            }
        }

        uint256[] memory activeListingList = new uint256[](activeListingCount);

        for (uint i = 0; i < activeListingCount; i++) {
            activeListingList[i] = tmpList[i];
        }

        return activeListingList;
    }

    function getActiveListingsByCollection(
        address _collectionContract,
        uint256 _from,
        uint256 _to
    ) external view returns (uint256[] memory) {
        require(
            _from <= _to && _to < listingsByCollection[_collectionContract].length,
            "Invalid range"
        );

        uint256[] memory tmpList = new uint256[](_to - _from + 1);

        uint activeListingCount = 0;

        for (uint i = _from; i <= _to; i++) {
            uint256 listingId = listingsByCollection[_collectionContract][i];
            if (
                listingById[listingId].isSold == false && listingById[listingId].isCanceled == false
            ) {
                tmpList[activeListingCount] = listingId;
                activeListingCount++;
            }
        }

        uint256[] memory activeListingList = new uint256[](activeListingCount);

        for (uint i = 0; i < activeListingCount; i++) {
            activeListingList[i] = tmpList[i];
        }

        return activeListingList;
    }

    function getTotalListingsByUser(address _user) external view returns (uint256) {
        return listingsByAddress[_user].length;
    }

    function getActiveListingsByUser(
        address _user,
        uint256 _from,
        uint256 _to
    ) external view returns (uint256[] memory) {
        require(_from <= _to && _to < listingsByAddress[_user].length, "Invalid range");

        uint256[] memory tmpList = new uint256[](_to - _from + 1);

        uint activeListingsCount = 0;
        for (uint i = _from; i <= _to; i++) {
            if (
                listingById[listingsByAddress[_user][i]].isSold == false &&
                listingById[listingsByAddress[_user][i]].isCanceled == false
            ) {
                tmpList[activeListingsCount] = listingsByAddress[_user][i];
                activeListingsCount++;
            }
        }

        uint256[] memory listingIds = new uint256[](activeListingsCount);

        for (uint i = 0; i < activeListingsCount; i++) {
            listingIds[i] = tmpList[i];
        }

        return listingIds;
    }

    function getCollectionRoyalties(
        address _collectionContract
    )
        external
        view
        returns (uint16 royaltiesRate, address[] memory receivers, uint16[] memory shares)
    {
        royaltiesRate = collectionWhitelist[_collectionContract].royaltiesRate;
        receivers = collectionWhitelist[_collectionContract].receivers;
        shares = new uint16[](receivers.length);
        for (uint256 i = 0; i < receivers.length; i++) {
            address receiver = receivers[i];
            shares[i] = collectionWhitelist[_collectionContract].shares[receiver];
        }
    }

    /* ********************************** */
    /*          Admin functions           */
    /* ********************************** */

    // @dev Withdraws ETH from this contract.
    // @notice : Emergency use only in case of a critical bug / new contract.
    function withdraw() external onlyOwner {
        require(address(this).balance > 0, "Nothing to withdraw");
        payable(msg.sender).transfer(address(this).balance);
    }

    // @dev Withdraws ERC20 tokens from this contract.
    // @notice : Emergency use only in case of a critical bug / new contract.
    function withdrawERC20(address _tokenContract) external onlyOwner {
        IERC20 token = IERC20(_tokenContract);
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, "Nothing to withdraw");
        token.transfer(msg.sender, balance);
    }

    // @dev Withdraws ERC721 tokens from this contract.
    // @notice : Emergency use only in case of a critical bug / new contract.
    function withdrawERC721(address _tokenContract, uint256 _tokenId) external onlyOwner {
        IERC721 token = IERC721(_tokenContract);
        token.transferFrom(address(this), msg.sender, _tokenId);
    }

    // @dev Withdraws ERC1155 tokens from this contract.
    // @notice : Emergency use only in case of a critical bug / new contract.
    function withdrawERC1155(
        address _tokenContract,
        uint256 _tokenId,
        uint256 _quantity
    ) external onlyOwner {
        IERC1155 token = IERC1155(_tokenContract);
        token.safeTransferFrom(address(this), msg.sender, _tokenId, _quantity, "");
    }

    function addCollectionToWhitelist(
        address _collectionContract,
        bool _feeIsActive,
        uint16 _royaltiesRate,
        address[] memory _receivers,
        uint16[] memory _shares
    ) external onlyOwner {
        collectionWhitelist[_collectionContract].collectionContract = _collectionContract;
        collectionWhitelist[_collectionContract].feeIsActive = _feeIsActive;
        collectionWhitelist[_collectionContract].tokenType = _getTokenType(_collectionContract);

        setCollectionRoyalties(_collectionContract, _royaltiesRate, _receivers, _shares);
    }

    function updateCollectionFee(
        address _collectionContract,
        bool _feeIsActive
    ) external onlyOwner {
        collectionWhitelist[_collectionContract].feeIsActive = _feeIsActive;
    }

    function removeCollectionFromWhitelist(address _collectionContract) external onlyOwner {
        collectionWhitelist[_collectionContract].collectionContract = address(0);
    }

    function setTokenContract(address _tokenContract) external onlyOwner {
        tokenContract = IERC20(_tokenContract);
    }

    function setMarketplaceFeeRate(uint16 _rate) external onlyOwner {
        marketplaceFees.rate = _rate;
    }

    function setMarketplaceFeeReceiver(address _receiver) external onlyOwner {
        marketplaceFees.receiver = _receiver;
    }

    function setCollectionRoyalties(
        address _collectionContract,
        uint16 _royaltiesRate,
        address[] memory _receivers,
        uint16[] memory _shares
    ) public onlyOwner {
        require(_receivers.length == _shares.length, "receivers and shares length mismatch");
        require(_receivers.length > 0, "no royalty receivers");
        require(_royaltiesRate <= MAX_RATE, "max royalty rate exceeded");
        require(_sumArray(_shares) == MAX_RATE, "shares rate mismatch");

        collectionWhitelist[_collectionContract].receivers = _receivers;
        collectionWhitelist[_collectionContract].royaltiesRate = _royaltiesRate;
        for (uint256 i = 0; i < _receivers.length; i++) {
            collectionWhitelist[_collectionContract].shares[_receivers[i]] = _shares[i];
        }
    }

    function refundListings(uint256 _from, uint256 _to) external onlyOwner {
        require(_from <= _to && _to < _listingIds, "Invalid range");

        for (uint i = _from; i <= _to; i++) {
            if (listingById[i].isSold == false && listingById[i].isCanceled == false) {
                listingById[i].isCanceled = true;
                _transferItems(
                    listingById[i].assetContract,
                    listingById[i].tokenType,
                    address(this),
                    listingById[i].seller,
                    listingById[i].tokenId,
                    listingById[i].quantity
                );
            }
        }
    }

    /* ********************************** */
    /*        Fees & Royalties            */
    /* ********************************** */

    function claimMarketplaceFees() external {
        require(
            msg.sender == marketplaceFees.receiver,
            "You're not the receiver of marketplace fees"
        );

        uint256 ethCollected = marketplaceFees.ethCollected;
        uint256 bloomCollected = marketplaceFees.bloomCollected;

        require(ethCollected > 0 || bloomCollected > 0, "You don't have enough token to claim");
        if (ethCollected > 0) {
            marketplaceFees.ethCollected = 0;
            payable(msg.sender).transfer(ethCollected);
        }

        if (bloomCollected > 0) {
            marketplaceFees.bloomCollected = 0;
            tokenContract.transfer(msg.sender, bloomCollected);
        }
    }

    function claimRoyalties() external {
        uint256 receiverAmounts = receiversAmounts[msg.sender];
        uint256 receiverBloomAmounts = receiversBloomAmounts[msg.sender];
        require(
            receiverAmounts > 0 || receiverBloomAmounts > 0,
            "You don't have enough token to claim"
        );
        if (receiverAmounts > 0) {
            receiversAmounts[msg.sender] = 0;
            payable(msg.sender).transfer(receiverAmounts);
        }

        if (receiverBloomAmounts > 0) {
            receiversBloomAmounts[msg.sender] = 0;
            tokenContract.transfer(msg.sender, receiverBloomAmounts);
        }
    }

    /* ********************************** */
    /*               Internal            */
    /* ********************************** */

    /// @dev Returns the interface supported by a contract.
    function _getTokenType(address _assetContract) internal view returns (TokenType tokenType) {
        if (IERC165(_assetContract).supportsInterface(type(IERC1155).interfaceId)) {
            tokenType = TokenType.ERC1155;
        } else if (IERC165(_assetContract).supportsInterface(type(IERC721).interfaceId)) {
            tokenType = TokenType.ERC721;
        } else {
            revert("Token must be ERC1155 or ERC721");
        }
    }

    /// @dev Checks whether the listing exists, is active, and is reserved for buyer.
    function _checkListingValidity(uint256 _listingId) internal view {
        require(listingById[_listingId].seller != address(0), "Listing doesn't exist");
        require(
            reservedBuyerByListing[_listingId] == address(0) ||
                reservedBuyerByListing[_listingId] == msg.sender,
            "buyer not reserved"
        );

        require(listingById[_listingId].isSold != true, "Item already sold");
        require(listingById[_listingId].isCanceled != true, "Listing canceled");
        require(listingById[_listingId].seller != msg.sender, "You can't purchase your own item");

        if (listingById[_listingId].isDeadline) {
            require(block.timestamp <= listingById[_listingId].deadline, "Listing expired");
        }
    }

    function _executeSale(uint256 _listingId) internal {
        address assetContract = listingById[_listingId].assetContract;

        _payout(msg.sender, listingById[_listingId]);

        // @notice send the item to the buyer
        _transferItems(
            assetContract,
            collectionWhitelist[assetContract].tokenType,
            address(this),
            msg.sender,
            listingById[_listingId].tokenId,
            listingById[_listingId].quantity
        );

        listingById[_listingId].isSold = true;

        emit NewSale(
            _listingId,
            assetContract,
            msg.sender,
            listingById[_listingId].seller,
            listingById[_listingId].tokenId,
            listingById[_listingId].quantity,
            listingById[_listingId].price
        );
    }

    function _payout(address _buyer, Listing memory _listing) internal {
        uint256 fees = 0;
        uint256 amountForSeller = 0;

        // Collect Marketplace fees
        if (collectionWhitelist[_listing.assetContract].feeIsActive) {
            fees = (_listing.price * marketplaceFees.rate) / MAX_RATE;
            require(fees > 0, "Fee should be greater than 0");
            amountForSeller = _listing.price - fees;

            if (_listing.currency == Currency.BLOOM) {
                tokenContract.transferFrom(_buyer, address(this), fees);
                marketplaceFees.bloomCollected += fees;
            } else {
                marketplaceFees.ethCollected += fees;
            }
        } else {
            amountForSeller = _listing.price;
        }

        // Collect royalties
        if (collectionWhitelist[_listing.assetContract].receivers.length > 0) {
            uint256 royaltiesAmount = (_listing.price *
                collectionWhitelist[_listing.assetContract].royaltiesRate) / MAX_RATE;
            amountForSeller = amountForSeller - royaltiesAmount;

            if (_listing.currency == Currency.BLOOM) {
                tokenContract.transferFrom(_buyer, address(this), royaltiesAmount);
            }

            address[] memory receivers = collectionWhitelist[_listing.assetContract].receivers;
            for (uint256 i = 0; i < receivers.length; i++) {
                uint256 receiverAmounts = (royaltiesAmount *
                    collectionWhitelist[_listing.assetContract].shares[receivers[i]]) / MAX_RATE;
                if (_listing.currency == Currency.ETH) {
                    receiversAmounts[receivers[i]] =
                        receiversAmounts[receivers[i]] +
                        receiverAmounts;
                } else {
                    receiversBloomAmounts[receivers[i]] =
                        receiversBloomAmounts[receivers[i]] +
                        receiverAmounts;
                }
            }
        }

        // Payout seller
        require(amountForSeller > 0, "Amount for seller should be greater than 0");
        _transferTokens(_buyer, _listing.seller, amountForSeller, _listing.currency);
    }

    /// @dev Transfers ETH or BLOOM Token
    function _transferTokens(
        address _from,
        address _to,
        uint256 _amount,
        Currency _currency
    ) internal {
        if (_currency == Currency.ETH) {
            payable(_to).transfer(_amount);
        } else {
            tokenContract.transferFrom(_from, _to, _amount);
        }
    }

    /// @dev Transfers tokens ERC1155 or ERC721
    function _transferItems(
        address _assetContract,
        TokenType _tokenType,
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _quantity
    ) internal {
        if (_tokenType == TokenType.ERC1155) {
            IERC1155(_assetContract).safeTransferFrom(_from, _to, _tokenId, _quantity, "");
        } else if (_tokenType == TokenType.ERC721) {
            IERC721(_assetContract).safeTransferFrom(_from, _to, _tokenId, "");
        }
    }

    /* ********************************** */
    /*               Utils            */
    /* ********************************** */

    function _sumArray(uint16[] memory _array) internal pure returns (uint256 sum) {
        for (uint i = 0; i < _array.length; i++) {
            sum += _array[i];
        }
        return sum;
    }

    /* ********************************** */
    /*               Others            */
    /* ********************************** */

    function collectionIsWhitelisted(address _assetContract) external view returns (bool) {
        return collectionWhitelist[_assetContract].collectionContract == _assetContract;
    }

    receive() external payable {}
}

