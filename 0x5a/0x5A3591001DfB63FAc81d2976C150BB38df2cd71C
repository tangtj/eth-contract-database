
// File: @openzeppelin/contracts/interfaces/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)

pragma solidity ^0.8.0;

import "../token/ERC721/IERC721.sol";


// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] calldata accounts,
        uint256[] calldata ids
    ) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}


// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a `safeBatchTransferFrom` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)

pragma solidity ^0.8.0;

import "./ERC1155Receiver.sol";

/**
 * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 *
 * @dev _Available since v3.1._
 */
contract ERC1155Holder is ERC1155Receiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}


// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)

pragma solidity ^0.8.0;

import "../IERC1155Receiver.sol";
import "../../../utils/introspection/ERC165.sol";

/**
 * @dev _Available since v3.1._
 */
abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}


// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}


// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)

pragma solidity ^0.8.0;

import "../IERC721Receiver.sol";

/**
 * @dev Implementation of the {IERC721Receiver} interface.
 *
 * Accepts all token transfers.
 * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
 */
contract ERC721Holder is IERC721Receiver {
    /**
     * @dev See {IERC721Receiver-onERC721Received}.
     *
     * Always returns `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: contracts/ethereum/core/HyperCycleShareManager.sol
// SPDX-License-Identifier: MIT
/*
    Version 1 of the HyperCycle Share Manager contract.
*/

pragma solidity 0.8.19;

import {Context} from '@openzeppelin/contracts/utils/Context.sol';
import {ERC721Holder} from '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';
import {ERC1155Holder} from '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';
import {ShareManagerErrors as Errors} from '../libs/ShareManagerErrors.sol';
import {ShareManagerEvents as Events} from '../libs/ShareManagerEvents.sol';
import {ShareManagerTypes as Types, IHYPCSwapV2, IHyperCycleLicense, IHyperCycleShareTokensV2, IHYPC} from '../libs/ShareManagerTypes.sol';

/**
@title HyperCycle Share Manager, revenue sharing manager.
@author Rodolfo Cova, Barry Rowe
@notice HyperCycle is a network of AI computation nodes offering different AI services in a 
        decentralized manner. In this system, there are license holders, token holders, hardware
        operators, and AI developers. Using the HyperCycleSwapV2 contract, an amount of HyPC (erc20)
        can be swapped for a cHyPC (containerized HyPC) token, which can then point towards a
        license (HyperCycleLicense) NFT id. At this point, the owner of this license can assign
        their license to some hardware running the HyperCycle Node Manager, and can from then
        on accept AI service requests on the network. 

        The HyperCycle Share Manager (This contract) allows the chypc owner to create a revenue sharing proposal, 
        to understand in deep the Share Token Contract, please refer to he Share Token Contract 
        documentation, See {HyperCycleShareTokensV2}.

        The main idea of the Share Manager is to be the one holding and managing the Share Token,
        being able to use the same benefits of the Share Tokens and extend it with the votations that
        share token holders can execute for the Share.

        To create a Share Proposal with the Share Manager, the chypc owner needs to call 
        `createShareProposal` function, this function will create a new Share Proposal and transfer
        the chypc to the Share Manager, the Share Manager will be the one holding the chypc until
        the Share Proposal is ended, in case the Share Proposal is ended, the chypc will be redeemed
        into hypc tokens, in which the share holders will be able to claim the proportional amount
        of share tokens to hypc tokens.

        The Share Proposal will be created with the following data:
            - CHyPC Data: CHyPC Id, CHyPC Owner, CHyPC Level, Initial Revenue Tokens, Initial Wealth Tokens
            - License Data: License Number, License Owner, License Level, Initial Revenue Tokens, Initial Wealth Tokens
            - Operator Data: Operator Revenue, Operator Assigned String, Operator Address
            - Share Token Data: Share Token Number, Revenue Deposit Delay, Revenue Token Id, Wealth Token Id, Valid End Timestamp
            - Status: Pending
        
        The Share Proposal can have the following status in the entire lifecycle of the Share Proposal:
            - Pending: The Share Proposal is created and waiting for the CHyPC NFT to be transfered to the Share Manager
            - Started: The Share Proposal is started and the Share Tokens are created, the CHyPC NFT is transfered to the Share Manager
            - Ended: The Share Proposal is ended and the license is transfered to the License Owner, 
                    the CHyPC NFT will be redeem for HyPC tokens and will be claimable by the Share Token Holders.

        The Share Manager contract had a DAO system where share token holderes can be able to create votations to change 
        the hardware operator, the hardware operator revenue, the manager contract and to cancel the share proposal, 
        the votations will be created by the Share Manager and the share token holders will be able to vote.

        The Share Proposal can be ended by the share token holders any time the consensus is reached, for this 100% or 90% (depends on the
        actual `SELECTED_VOTATION_PORCENT`) of the wealth tokens needs to be voted to end the Share Proposal, in case the Share Proposal is 
        ended, the ending process will be executed.

        The Share Manager contract can be changed by the share token holders any time the consensus is reached, for this 100% of the wealth tokens
        needs to be voted to change the Share Manager, in case the Share Manager is changed,  the transfer of the Share Token Ownership will be executed.

        The Hardware Operator can be changed by the share token holders any time the consensus is reached, for this 50% of the wealth tokens
        needs to be voted to change the Hardware Operator, in case the Hardware Operator is changed, the Operator Revenue will be transfered
        to the older operator and the new operator will be set.

        The Hardware Operator Revenue can be changed by the share token holders any time the consensus is reached, 
        for this 50% of the wealth tokens needs to be voted to change the Hardware Operator Revenue, 
        in case the Hardware Operator Revenue is changed, the new operator revenue will be set.

        Another important feature of the Share Manager is the ability to migrate the Share Tokens from the Share Tokens contract
        to the Share Manager, this will allow the Share Manager to be the one holding the Share Tokens and be able to manage the Share
        Proposal and Votations. The Share Manager will be able to claim the Hypc tokens, based in the amount of wealth tokens available, 
        in case the Share Proposal is ended and the CHyPC exists.

        To migrate the Share Tokens to the Share Manager contract, the Share Token owner needs to call `startShareProposalMigration` function,
        this function will start the migration and the Share Manager contract will be able to finish the migration only if the ownership
        of the share token is changed to the Share Manager contract, and the Share Proposal is pending.
*/
contract HyperCycleShareManager is ERC721Holder, ERC1155Holder, Context {
    Types.ManagerData public managerData;

    uint256 public sharesProposalsAmount;

    uint256 constant ONE_HUNDRED_PERCENT = 1e18;

    uint256 public SELECTED_VOTATION_PERCENT;

    mapping(uint256 shareProposalId => mapping(address user => uint256)) private _votePower;

    mapping(uint256 shareProposalId => mapping(uint256 votationIndex =>mapping(address user => bool))) private _voted;

    mapping(uint256 shareProposalId => uint256) private _votationId;

    mapping(uint256 shareProposalId => mapping(uint256 votationId => Types.Votation)) private _votations;

    mapping(uint256 shareProposalId => Types.ShareProposalData) private _shareProposals;

    mapping(uint256 shareTokenNumber => bool) private _shareTokenExists;

    modifier onlyVoter(uint256 shareProposalId) {
        if (_votePower[shareProposalId][_msgSender()] == 0) revert Errors.NoWealthTokensAvailable();

        _;
    }

    modifier onlyCHyPCOwner(uint256 shareProposalId) {
        if (_shareProposals[shareProposalId].chypcData.tokenOwner != _msgSender()) revert Errors.InvalidCHYPCOwner();

        _;
    }

    modifier onlyLicenseOwner(uint256 licenseNumber) {
        if (managerData.licenseContract.ownerOf(licenseNumber) != _msgSender()) revert Errors.InvalidLicenseOwner();
        _;
    }

    /**
        @dev The constructor takes in the contract addresses for the HyPC token, license, cHyPC NFTs and Share Tokens contract.
        @param _consensusOption: The consensus option to be used for the votations.
        @param _hypcToken: The HyPC ERC20 contract address.
        @param _chypcV2: The cHyPC ERC721 contract address.
        @param _licenseContract: The license ERC721 contract address.
        @param _hypcShareTokens: The license ERC721 contract address.
    */
    constructor(Types.ConsensusOptions _consensusOption, address _hypcToken, address _chypcV2, address _licenseContract, address _hypcShareTokens) payable {
        if (_hypcToken == address(0)) revert Errors.InvalidHYPCTokenAddress();

        if (_chypcV2 == address(0)) revert Errors.InvalidCHYPCAddress();

        if (_licenseContract == address(0)) revert Errors.InvalidLicenseAddress();

        if (_hypcShareTokens == address(0)) revert Errors.InvalidShareTokenContract();

        _consensusOption == Types.ConsensusOptions.ONE_HUNDRED_PERCENT ?
            SELECTED_VOTATION_PERCENT = ONE_HUNDRED_PERCENT :
            SELECTED_VOTATION_PERCENT = ONE_HUNDRED_PERCENT * 9 / 10;

        managerData = Types.ManagerData({
            hypcToken: IHYPC(_hypcToken),
            chypcV2: IHYPCSwapV2(_chypcV2),
            licenseContract: IHyperCycleLicense(_licenseContract),
            hypcShareTokens: IHyperCycleShareTokensV2(_hypcShareTokens)
        });
    }

    // Share proposal management functions

    /**
    @notice Allows a user to create a new share.
    @param proposalData The encoded data needed to create a new share proposal, should have encoded: 
                        (uint256,uint256,uint256,uint256,uint256,string,address,bool,bool).
    @notice chypcId: should be the license number to be used for the share.
    @notice revenueToAssignToChypc: should be the amount of revenue tokens to be assigned to the chypc owner.
    @notice wealthToAssignToChypc: should be the amount of wealth tokens to be assigned to the chypc owner.
    @notice revenueDepositDelay: should be the amount of time in seconds that the revenue tokens will be locked.
    @notice operatorAssignedString: should be the string to be used as the operator assigned string for the share.
    @notice hardwareOperator: should be the address of the hardware operator to be used for the share.
    @notice chypcExist: should be true if the share will be completed by a cHyPC NFT, false in case the license is already backed.
    */
    function createShareProposal(bytes memory proposalData) external {
        (
            uint256 chypcId,
            uint256 revenueToAssignToChypc,
            uint256 wealthToAssignToChypc,
            uint256 revenueDepositDelay,
            uint256 licenseNumber,
            string memory operatorAssignedString,
            address hardwareOperator
        ) = abi.decode(proposalData, (uint256, uint256, uint256, uint256, uint256, string, address));

        uint256 chypcLevel = managerData.chypcV2.getTokenLevel(chypcId);

        if (managerData.chypcV2.ownerOf(chypcId) != _msgSender()) revert Errors.InvalidCHYPCOwner();

        if (hardwareOperator == address(0)) revert Errors.InvalidProposedAddress();

        if (bytes(operatorAssignedString).length == 0) revert Errors.InvalidProposedString();

        if (
            revenueToAssignToChypc > (1 << chypcLevel) * 7 / 10 ||
            wealthToAssignToChypc > (1 << chypcLevel)
        ) revert Errors.InvalidTokenAmount();

        uint256 shareProposalId = sharesProposalsAmount++;

        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        shareProposal.operatorData = Types.HardwareOperatorData({
            operatorRevenue: (1 << chypcLevel) * 2 / 10,
            operatorAssignedString: operatorAssignedString,
            operatorAddress: hardwareOperator
        });

        shareProposal.status = Types.ShareProposalStatus.PENDING;

        shareProposal.chypcData = Types.TokenHolderData({
            tokenNumber: chypcId,
            tokenOwner: _msgSender(),
            tokenLevel: chypcLevel,
            initialRevenueTokens: revenueToAssignToChypc,
            initialWealthTokens: wealthToAssignToChypc
        });

        shareProposal.shareTokenData.revenueDepositDelay = revenueDepositDelay;

        uint256 votationId = _votationId[shareProposalId];

        _votations[shareProposalId][votationId] = Types.Votation({
            votationId: votationId,
            votesFor: 0,
            votesAgainst: 0,
            deadline: type(uint256).max,
            proposedData: '',
            option: Types.VotationOptions.CANCEL_SHARE,
            amountReached: false
        });

        _votationId[shareProposalId]++;
        emit Events.VoteStarted(shareProposalId, votationId, Types.VotationOptions.CANCEL_SHARE);

        managerData.chypcV2.safeTransferFrom(_msgSender(), address(this), chypcId);

        if (licenseNumber != 0) {
            _completeProposal(shareProposalId, licenseNumber);
        }

        emit Events.ShareProposalCreated(shareProposalId);
    }

    /// @notice Allows the owner of the cHyPC to cancel a pending share proposal.
    /// @param shareProposalId the share proposal Id to be cancelled.
    function cancelPendingShareProposal(uint256 shareProposalId) external onlyCHyPCOwner(shareProposalId) {
        if (_shareProposals[shareProposalId].status != Types.ShareProposalStatus.PENDING)
            revert Errors.ShareProposalIsNotPending();

        _endShareProposal(shareProposalId);
    }

    /// @notice Allows the owner of the License to complete a pending share proposal.
    /// @param shareProposalId The share proposal Id to be used to complete the share.
    /// @param licenseNumber The License NFT id to be used to start the share.
    function completeShareProposal(uint256 shareProposalId, uint256 licenseNumber) external onlyLicenseOwner(licenseNumber) {
        if (_shareProposals[shareProposalId].status != Types.ShareProposalStatus.PENDING)
            revert Errors.ShareProposalIsNotPending();

        _completeProposal(shareProposalId, licenseNumber);
    }

    /// @notice Internal function to allow the License NFT owner to complete a pending share proposal.
    /// @param shareProposalId The share proposal Id to be used to complete the share.
    /// @param licenseNumber The License NFT id to be used to start the share.
    function _completeProposal(uint256 shareProposalId, uint256 licenseNumber) private {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        uint256 licenseLevel = managerData.licenseContract.getLicenseHeight(licenseNumber);
        uint256 totalSupply = 1 << shareProposal.chypcData.tokenLevel;

        if (licenseLevel != shareProposal.chypcData.tokenLevel)
            revert Errors.TokenLevelMismatch();

        shareProposal.status = Types.ShareProposalStatus.STARTED;

        shareProposal.licenseData = Types.TokenHolderData({
            tokenNumber: licenseNumber,
            tokenOwner: _msgSender(),
            tokenLevel: licenseLevel,
            initialRevenueTokens: (totalSupply * 7 / 10) - shareProposal.chypcData.initialRevenueTokens,
            initialWealthTokens: totalSupply - shareProposal.chypcData.initialWealthTokens
        });

        uint256 currentShareNumber = managerData.hypcShareTokens.currentShareNumber();

        _shareTokenExists[currentShareNumber] = true;

        shareProposal.shareTokenData = Types.ShareTokenData({
            shareTokenNumber: currentShareNumber,
            revenueDepositDelay: shareProposal.shareTokenData.revenueDepositDelay,
            rTokenId: currentShareNumber << 1,
            wTokenId: (currentShareNumber << 1) + 1,
            validEndTimestamp: block.timestamp + 1 days
        });

        managerData.licenseContract.safeTransferFrom(_msgSender(), address(this), licenseNumber);

        managerData.licenseContract.approve(
            address(managerData.hypcShareTokens),
            licenseNumber
        );

        managerData.chypcV2.approve(address(managerData.hypcShareTokens), shareProposal.chypcData.tokenNumber);

        managerData.hypcShareTokens.createShareTokens(
            licenseNumber,
            shareProposal.chypcData.tokenNumber,
            true,
            shareProposal.operatorData.operatorAssignedString,
            shareProposal.shareTokenData.revenueDepositDelay
        );

        _sendRevenueAndWealthTokens(
            shareProposal.licenseData.tokenOwner,
            shareProposal.shareTokenData.rTokenId,
            shareProposal.shareTokenData.wTokenId,
            shareProposal.licenseData.initialRevenueTokens,
            shareProposal.licenseData.initialWealthTokens
        );

        _sendRevenueAndWealthTokens(
            shareProposal.chypcData.tokenOwner,
            shareProposal.shareTokenData.rTokenId,
            shareProposal.shareTokenData.wTokenId,
            shareProposal.chypcData.initialRevenueTokens,
            shareProposal.chypcData.initialWealthTokens
        );

        emit Events.ShareProposalStarted(shareProposalId);
    }

    /// @notice Private function to send the share proposal tokens
    /// @param to address to send tokens
    /// @param rTokenId id of the revenue token
    /// @param wTokenId id of the wealth token
    /// @param rTokenAmount amount of revenue to send
    /// @param wTokenAmount amount of wealth to send
    function _sendRevenueAndWealthTokens(
        address to,
        uint256 rTokenId,
        uint256 wTokenId,
        uint256 rTokenAmount,
        uint256 wTokenAmount
    ) private {
        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (rTokenAmount, wTokenAmount);
        uint256[] memory tokenIds = new uint256[](2);
        (tokenIds[0], tokenIds[1]) = (rTokenId, wTokenId);

        managerData.hypcShareTokens.safeBatchTransferFrom(address(this), to, tokenIds, amounts, '');
    }
    
    /// @notice This contract will start the migration to the Share Manager contract
    ///         to be able to migrate the share proposal, it needs to be called by the share owner
    /// @param shareTokenNumber share token number to start migration from Share Tokens contract
    /// @param hardwareOperator address of the hardware operator to be used for the share
    function startShareProposalMigration(
        uint256 shareTokenNumber,
        address hardwareOperator,
        string memory operatorAssignedString
    ) external {
        if (managerData.hypcShareTokens.getShareOwner(shareTokenNumber) != msg.sender)
            revert Errors.InvalidShareTokenOwner();

        if (!managerData.hypcShareTokens.isShareActive(shareTokenNumber)) revert Errors.GetShareDataFailed();

        if (hardwareOperator == address(0)) revert Errors.InvalidProposedAddress();

        (uint256 revenueDepositDelay, bool chypcExists) = _getShareData(shareTokenNumber);

        if (!chypcExists) revert Errors.ChypcIsNotHeld();

        uint256 shareProposalId = sharesProposalsAmount++;

        _shareProposals[shareProposalId].shareTokenData = Types.ShareTokenData({
            shareTokenNumber: shareTokenNumber,
            revenueDepositDelay: revenueDepositDelay,
            rTokenId: shareTokenNumber * 2,
            wTokenId: shareTokenNumber * 2 + 1,
            validEndTimestamp: managerData.hypcShareTokens.getShareStartTime(shareTokenNumber) + 1 days
        });

        uint256 chypcId = managerData.hypcShareTokens.getShareCHyPCId(shareTokenNumber);
        uint256 licenseId = managerData.hypcShareTokens.getShareLicenseId(shareTokenNumber);
        uint256 chypcLevel = managerData.chypcV2.getTokenLevel(chypcId);
        uint256 licenseLevel = managerData.licenseContract.getLicenseHeight(licenseId);
        uint256 wealthTokensSupply = managerData.hypcShareTokens.getRevenueTokenTotalSupply(shareTokenNumber);

        if (licenseLevel != chypcLevel)
            revert Errors.TokenLevelMismatch();

        _shareProposals[shareProposalId].chypcData = Types.TokenHolderData({
            tokenNumber: chypcId,
            tokenOwner: msg.sender,
            tokenLevel: chypcLevel,
            initialRevenueTokens: wealthTokensSupply * 7 / 10,
            initialWealthTokens: wealthTokensSupply
        });

        _shareProposals[shareProposalId].licenseData = Types.TokenHolderData({
            tokenNumber: licenseId,
            tokenOwner: msg.sender,
            tokenLevel: licenseLevel,
            initialRevenueTokens: 0,
            initialWealthTokens: 0
        });

        _shareProposals[shareProposalId].operatorData = Types.HardwareOperatorData({
            operatorRevenue: wealthTokensSupply * 2 / 10,
            operatorAssignedString: operatorAssignedString,
            operatorAddress: hardwareOperator
        });

        _shareProposals[shareProposalId].status = Types.ShareProposalStatus.PENDING;

        managerData.hypcShareTokens.safeTransferFrom(
            msg.sender, 
            address(this), 
            _shareProposals[shareProposalId].shareTokenData.rTokenId, 
            wealthTokensSupply * 3 / 10, 
            ''
        );

        emit Events.ShareProposalCreated(shareProposalId);
    }

    function cancelShareTokenMigration(uint256 shareProposalId) external {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        uint256 shareTokenNumber = shareProposal.shareTokenData.shareTokenNumber;

        if (shareProposal.status != Types.ShareProposalStatus.PENDING)
            revert Errors.ShareProposalIsNotPending();
        
        if (
            managerData.hypcShareTokens.getShareOwner(
                shareTokenNumber
            ) != address(this)
        ) revert Errors.InvalidShareTokenOwner();

        if (_msgSender() != shareProposal.chypcData.tokenOwner) revert Errors.InvalidCHYPCOwner();

        shareProposal.status = Types.ShareProposalStatus.ENDED;

        managerData.hypcShareTokens.transferShareOwnership(shareTokenNumber, _msgSender());

        uint256 wealthTokensSupply = managerData.hypcShareTokens.getRevenueTokenTotalSupply(shareTokenNumber);

        managerData.hypcShareTokens.safeTransferFrom(
            address(this),
            msg.sender,
            _shareProposals[shareProposalId].shareTokenData.rTokenId, 
            wealthTokensSupply * 3 / 10, 
            ''
        );

        emit Events.ShareProposalEnded(shareProposalId);
    }

    /// @notice This function will finish the migration to the Share Manager contract
    ///         The owner will be able to finish the migration only if the ownership of the share token
    ///         is changed to this contract, and the share proposal is pending
    /// @param shareProposalId Share proposal id to finish migration
    function finishShareTokenMigration(uint256 shareProposalId) external {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        uint256 shareTokenNumber = shareProposal.shareTokenData.shareTokenNumber;
        
        if (_shareTokenExists[shareTokenNumber]) revert Errors.ShareTokenAlreadyExists();

        if (managerData.hypcShareTokens.getShareOwner(shareTokenNumber) != address(this))
            revert Errors.InvalidShareTokenOwner();

        managerData.hypcShareTokens.setShareMessage(
            shareTokenNumber,
            shareProposal.operatorData.operatorAssignedString
        );

        _shareTokenExists[shareTokenNumber] = true;

        _shareProposals[shareProposalId].status = Types.ShareProposalStatus.STARTED;
    }

    /// @notice Private function to get the sharde data from the share token contract, 
    ///         and return the revenue deposit delay and if the share is backed by a cHyPC
    ///         Using the specific slot of the `ShareData` struct to initialize the variables
    /// @param shareNumber share number to get the data from
    /// @return revenueDepositDelay delay in seconds to unlock the revenue deposited
    /// @return chypcExists if the share was backed by a HyPC or using a cHyPC NFT
    function _getShareData(uint256 shareNumber) private view returns(uint256 revenueDepositDelay, bool chypcExists) {
        (bool success, bytes memory data) = address(managerData.hypcShareTokens).staticcall(abi.encodeWithSelector(managerData.hypcShareTokens.shareData.selector, shareNumber));
        
        if (!success) revert Errors.GetShareDataFailed();

        assembly {
            revenueDepositDelay := mload(add(data, 0x160))
            chypcExists := mload(add(data, 0x1A0))
        }
    }

    /// @notice Allows an user to claim Hypc tokens, based in the amount of wealth tokens available.
    ///         The Share Proposal needs to be ended and Chypc needs to exists.
    /// @param shareProposalId The share proposal Id to be used to claim the Hypc.
    function claimHypcPortion(uint256 shareProposalId) external {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        if (shareProposal.status != Types.ShareProposalStatus.ENDED) revert Errors.ShareProposalIsNotEnded();

        uint256 userWealthBalance = managerData.hypcShareTokens.balanceOf(
            _msgSender(),
            shareProposal.shareTokenData.wTokenId
        );

        uint256 userVotePower = _votePower[shareProposalId][_msgSender()];

        if (userWealthBalance == 0 && userVotePower == 0) revert Errors.NoWealthTokensAvailable();

        uint256 wealthTokenTotalSupply = managerData.hypcShareTokens.getWealthTokenTotalSupply(
            shareProposal.shareTokenData.shareTokenNumber
        );

        uint256 hypcBacked = 1 << shareProposal.chypcData.tokenLevel;

        uint256 userTransferAmount = (hypcBacked * (userWealthBalance + userVotePower)) / wealthTokenTotalSupply;

        delete _votePower[shareProposalId][_msgSender()];

        if (userWealthBalance > 0) {
            managerData.hypcShareTokens.safeTransferFrom(
                _msgSender(),
                address(this),
                shareProposal.shareTokenData.wTokenId,
                userWealthBalance,
                ''
            );
        }

        if (managerData.hypcToken.balanceOf(address(this)) < userTransferAmount)
            revert Errors.NotEnoughHYPC();

        managerData.hypcToken.transfer(
            _msgSender(),
            userTransferAmount
        );

        emit Events.HypcClaimed(shareProposalId, userTransferAmount);
    }

    /// @notice Allows an user to claim the surplus of a share proposal, the Share Proposal needs to be ended.
    /// @dev    The surplus is the amount of tokens that were locked to increase the hardware operator revenue.
    /// @dev    The amount will be sended to the license owner and the chypc owner.
    /// @param shareProposalId The share proposal Id to be used to claim the surplus amount of tokens.
    function claimSurplus(uint256 shareProposalId) external {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        if (shareProposal.status != Types.ShareProposalStatus.ENDED) revert Errors.ShareProposalIsNotEnded();

        uint256 surplus = shareProposal.hypcSurplus >> 1;
        uint256 surplusRemainder = shareProposal.hypcSurplus - surplus;

        delete shareProposal.hypcSurplus;

        managerData.hypcToken.transfer(shareProposal.chypcData.tokenOwner, surplus);
        managerData.hypcToken.transfer(shareProposal.licenseData.tokenOwner, surplusRemainder);
    }

    /// @notice Private function to end the finish the share proposal
    /// @dev It will send the license only if isn't splittable
    /// @dev It will send the cHyPC only if the token was transfered
    /// @dev It will send the hardware operator revenue only if proposal started
    /// @param shareProposalId The share proposal Id to be used to end the share.
    function _endShareProposal(uint256 shareProposalId) private {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        bool shareProposalStarted = shareProposal.status == Types.ShareProposalStatus.STARTED;

        shareProposal.status = Types.ShareProposalStatus.ENDED;

        if (!shareProposalStarted) {
            managerData.chypcV2.safeTransferFrom(
                address(this),
                shareProposal.chypcData.tokenOwner,
                shareProposal.chypcData.tokenNumber
            );
        } else {
            managerData.licenseContract.safeTransferFrom(
                address(this),
                shareProposal.licenseData.tokenOwner,
                shareProposal.licenseData.tokenNumber
            );

            _sendRevenueToHardwareOperator(shareProposalId);

            managerData.chypcV2.redeem(shareProposal.chypcData.tokenNumber);
        }

        emit Events.ShareProposalEnded(shareProposalId);
    }

    /// @notice Private function that will send the revenue collected to the hardware operator
    /// @param shareProposalId The share proposal Id to be used to get the data
    function _sendRevenueToHardwareOperator(uint256 shareProposalId) private {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        uint256 oldBalance = managerData.hypcToken.balanceOf(address(this));

        try managerData.hypcShareTokens.claimAndWithdraw(shareProposal.shareTokenData.shareTokenNumber) {
            // ...
        } catch (bytes memory err) {
            if (keccak256(abi.encodeWithSignature('NoRevenueToClaim()')) != keccak256(err)) {
                revert(string(err));
            }
        }

        uint256 newBalance = managerData.hypcToken.balanceOf(address(this));
        uint256 amountReceived = newBalance - oldBalance;

        uint256 hardwareOperatorRevenue = (amountReceived * shareProposal.operatorData.operatorRevenue) / (1 << shareProposal.chypcData.tokenLevel) * 3 / 10;

        shareProposal.hypcSurplus += amountReceived - hardwareOperatorRevenue;

        managerData.hypcToken.transfer(shareProposal.operatorData.operatorAddress, hardwareOperatorRevenue);
    }

    // Propose functions

    /// @notice Allows an user to create a new votation and propose a new Hardware Operator.
    /// @param shareProposalId The share proposal Id to be used to create the votation
    /// @param deadline Time to be waited to complete the votation
    /// @param newProposedString the new proposed assigned string for the hardware operator
    /// @param newHardwareOperator the new hardware operator address
    function proposeNewHardwareOperatorAddress(
        uint256 shareProposalId,
        uint256 deadline,
        string memory newProposedString,
        address newHardwareOperator
    ) external onlyVoter(shareProposalId) {
        if (newHardwareOperator == address(0)) revert Errors.InvalidProposedAddress();
        if (deadline <= block.timestamp) revert Errors.InvalidDeadline();

        uint256 votationId = _votationId[shareProposalId];

        _votations[shareProposalId][votationId] = Types.Votation({
            votationId: votationId,
            votesFor: 0,
            votesAgainst: 0,
            deadline: deadline,
            proposedData: abi.encode(newProposedString, newHardwareOperator),
            option: Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS,
            amountReached: false
        });

        _votationId[shareProposalId]++;
        emit Events.VoteStarted(shareProposalId, votationId, Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS);
    }

    /// @notice Allows an user to create a new votation and propose a new Hardware Operator Revenue.
    /// @param shareProposalId The share proposal Id to be used to create the votation
    /// @param deadline Time to be waited to complete the votation
    /// @param newRevenue the new proposed hardware operator revenue
    /// @dev `newRevenue` should be greater or equal than 1/10 of the W Token total supply
    /// @dev `newRevenue` should be less or equal than 3/10 of the W Token total supply
    function proposeNewHardwareOperatorRevenue(
        uint256 shareProposalId,
        uint256 deadline,
        uint256 newRevenue
    ) external onlyVoter(shareProposalId) {
        uint256 revenueTotalSupply = managerData.hypcShareTokens.getRevenueTokenTotalSupply(
            _shareProposals[shareProposalId].shareTokenData.shareTokenNumber
        );

        if (
            newRevenue < revenueTotalSupply / 10 || newRevenue > revenueTotalSupply * 3 / 10
        ) {
            revert Errors.InvalidTokenAmount();
        }

        if (deadline <= block.timestamp) revert Errors.InvalidDeadline();

        uint256 votationId = _votationId[shareProposalId];

        _votations[shareProposalId][votationId] = Types.Votation({
            votationId: votationId,
            votesFor: 0,
            votesAgainst: 0,
            deadline: deadline,
            proposedData: abi.encode(newRevenue),
            option: Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_REVENUE,
            amountReached: false
        });
        _votationId[shareProposalId]++;
        emit Events.VoteStarted(shareProposalId, votationId, Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_REVENUE);
    }

    /// @notice Allows an user to create a new votation and propose a new share manager
    /// @param shareProposalId The share proposal Id to be used to create the votation
    /// @param deadline Time to be waited to complete the votation
    /// @param newShareManager The new share manager address
    function proposeNewManager(
        uint256 shareProposalId,
        uint256 deadline,
        address newShareManager
    ) external onlyVoter(shareProposalId) {
        if (
            newShareManager == address(0) ||
            newShareManager == address(this)
        ) revert Errors.InvalidProposedAddress();
        if (deadline <= block.timestamp) revert Errors.InvalidDeadline();

        uint256 votationId = _votationId[shareProposalId];

        _votations[shareProposalId][votationId] = Types.Votation({
            votationId: votationId,
            votesFor: 0,
            votesAgainst: 0,
            deadline: deadline,
            proposedData: abi.encode(newShareManager),
            option: Types.VotationOptions.CHANGE_MANAGER_CONTRACT,
            amountReached: false
        });

        _votationId[shareProposalId]++;
        emit Events.VoteStarted(shareProposalId, votationId, Types.VotationOptions.CHANGE_MANAGER_CONTRACT);
    }

    function proposeNewDepositRevenueDelay(
        uint256 shareProposalId,
        uint256 deadline,
        uint256 newDepositRevenueDelay
    ) external onlyVoter(shareProposalId) {
        if (newDepositRevenueDelay < 1 days) revert Errors.InvalidDepositRevenueDelay();
        if (deadline <= block.timestamp) revert Errors.InvalidDeadline();

        uint256 votationId = _votationId[shareProposalId];

        _votations[shareProposalId][votationId] = Types.Votation({
            votationId: votationId,
            votesFor: 0,
            votesAgainst: 0,
            deadline: deadline,
            proposedData: abi.encode(newDepositRevenueDelay),
            option: Types.VotationOptions.CHANGE_DEPOSIT_REVENUE_DELAY,
            amountReached: false
        });

        _votationId[shareProposalId]++;
        emit Events.VoteStarted(shareProposalId, votationId, Types.VotationOptions.CHANGE_DEPOSIT_REVENUE_DELAY);
    }

    // Votation functions

    /// @notice Function to execute or finish a votation, only able to vote if user increase the vote power
    /// @param shareProposalId Share Proposal Id to get the votations
    /// @param votationIndex Index of the votation to vote
    /// @param voteFor If true will increase the votes to execute the votation, otherwise will increase the votes to finish it.
    function vote(uint256 shareProposalId, uint256 votationIndex, bool voteFor) external onlyVoter(shareProposalId) {
        Types.Votation storage votation = _votations[shareProposalId][votationIndex];

        if (_shareProposals[shareProposalId].status == Types.ShareProposalStatus.ENDED)
            revert Errors.ShareTokenIsNotActive();

        if (votation.votationId == 0 && votationIndex != 0) revert Errors.InvalidVotationOption();

        if (votation.amountReached) revert Errors.VotationAmountReached();

        if (block.timestamp > votation.deadline) revert Errors.VotationDeadlineReached();

        if (_voted[shareProposalId][votation.votationId][_msgSender()]) revert Errors.ParticipantAlreadyVote();

        _voted[shareProposalId][votation.votationId][_msgSender()] = true;

        uint256 votePower = _votePower[shareProposalId][_msgSender()];

        voteFor ? votation.votesFor += votePower : votation.votesAgainst += votePower;

        uint256 wealthTokenSupply = managerData.hypcShareTokens.getWealthTokenTotalSupply(
            _shareProposals[shareProposalId].shareTokenData.shareTokenNumber
        );

        if (
            votation.option == Types.VotationOptions.CANCEL_SHARE ||
            votation.option == Types.VotationOptions.CHANGE_MANAGER_CONTRACT
        ) {
            if (
                votation.votesFor >= wealthTokenSupply * SELECTED_VOTATION_PERCENT / ONE_HUNDRED_PERCENT
            ) {
                votation.amountReached = true;
            }
        } else {
            if (
                (voteFor ? votation.votesFor : votation.votesAgainst) > (wealthTokenSupply >> 1) * SELECTED_VOTATION_PERCENT / ONE_HUNDRED_PERCENT
            ) {
                votation.amountReached = true;
            }
        }

        if (votation.amountReached) {
            if(voteFor) {
                _executeVotationAction(shareProposalId, votationIndex);
            }
            emit Events.VotationEnded(shareProposalId, votationIndex, voteFor);
        }

        emit Events.VoteEmmited(shareProposalId, _msgSender(), votationIndex);
    }

    /// @notice Increase the caller votation power, transfering the wealth tokens from the user to the contract
    /// @param shareProposalId Id of the Share Proposal to increase the vote power
    function increaseVotePower(uint256 shareProposalId) external {
        Types.ShareTokenData storage shareTokenData = _shareProposals[shareProposalId].shareTokenData;

        uint256 balance = managerData.hypcShareTokens.balanceOf(_msgSender(), shareTokenData.wTokenId);

        if (balance == 0) revert Errors.NoWealthTokensAvailable();

        managerData.hypcShareTokens.safeTransferFrom(_msgSender(), address(this), shareTokenData.wTokenId, balance, '');

        _votePower[shareProposalId][_msgSender()] += balance;
    }

    /// @notice Decrease the caller votation power, transfering the wealth tokens from the contract to the user
    /// @param shareProposalId Id of the Share Proposal to decrease the vote power
    function decreaseVotePower(uint256 shareProposalId) external {
        if (_shareProposals[shareProposalId].status == Types.ShareProposalStatus.ENDED)
            revert Errors.ShareTokenIsNotActive();

        Types.ShareTokenData storage shareTokenData = _shareProposals[shareProposalId].shareTokenData;

        uint256 balance = _votePower[shareProposalId][_msgSender()];

        delete _votePower[shareProposalId][_msgSender()];

        managerData.hypcShareTokens.safeTransferFrom(address(this), _msgSender(), shareTokenData.wTokenId, balance, '');
    }

    // Votation Actions

    /// Private function that will execute the votations actions based on the votation type
    /// @param shareProposalId Id of the Share Proposal to execute the action
    /// @param votationIndex Index of the votation to execute the action
    /// @dev If `votationIndex` is zero the proposal will be cancelled
    function _executeVotationAction(uint256 shareProposalId, uint256 votationIndex) private {
        Types.VotationOptions votationOption = _votations[shareProposalId][votationIndex].option;

        if (votationOption == Types.VotationOptions.CANCEL_SHARE) {
            _cancelShareProposal(shareProposalId);
        }

        if (votationOption == Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS) {
            _changeHardwareOperatorAddress(shareProposalId, votationIndex);
        }

        if (votationOption == Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_REVENUE) {
            _changeHardwareOperatorRevenue(shareProposalId, votationIndex);
        }

        if (votationOption == Types.VotationOptions.CHANGE_MANAGER_CONTRACT) {
            _changeShareManagerContract(shareProposalId, votationIndex);
        }

        if (votationOption == Types.VotationOptions.CHANGE_DEPOSIT_REVENUE_DELAY) {
            _changeDepositRevenueDelay(shareProposalId, votationIndex);
        }
    }

    /// Private function that will execute the cancel action
    /// @param shareProposalId Id of the Share Proposal to be cancelled
    function _cancelShareProposal(uint256 shareProposalId) private {
        if (_shareProposals[shareProposalId].shareTokenData.validEndTimestamp > block.timestamp)
            revert Errors.ShareProposalEndTimeNotReached();

        managerData.hypcShareTokens.cancelShareTokens(_shareProposals[shareProposalId].shareTokenData.shareTokenNumber);

        _endShareProposal(shareProposalId);

        emit Events.VoteActionExecuted(shareProposalId, Types.VotationOptions.CANCEL_SHARE);
    }

    /// Private function that will execute the change hardware operator action
    /// @param shareProposalId Id of the Share Proposal to be changed
    /// @param votationIndex Index of the votation to execute
    function _changeHardwareOperatorAddress(uint256 shareProposalId, uint256 votationIndex) private {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        _sendRevenueToHardwareOperator(shareProposalId);

        (string memory newHardwareOperatorString, address newHardwareOperatorAddress) = abi.decode(
            _votations[shareProposalId][votationIndex].proposedData,
            (string, address)
        );

        shareProposal.operatorData.operatorAddress = newHardwareOperatorAddress;
        shareProposal.operatorData.operatorAssignedString = newHardwareOperatorString;

        managerData.hypcShareTokens.setShareMessage(
            shareProposal.shareTokenData.shareTokenNumber,
            shareProposal.operatorData.operatorAssignedString
        );

        emit Events.VoteActionExecuted(shareProposalId, Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS);
    }

    /// Private function that will execute the change hardware operator revenue action
    /// @param shareProposalId Id of the Share Proposal to be changed
    /// @param votationIndex Index of the votation to execute
    function _changeHardwareOperatorRevenue(uint256 shareProposalId, uint256 votationIndex) private {

        _shareProposals[shareProposalId].operatorData.operatorRevenue = abi.decode(_votations[shareProposalId][votationIndex].proposedData, (uint256));

        emit Events.VoteActionExecuted(shareProposalId, Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_REVENUE);
    }

    /// Private function that will execute the change share manager action
    /// @param shareProposalId Id of the Share Proposal to be changed
    /// @param votationIndex Index of the votation to execute
    /// @dev The share proposal will be ended afterward
    function _changeShareManagerContract(uint256 shareProposalId, uint256 votationIndex) private {
        Types.ShareProposalData storage shareProposal = _shareProposals[shareProposalId];

        shareProposal.status = Types.ShareProposalStatus.ENDED;

        address newManager = abi.decode(_votations[shareProposalId][votationIndex].proposedData, (address));

        managerData.hypcShareTokens.transferShareOwnership(shareProposal.shareTokenData.shareTokenNumber, newManager);

        _sendRevenueToHardwareOperator(shareProposalId);

        _sendRevenueAndWealthTokens(
            newManager,
            shareProposal.shareTokenData.rTokenId,
            shareProposal.shareTokenData.wTokenId,
            managerData.hypcShareTokens.balanceOf(
                address(this),
                shareProposal.shareTokenData.rTokenId
            ),
            managerData.hypcShareTokens.balanceOf(
                address(this),
                shareProposal.shareTokenData.wTokenId
            )
        );

        emit Events.VoteActionExecuted(shareProposalId, Types.VotationOptions.CHANGE_MANAGER_CONTRACT);
    }

    /// Private function that will execute the change deposit revenue delay
    /// @param shareProposalId Id of the Share Proposal to be changed
    /// @param votationIndex Index of the votation to execute
    function _changeDepositRevenueDelay(uint256 shareProposalId, uint256 votationIndex) private {

        _shareProposals[shareProposalId].shareTokenData.revenueDepositDelay = abi.decode(_votations[shareProposalId][votationIndex].proposedData, (uint256));

        managerData.hypcShareTokens.changePendingRevenueDelay(
            _shareProposals[shareProposalId].shareTokenData.shareTokenNumber,
            _shareProposals[shareProposalId].shareTokenData.revenueDepositDelay
        );

        emit Events.VoteActionExecuted(shareProposalId, Types.VotationOptions.CHANGE_DEPOSIT_REVENUE_DELAY);
    }

    // Get functions

    // ManagerData getters

    /// @notice Get the setted swap V2 contract
    /// @return Swap V2 contract address
    function getCHYPC() external view returns (address) {
        return address(managerData.chypcV2);
    }

    /// @notice Get the setted License contract
    /// @return License contract address
    function getLicenseContract() external view returns (address) {
        return address(managerData.licenseContract);
    }

    /// @notice Get the setted HyperCycle Share Token contract
    /// @return HyperCycle Share Token contract address
    function getHypcShareTokenContract() external view returns (address) {
        return address(managerData.hypcShareTokens);
    }

    /// @notice Get the setted HyperCycle Token contract
    /// @return HyperCycle ERC 20 token
    function getHypcToken() external view returns (address) {
        return address(managerData.hypcToken);
    }

    // ShareProposalData getters

    /// @notice Get the data of a selected share proposal
    /// @param shareProposalId Id of the Share Proposal
    /// @return Share Proposal Data
    function getShareProposalData(uint256 shareProposalId) external view returns (Types.ShareProposalData memory) {
        return _shareProposals[shareProposalId];
    }

    /// @notice Get the status of a selected share proposal
    /// @param shareProposalId Id of the share proposal
    /// @return Share proposal status
    function getShareProposalStatus(uint256 shareProposalId) external view returns (Types.ShareProposalStatus) {
        return _shareProposals[shareProposalId].status;
    }
    
    /// @notice Get the revenue deposit delay of a selected share proposal
    /// @param shareProposalId Id of the share proposal
    /// @return Revenue deposit delay
    function getRevenueDelay(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].shareTokenData.revenueDepositDelay;
    }

    /// @notice Get the actual Hardware Operator Revenue of a selected share proposal
    /// @param shareProposalId Id of the share proposal
    /// @return Hardware Operator Revenue
    function getShareProposalHardwareOperatorRevenue(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].operatorData.operatorRevenue;
    }

    /// @notice Get the License token id
    /// @param shareProposalId Id of the share proposal
    /// @return License token id
    function getShareProposalLicenseNumber(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].licenseData.tokenNumber;
    }

    /// @notice Get the License Owner
    /// @param shareProposalId Id of the share proposal
    /// @return License Owner
    function getShareProposalLicenseOwner(uint256 shareProposalId) external view returns (address) {
        return _shareProposals[shareProposalId].licenseData.tokenOwner;
    }

    /// @notice Get the License Level
    /// @param shareProposalId Id of the share proposal
    /// @return License level
    function getShareProposalLicenseLevel(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].licenseData.tokenLevel;
    }

    /// @notice Get the cHyPc token id
    /// @param shareProposalId Id of the share proposal
    /// @return cHyPc token id
    function getShareProposalCHYPCNumber(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].chypcData.tokenNumber;
    }

    /// @notice Get the cHyPc owner
    /// @param shareProposalId Id of the share proposal
    /// @return cHyPc owner
    function getShareProposalCHYPCOwner(uint256 shareProposalId) external view returns (address) {
        return _shareProposals[shareProposalId].chypcData.tokenOwner;
    }

    /// @notice Get the cHyPc level
    /// @param shareProposalId Id of the share proposal
    /// @return cHyPc level
    function getShareProposalCHYPCLevel(uint256 shareProposalId) external view returns (uint256) {
        return _shareProposals[shareProposalId].chypcData.tokenLevel;
    }

    /// @notice Get the Hardware Operator address
    /// @param shareProposalId Id of the share proposal
    /// @return Hardware Operator address
    function getShareProposalHardwareOperator(uint256 shareProposalId) external view returns (address) {
        return _shareProposals[shareProposalId].operatorData.operatorAddress;
    }

    // NewProposedShareData getters

    /// @notice Get the proposed hardware operator address
    /// @dev Should revert if the votation option isn't the expected
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return operator proposed hardware operator
    function getProposedHardwareOperatorAddress(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (address operator) {
        if (
            _votations[shareProposalId][votationIndex].option != Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS
        ) {
            revert Errors.InvalidVotationOption();
        }
        (, operator) = abi.decode(_votations[shareProposalId][votationIndex].proposedData, (string, address));
    }

    /// @notice Get the proposed hardware operator revenue
    /// @dev Should revert if the votation option isn't the expected
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return Proposed hardware operator revenue
    function getProposedHardwareOperatorRevenue(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (uint256) {
        if (
            _votations[shareProposalId][votationIndex].option != Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_REVENUE
        ) {
            revert Errors.InvalidVotationOption();
        }
        return abi.decode(_votations[shareProposalId][votationIndex].proposedData, (uint256));
    }

    /// @notice Get the proposed revenue deposit delay
    /// @dev Should revert if the votation option isn't the expected
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return Proposed revenue deposit delay
    function getProposedDepositRevenueDelay(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (uint256) {
        if (
            _votations[shareProposalId][votationIndex].option != Types.VotationOptions.CHANGE_DEPOSIT_REVENUE_DELAY
        ) {
            revert Errors.InvalidVotationOption();
        }
        return abi.decode(_votations[shareProposalId][votationIndex].proposedData, (uint256));
    }

    /// @notice Get the proposed hardware operator string
    /// @dev Should revert if the votation option isn't the expected
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return proposedString proposed hardware operator string
    function getProposedNewShareMessage(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (string memory proposedString) {
        if (
            _votations[shareProposalId][votationIndex].option != Types.VotationOptions.CHANGE_HARDWARE_OPERATOR_ADDRESS
        ) {
            revert Errors.InvalidVotationOption();
        }
        (proposedString, ) = abi.decode(_votations[shareProposalId][votationIndex].proposedData, (string, address));
    }

    // Votation getters

    /// @notice Get the amount of votes on behalf to execute the votation
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return Amount of votes
    function getShareProposalVotationVotesFor(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (uint256) {
        return _votations[shareProposalId][votationIndex].votesFor;
    }

    /// @notice Get the amount of votes against execute the votation
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return Amount of votes
    function getShareProposalVotationVotesAgainst(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (uint256) {
        return _votations[shareProposalId][votationIndex].votesAgainst;
    }

    /// @notice Get the amount of votes needed to execute or finish the votation
    /// @return Votes needed
    function getVotationConsensus(uint256 shareProposalId, Types.VotationOptions votationOption) external view returns (uint256) {
        uint256 totalSupply = managerData.hypcShareTokens.getWealthTokenTotalSupply(
            _shareProposals[shareProposalId].shareTokenData.shareTokenNumber
        );
        if (votationOption == Types.VotationOptions.CANCEL_SHARE || votationOption == Types.VotationOptions.CHANGE_MANAGER_CONTRACT) {
            return totalSupply * SELECTED_VOTATION_PERCENT / ONE_HUNDRED_PERCENT;
        } else {
            return (totalSupply >> 1) * SELECTED_VOTATION_PERCENT / ONE_HUNDRED_PERCENT;
        }
    }

    /// @notice Get if the votation amount was reached to execute or finish it
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return If votation amount was reached
    function getShareProposalVotationAmountReached(
        uint256 shareProposalId,
        uint256 votationIndex
    ) external view returns (bool) {
        return _votations[shareProposalId][votationIndex].amountReached;
    }

    /// @notice Get if a selected address has voted in a specific votation
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @param voter address of the voter to check
    /// @return If voter has voted
    function getUserVote(uint256 shareProposalId, uint256 votationIndex, address voter) external view returns (bool) {
        return _voted[shareProposalId][votationIndex][voter];
    }

    /// @notice Get the vote power a voter has
    /// @param shareProposalId Id of the share proposal
    /// @param voter address of the voter to check
    /// @return Vote power
    function getVotePower(uint256 shareProposalId, address voter) external view returns (uint256) {
        return _votePower[shareProposalId][voter];
    }

    /// @notice Get the amount of votations a share proposal has
    /// @param shareProposalId Id of the share proposal
    /// @return Amount of votations
    function getVotationsAmount(uint256 shareProposalId) external view returns (uint256) {
        return _votationId[shareProposalId];
    }

    /// @notice Get the votation data
    /// @param shareProposalId Id of the share proposal
    /// @param votationIndex Index of the votation
    /// @return Votation data
    function getVotationData(
        uint256 shareProposalId,
        uint256 votationIndex,
        address voter
    ) external view returns (Types.Votation memory, bool) {
        return (
            _votations[shareProposalId][votationIndex],
            _voted[shareProposalId][votationIndex][voter]
        );
    }
}


// File: contracts/ethereum/interfaces/IHYPC.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @notice Interface for the HyperCycleToken.sol contract.
interface IHYPC is IERC20 {
    /*
     * Accesses the ERC20 functions of the HYPC contract. The burn function
     * is also exposed for future contracts.
    */
    /// @notice Burns an amount of the HyPC ERC20.
    function burn(uint256 amount) external;
}


// File: contracts/ethereum/interfaces/IHYPCSwapV2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts/interfaces/IERC721.sol";

/// @notice Interface for the HYPCSwap.sol contract.
interface IHYPCSwapV2 is IERC721 {
    /**
     * Accesses the addNFT function so that the CHYPC contract can
     * add the newly created NFT into this contract.
     */

    function addRootTokens(uint256 tokens) external;

    function splitHeldToken(uint256 level, uint256 skipLevels) external;

    function swapV2(uint256 level) external;

    function redeem(uint256 tokenNumber) external;

    function assignNumber(uint256 tokenNumber, uint256 targetNumber) external;

    function assignString(uint256 tokenNumber, string memory data) external;

    function burn(uint256 tokenNumber, string memory data) external;

    function assign(uint256 tokenNumber, string memory data) external;

    function swap() external;


    function getAssignment(uint256 tokenNumber) external view returns (string memory);
    function getAssignmentNumber(uint256 tokenNumber) external view returns (uint256);
    function getAssignmentString(uint256 tokenNumber) external view returns (string memory);



    function getBurnData(uint256 tokenNumber) external view returns (string memory);

    function getAvailableToken(uint256 level, uint256 index) external view returns (uint256);

    function getTokenLevel(uint256 tokenNumber) external view returns (uint256);

    function getAssignmentTargetNumber(uint256 targetNumber) external view returns (uint256);
}


// File: contracts/ethereum/interfaces/IHyperCycleLicense.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

/// @notice Interface for the CHYPC.sol contract.
interface IHyperCycleLicense is IERC721 {
    /**
     * Accesses the assignment function of c_HyPC so the swap can remove 
     * the assignment data when a token is redeemed or swapped.
     */
    /// @notice Creates a new root token inside this contract, with a specified licenseID.
    function mint(
        uint256 numTokens
    ) external;

    /// @notice Splits a given token into two new tokens, with corresponding licenseID's.
    function split(
        uint256 tokenId
    ) external;

    /// @notice Burns a given tokenId with a specified burn string.
    function burn(
        uint256 tokenId,
        string memory burnString          
    ) external;

    /// @notice Merges together two child licenses into a parent license.
    function merge(
        uint256 tokenId
    ) external;

    /// @notice Returns the burn data from the given tokenId.
    function getBurnData(
        uint256 tokenId
    ) external view returns (string memory);

    /// @notice Returns the license height of the given tokenId.
    function getLicenseHeight(
        uint256 licenseId
    ) external view returns (uint8);

    /// @notice Returns the license height of the given tokenId.
    function getLicenseStatus(
        uint256 licenseId
    ) external view returns (uint256);
}


// File: contracts/ethereum/interfaces/IHyperCycleShareTokensV2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';

/// @notice Interface for the HyperCycleShareTokens.sol contract.
interface IHyperCycleShareTokensV2 is IERC1155 {
    struct PendingDeposit {
        uint256 availableAtTimestamp;
        uint256 amount;
    }

    function shareData(
        uint256 shareNumber
    )
        external
        pure
        returns (
            uint256 licenseId,
            uint256 chypcId,
            uint256 status,
            address owner,
            uint256 rTokenNumber,
            uint256 wTokenNumber,
            uint256 rTokenSupply,
            uint256 wTokenSupply,
            uint256 startTimestamp,
            uint256 revenueDeposited,
            uint256 revenueDepositDelay,
            string memory message,
            bool chypcTokenHeld
        );

    function currentShareNumber() external returns (uint256);

    function increaseShareLimit(uint256 number) external;

    function createShareTokens(
        uint256 licenseNumber,
        uint256 chypcNumber,
        bool chypcTokenHeld,
        string memory startingMessage,
        uint256 maxRevenueDeposit
    ) external;

    function changePendingRevenueDelay(uint256 shareNumber, uint256 newDelay) external;

    function transferShareOwnership(uint256 shareNumber, address to) external;

    function cancelShareTokens(uint256 shareNumber) external;

    function depositRevenue(uint256 shareNumber, uint256 amt) external;

    function claimRevenue(uint256 shareNumber) external;

    function withdrawEarnings(uint256 shareNumber) external;

    function claimAndWithdraw(uint256 shareNumber) external;

    function setShareMessage(uint256 shareNumber, string memory message) external;

    function burnRevenueTokens(uint256 shareNumber, uint256 amount) external;

    function burnWealthTokens(uint256 shareNumber, uint256 amount) external;

    function getShareLicenseId(uint256 shareNumber) external view returns (uint256);

    function getShareCHyPCId(uint256 shareNumber) external view returns (uint256);

    function getShareOwner(uint256 shareNumber) external view returns (address);

    function getShareRevenueTokenId(uint256 shareNumber) external view returns (uint256);

    function getShareWealthTokenId(uint256 shareNumber) external view returns (uint256);

    function getShareTotalRevenue(uint256 shareNumber) external view returns (uint256);

    function getShareStartTime(uint256 shareNumber) external view returns (uint256);

    function getShareMessage(uint256 shareNumber) external view returns (string memory);

    function isShareActive(uint256 shareNumber) external view returns (bool);

    function shareCreated(uint256 shareNumber) external view returns (bool);

    function getRevenueTokenTotalSupply(uint256 shareNumber) external view returns (uint256);

    function getWealthTokenTotalSupply(uint256 shareNumber) external view returns (uint256);

    function getPendingDeposit(uint256 shareNumber, uint256 index) external view returns (PendingDeposit memory);

    function getPendingDepositsLength(uint256 shareNumber) external view returns (uint256);
}


// File: contracts/ethereum/libs/ShareManagerErrors.sol
// SPDX-License-Identifier: MIT
/*
    Share Manager Errors
*/

pragma solidity 0.8.19;

library ShareManagerErrors {
    error ShareProposalIsNotPending();

    error ShareProposalIsNotEnded();

    error ShareProposalEndTimeNotReached();

    error InvalidProposedAddress();

    error InvalidHYPCTokenAddress();

    error InvalidCHYPCAddress();

    error InvalidCHYPCOwner();

    error InvalidTokenAmount();

    error InvalidShareTokenContract();

    error InvalidProposedString();

    error InvalidLicenseAddress();

    error InvalidLicenseOwner();

    error InvalidVotationOption();

    error InvalidDeadline();

    error ChypcIsNotHeld();

    error ParticipantAlreadyVote();

    error NoWealthTokensAvailable();

    error VotationAmountReached();

    error VotationDeadlineReached();

    error TokenLevelMismatch();

    error ShareTokenAlreadyExists();

    error InvalidShareTokenOwner();

    error GetShareDataFailed();

    error ShareTokenIsNotActive();

    error NotEnoughHYPC();

    error InvalidDepositRevenueDelay();
}


// File: contracts/ethereum/libs/ShareManagerEvents.sol
// SPDX-License-Identifier: MIT
/*
    Share Manager Events
*/

pragma solidity 0.8.19;

import {ShareManagerTypes} from './ShareManagerTypes.sol';

library ShareManagerEvents {
    event ShareProposalCreated(uint256 shareProposalId);

    event ShareProposalStarted(uint256 shareProposalId);

    event ShareProposalEnded(uint256 shareProposalId);

    event HypcClaimed(uint256 shareProposalId, uint256 hypcClaimed);

    event VoteStarted(uint256 shareProposalId, uint256 votationIndex, ShareManagerTypes.VotationOptions selectedOption);

    event VoteActionExecuted(uint256 shareProposalId, ShareManagerTypes.VotationOptions selectedOption);

    event VoteEmmited(uint256 shareProposalId, address voter, uint256 votationIndex);

    event VotationEnded(uint256 shareProposalId, uint256 votationIndex, bool voteForWinner);
}


// File: contracts/ethereum/libs/ShareManagerTypes.sol
// SPDX-License-Identifier: MIT
/*
    Share Manager Types
*/

pragma solidity 0.8.19;

import {IHYPCSwapV2} from '../interfaces/IHYPCSwapV2.sol';
import {IHyperCycleLicense} from '../interfaces/IHyperCycleLicense.sol';
import {IHyperCycleShareTokensV2} from '../interfaces/IHyperCycleShareTokensV2.sol';
import {IHYPC} from '../interfaces/IHYPC.sol';

library ShareManagerTypes {
    enum ShareProposalStatus {
        NOT_CREATED,
        PENDING,
        STARTED,
        ENDED
    }

    enum VotationOptions {
        CANCEL_SHARE,
        CHANGE_HARDWARE_OPERATOR_ADDRESS,
        CHANGE_HARDWARE_OPERATOR_REVENUE,
        CHANGE_MANAGER_CONTRACT,
        CHANGE_DEPOSIT_REVENUE_DELAY
    }

    enum ConsensusOptions {
        ONE_HUNDRED_PERCENT,
        NINETY_PERCENT
    }

    struct ManagerData {
        IHYPC hypcToken;
        IHYPCSwapV2 chypcV2;
        IHyperCycleLicense licenseContract;
        IHyperCycleShareTokensV2 hypcShareTokens;
    }

    struct ShareProposalData {
        ShareTokenData shareTokenData;
        TokenHolderData licenseData;
        TokenHolderData chypcData;
        HardwareOperatorData operatorData;
        ShareProposalStatus status;
        uint256 hypcSurplus;
    }

    struct ShareTokenData {
        uint256 validEndTimestamp;
        uint256 shareTokenNumber;
        uint256 rTokenId;
        uint256 wTokenId;
        uint256 revenueDepositDelay;
    }

    struct TokenHolderData {
        uint256 tokenNumber;
        uint256 tokenLevel;
        uint256 initialRevenueTokens;
        uint256 initialWealthTokens;
        address tokenOwner;
    }

    struct HardwareOperatorData {
        uint256 operatorRevenue;
        string operatorAssignedString;
        address operatorAddress;
    }

    struct Votation {
        uint256 votationId;
        uint256 votesFor;
        uint256 votesAgainst;
        uint256 deadline;
        bytes proposedData;
        VotationOptions option;
        bool amountReached;
    }

    struct ShareData {
        uint256 licenseId;
        uint256 chypcId;
        uint256 status;
        address owner;
        uint256 rTokenNumber;
        uint256 wTokenNumber;
        uint256 rTokenSupply;
        uint256 wTokenSupply;
        uint256 startTimestamp;
        uint256 revenueDeposited;
        uint256 revenueDepositDelay;
        string message;
        bool chypcTokenHeld;
    }
}

