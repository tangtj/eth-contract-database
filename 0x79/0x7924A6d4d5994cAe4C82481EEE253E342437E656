{"InsuranceDeclaration.sol":{"content":"// SPDX-License-Identifier: --ðŸ¦‰--\n\npragma solidity ^0.8.0;\n\nimport \u0027./WiseTokenInterface.sol\u0027;\n\ninterface UniswapRouter {\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (\n        uint[] memory amounts\n    );\n}\n\ncontract InsuranceDeclaration {\n\n    WiseTokenInterface public immutable WISE_CONTRACT;\n    UniswapRouter public immutable UNISWAP_ROUTER;\n\n    address constant wiseToken =\n    0x66a0f676479Cee1d7373f3DC2e2952778BfF5bd6;\n\n    address constant uniswapRouter =\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    address public constant WETH =\n    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n\n    // tracking state variables - cannot be changed by master\n    uint256 public totalStaked; // - just to track amount of total tokens staked\n    uint256 public totalCovers; // - amount of tokens we need to cover\n    uint256 public totalBufferStaked;  // - to track amount of tokens dedicated to buffer stakes\n    uint256 public totalPublicDebth;   // - amount of tokens we own to public contributors\n    uint256 public totalPublicRewards; // - amount of token we allocate to public payouts (to public contribs)\n    uint256 public totalMasterProfits; // - tracking profits for the master, to know how much can be taken\n\n    uint256 public teamContribution; // initial funding from the team\n\n    // threshold for opening new stakes - can be adjusted by master\n    uint256 public coverageThreshold;\n\n    // threshold for profit payouts - can be adjusted by master\n    uint256 public payoutThreshold;\n\n    // threshold for getting staked amount back - can be adjusted by master\n    uint256 public penaltyThresholdA;\n    uint256 public penaltyThresholdB;\n\n    // threshold for getting staked amount back - can be adjusted by master\n    uint256 public penaltyA;\n    uint256 public penaltyB;\n\n    // % amount to be staked when opening insurance stake - can be adjusted by master\n    uint256 public stakePercent;\n\n    // % amount to return from principal when closing stake - can be adjusted by master\n    uint256 public principalCut; // (0%-10%)\n\n    // % amount to return from interest when closing stake - can be adjusted by master\n    uint256 public interestCut; // (0%-10%)\n\n    // % amount to return for public investor - can be adjusted by master\n    uint256 public publicRewardPercent;\n\n    // cap for public contributions\n    uint256 public publicDebthCap;\n\n    // cap for buffer staking total amount - can be adjusted by master\n    uint256 public bufferStakeCap;\n\n    // ability to control maximum buffer stake duration - can be adjusted by master\n    uint256 public maximumBufferStakeDuration;\n\n    // ability to purchase insurancce - can be switched by master\n    bool public allowInsurance;\n\n    // ability to fund treasury from outside - can be switched by master\n    bool public allowPublicContributions;\n\n    // ability to reroute buffer stake interest as developer funds - can be switched by master\n    bool public getBufferStakeInterest;\n\n    uint256 constant MAX_STAKE_DAYS = 1095; // constant cannot be adjusted 3 years\n\n    address payable public insuranceMaster; // master is a MultiSigWallet\n    address payable public insuranceWorker; // worker can be defined by master\n\n    struct InsuranceStake {\n        bytes16 stakeID;\n        uint256 bufferAmount;\n        uint256 stakedAmount;\n        uint256 matureAmount;\n        uint256 emergencyAmount;\n        address currentOwner;\n        bool isActive;\n    }\n\n    struct BufferStake {\n        uint256 stakedAmount;\n        bytes16 stakeID;\n        bool isActive;\n    }\n\n    struct OwnerlessStake {\n        uint256 stakeIndex;\n        address originalOwner;\n    }\n\n    uint256 public bufferStakeCount;\n    uint256 public ownerlessStakeCount;\n    uint256 public insuranceStakeCount;\n\n    uint256 public activeInsuranceStakeCount;\n    uint256 public activeOwnerlessStakeCount;\n    uint256 public activeBufferStakeCount;\n\n    mapping (address =\u003e uint256) public insuranceStakeCounts;\n    mapping (address =\u003e mapping(uint256 =\u003e InsuranceStake)) public insuranceStakes;\n\n    mapping (uint256 =\u003e BufferStake) public bufferStakes;\n    mapping (uint256 =\u003e OwnerlessStake) public ownerlessStakes;\n\n    // tracking individual public debth to contributor\n    mapping (address =\u003e uint256) public publicReward;\n\n    modifier onlyMaster() {\n        require(\n            msg.sender == insuranceMaster,\n            \u0027WiseInsurance: not an agent\u0027\n        );\n        _;\n    }\n\n    modifier onlyWorker() {\n        require(\n            msg.sender == insuranceWorker,\n            \u0027WiseInsurance: not a worker\u0027\n        );\n        _;\n    }\n\n    event TreasuryFunded(\n        uint256 amount,\n        address funder,\n        uint256 total\n    );\n\n    event InsurancStakeOpened(\n        bytes16 indexed stakeID,\n        uint256 stakedAmount,\n        uint256 returnAmount,\n        address indexed originalOwner,\n        uint256 indexed stakeIndex,\n        bytes16 referralID\n    );\n\n    event EmergencyExitStake(\n        address indexed stakeOwner,\n        uint256 indexed stakeIndex,\n        bytes16 indexed stakeID,\n        uint256 returnAfterFee,\n        uint256 returnAmount,\n        uint64 currentWiseDay\n    );\n\n    event NewOwnerlessStake(\n        uint256 indexed ownerlessIndex,\n        uint256 indexed stakeIndex,\n        address indexed stakeOwner\n    );\n\n    event InsuranceStakeClosed(\n        address indexed staker,\n        uint256 indexed stakeIndex,\n        bytes16 indexed stakeID,\n        uint256 returnAmount,\n        uint256 rewardAfterFee\n    );\n\n    event OwnerlessStakeClosed(\n        uint256 ownerlessIndex,\n        address indexed staker,\n        uint256 indexed stakeIndex,\n        bytes16 indexed stakeID,\n        uint256 stakedAmount,\n        uint256 rewardAmount\n    );\n\n    event BufferStakeOpened(\n        bytes16 indexed stakeID,\n        uint256 stakedAmount,\n        bytes16 indexed referralID\n    );\n\n    event BufferStakeClosed(\n        bytes16 indexed stakeID,\n        uint256 stakedAmount,\n        uint256 rewardAmount\n    );\n\n    event PublicContributionsOpened(\n        bool indexed status\n    );\n\n    event PublicProfit(\n        address indexed contributor,\n        uint256 amount,\n        uint256 publicDebth,\n        uint256 publicRewards\n    );\n\n    event ProfitsTaken(\n        uint256 profitAmount,\n        uint256 remainingBuffer\n    );\n\n    event publicRewardsGiven(\n        uint256 rewardAmount,\n        uint256 totalPublicDebth,\n        uint256 totalPublicRewards\n    );\n\n    event DeveloperFundsRouted(\n        uint256 fundsAmount\n    );\n\n    event checkStake(\n        uint256 startDay,\n        uint256 lockDays,\n        uint256 finalDay,\n        uint256 closeDay,\n        uint256 scrapeDay,\n        uint256 stakedAmount,\n        uint256 stakesShares,\n        uint256 rewardAmount,\n        uint256 penaltyAmount,\n        bool isActive,\n        bool isMature\n    );\n\n    constructor() {\n\n        WISE_CONTRACT = WiseTokenInterface(\n            wiseToken\n        );\n\n        UNISWAP_ROUTER = UniswapRouter(\n            uniswapRouter\n        );\n\n        stakePercent = 90;\n        payoutThreshold = 10;\n        coverageThreshold = 3;\n\n        penaltyThresholdA = 0;\n        penaltyThresholdB = 0;\n\n        penaltyA = 0;\n        penaltyB = 0;\n\n        insuranceMaster = payable(0xfEc4264F728C056bD528E9e012cf4D943bd92b53);\n        insuranceWorker = payable(0x9404f4B0846A2cD5c659c1edD52BA60abF1F10F4);\n\n        allowInsurance = true;\n    }\n\n    address ZERO_ADDRESS = address(0x0);\n\n    string TRANSFER_FAILED = \u0027WiseInsurance: transfer failed\u0027;\n\n    string NOT_YOUR_STAKE = \u0027WiseInsurance: stake ownership already renounced\u0027;\n    string NOT_MATURE_STAKE = \u0027WiseInsurance: stake is not mature\u0027;\n    string NOT_ACTIVE_STAKE = \u0027WiseInsurance: stake already closed\u0027;\n    string NOT_OWNERLESS_STAKE = \u0027WiseInsurance: stake is not ownerless\u0027;\n\n    string MATURED_STAKE = \u0027WiseInsurance: stake already matured\u0027;\n    string BELOW_COVERAGE_THRESHOLD = \u0027WiseInsurance: below coverage threshold\u0027;\n    string BELOW_PAYOUT_THRESHOLD = \u0027WiseInsurance: below payout threshold\u0027;\n    string PUBLIC_CONTRIBUTIONS_DISABLED = \u0027WiseInsurance: public contributions closed\u0027;\n    string DECREASE_STAKE_DURATION = \u0027WiseInsurance: lockDays exceeded\u0027;\n    string INSURANCE_DISABLED = \u0027WiseInsurance: disabled\u0027;\n    string NO_REWARD_FOR_CONTRIBUTOR = \u0027WiseInsurance: no rewards for contributor\u0027;\n    string NO_PUBLIC_DEBTH = \u0027WiseInsurance: no public debth\u0027;\n    string NO_PUBLIC_REWARD_AVAILABLE = \u0027WiseInsurance: no rewards in public pot\u0027;\n    string EXCEEDING_PUBLIC_DEBTH_CAP = \u0027WiseInsurance: exceeding public debth cap\u0027;\n    string PUBLIC_DEBTH_NOT_PAID = \u0027WiseInsurance: public debth not paid\u0027;\n    string PUBLIC_CONTRIBUTION_MUST_BE_DISABLED = \u0027WiseInsurance: public contributions must be disabled\u0027;\n}"},"InsuranceHelper.sol":{"content":"// SPDX-License-Identifier: --ðŸ¦‰--\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./InsuranceDeclaration.sol\u0027;\r\n\r\ncontract InsuranceHelper is InsuranceDeclaration {\r\n\r\n    //  WISE INSURANCE (INTERNAL FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n\tfunction _increaseTotalStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalStaked =\r\n\t    totalStaked + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalStaked =\r\n\t    totalStaked - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalCovers(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalCovers =\r\n\t    totalCovers + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalCovers(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalCovers =\r\n\t    totalCovers - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalBufferStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalBufferStaked =\r\n\t    totalBufferStaked + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalBufferStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalBufferStaked =\r\n\t    totalBufferStaked - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalMasterProfits(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalMasterProfits =\r\n\t    totalMasterProfits + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalMasterProfits(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalMasterProfits =\r\n\t    totalMasterProfits \u003e _amount ?\r\n\t    totalMasterProfits - _amount : 0;\r\n\t}\r\n\r\n    function _increaseActiveInsuranceStakeCount()\r\n        internal\r\n    {\r\n        activeInsuranceStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveInsuranceStakeCount()\r\n        internal\r\n    {\r\n        activeInsuranceStakeCount--;\r\n    }\r\n\r\n    function _increaseActiveOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        activeOwnerlessStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        activeOwnerlessStakeCount--;\r\n    }\r\n\r\n    function _increaseActiveBufferStakeCount()\r\n        internal\r\n    {\r\n        activeBufferStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveBufferStakeCount()\r\n        internal\r\n    {\r\n        activeBufferStakeCount--;\r\n    }\r\n\r\n    function _increaseOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        ownerlessStakeCount++;\r\n    }\r\n\r\n    function _increaseBufferStakeCount()\r\n        internal\r\n    {\r\n        bufferStakeCount++;\r\n    }\r\n\r\n    function _trackOwnerlessStake(\r\n        address _originalOwner,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        ownerlessStakes[ownerlessStakeCount].stakeIndex = _stakeIndex;\r\n        ownerlessStakes[ownerlessStakeCount].originalOwner = _originalOwner;\r\n    }\r\n\r\n    function _increaseInsuranceStakeCounts(\r\n        address _staker\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakeCount++;\r\n        insuranceStakeCounts[_staker]++;\r\n    }\r\n\r\n    function _increasePublicDebth(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicDebth =\r\n        totalPublicDebth + _amount;\r\n    }\r\n\r\n    function _decreasePublicDebth(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicDebth =\r\n        totalPublicDebth - _amount;\r\n    }\r\n\r\n    function _increasePublicReward(\r\n        address _contributor,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        publicReward[_contributor] =\r\n        publicReward[_contributor] + _amount;\r\n    }\r\n\r\n    function _decreasePublicReward(\r\n        address _contributor,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        publicReward[_contributor] =\r\n        publicReward[_contributor] - _amount;\r\n    }\r\n\r\n    function _increasePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicRewards =\r\n        totalPublicRewards + _amount;\r\n    }\r\n\r\n    function _decreasePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicRewards =\r\n        totalPublicRewards - _amount;\r\n    }\r\n\r\n    function _renounceStakeOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakes[_staker][_stakeIndex].currentOwner = ZERO_ADDRESS;\r\n    }\r\n\r\n    function _calculateEmergencyAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _principalCut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _principalCut;\r\n        return _stakedAmount * percent / 100;\r\n    }\r\n\r\n    function _calculateMatureAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _bufferAmount,\r\n        uint256 _principalCut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _principalCut;\r\n        return (_stakedAmount + _bufferAmount) * percent / 100;\r\n    }\r\n\r\n    function _deactivateStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakes[_staker][_stakeIndex].isActive = false;\r\n    }\r\n\r\n    function stakesPagination(\r\n        address _staker,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16[] memory _stakes)\r\n    {\r\n        uint256 start = _offset \u003e 0 \u0026\u0026\r\n            insuranceStakeCounts[_staker] \u003e _offset ?\r\n            insuranceStakeCounts[_staker] - _offset : insuranceStakeCounts[_staker];\r\n\r\n        uint256 finish = _length \u003e 0 \u0026\u0026\r\n            start \u003e _length ?\r\n            start - _length : 0;\r\n\r\n        uint256 i;\r\n\r\n        _stakes = new bytes16[](start - finish);\r\n\r\n        for (uint256 _stakeIndex = start; _stakeIndex \u003e finish; _stakeIndex--) {\r\n            bytes16 _stakeID = getStakeID(_staker, _stakeIndex - 1);\r\n            if (insuranceStakes[_staker][_stakeIndex - 1].stakedAmount \u003e 0) {\r\n                _stakes[i] = _stakeID; i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  WISE INSURANCE (PUBLIC FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n    function getBufferAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].bufferAmount;\r\n    }\r\n\r\n    function getEmergencyAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].emergencyAmount;\r\n    }\r\n\r\n    function getMatureAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].matureAmount;\r\n    }\r\n\r\n    function getStakedAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].stakedAmount;\r\n    }\r\n\r\n    function getStakeData(\r\n        uint256 _ownerlessStakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (address, uint256)\r\n    {\r\n        return (\r\n            ownerlessStakes[_ownerlessStakeIndex].originalOwner,\r\n            ownerlessStakes[_ownerlessStakeIndex].stakeIndex\r\n        );\r\n    }\r\n\r\n    function checkActiveStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].isActive;\r\n    }\r\n\r\n    function checkOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].currentOwner == _staker;\r\n    }\r\n\r\n    function checkOwnerlessStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].currentOwner == ZERO_ADDRESS;\r\n    }\r\n\r\n    function applyFee(\r\n        uint256 _totalReward,\r\n        uint256 _interestCut\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _interestCut;\r\n        return _totalReward * percent / 100;\r\n    }\r\n\r\n    function penaltyFee(\r\n        uint256 _toReturn,\r\n        uint256 _matureLevel\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 penaltyPercent;\r\n\r\n        if (_matureLevel \u003c= penaltyThresholdB) {\r\n            penaltyPercent = penaltyB;\r\n        }\r\n\r\n        if (_matureLevel \u003c= penaltyThresholdA) {\r\n            penaltyPercent = penaltyA;\r\n        }\r\n\r\n        uint256 percent = 100 - penaltyPercent;\r\n        return _toReturn * percent / 100;\r\n    }\r\n\r\n    function checkMatureLevel(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n\r\n        (   uint256 startDay,\r\n            uint256 lockDays,\r\n            uint256 finalDay,\r\n            uint256 closeDay,\r\n            uint256 scrapeDay,\r\n            uint256 stakedAmount,\r\n            uint256 stakesShares,\r\n            uint256 rewardAmount,\r\n            uint256 penaltyAmount,\r\n            bool isActive,\r\n            bool isMature\r\n        ) = WISE_CONTRACT.checkStakeByID(\r\n            _staker,\r\n            _stakeID\r\n        );\r\n\r\n        return 100 - (_daysLeft(WISE_CONTRACT.currentWiseDay(), finalDay) * 100 / lockDays);\r\n    }\r\n\r\n    function _daysLeft(\r\n        uint256 _startDate,\r\n        uint256 _endDate\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _startDate \u003e _endDate ? 0 : _endDate - _startDate;\r\n    }\r\n\r\n    function getStakeID(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (bytes16)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].stakeID;\r\n    }\r\n\r\n    //  WISE INSURANCE (EXTERNAL MASTER FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n    function enablePublicContribution()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowPublicContributions = true;\r\n        emit PublicContributionsOpened(true);\r\n    }\r\n\r\n    function disablePublicContribution()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowPublicContributions = false;\r\n        emit PublicContributionsOpened(false);\r\n    }\r\n\r\n    function switchBufferStakeInterest(\r\n        bool _asDeveloperFunds\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        getBufferStakeInterest = _asDeveloperFunds;\r\n    }\r\n\r\n    bytes4 private constant TRANSFER = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \u0027transfer(address,uint256)\u0027\r\n            )\r\n        )\r\n    );\r\n\r\n    bytes4 private constant TRANSFER_FROM = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \u0027transferFrom(address,address,uint256)\u0027\r\n            )\r\n        )\r\n    );\r\n\r\n    function safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success \u0026\u0026 (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            TRANSFER_FAILED\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER_FROM,\r\n                _from,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success \u0026\u0026 (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            TRANSFER_FAILED\r\n        );\r\n    }\r\n}"},"WiseInsurance.sol":{"content":"// SPDX-License-Identifier: --ðŸ¦‰--\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./InsuranceHelper.sol\u0027;\r\n\r\ncontract WiseInsurance is InsuranceHelper {\r\n\r\n    function createStakeBulk(\r\n        uint256[] memory _stakedAmount,\r\n        uint64[] memory _lockDays,\r\n        address[] memory _referrer\r\n    )\r\n        external\r\n    {\r\n        for(uint256 i = 0; i \u003c _stakedAmount.length; i++) {\r\n            createStake(\r\n                _stakedAmount[i],\r\n                _lockDays[i],\r\n                _referrer[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function createStakeWithETH(\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        address[] memory path = new address[](2);\r\n            path[0] = WETH;\r\n            path[1] = wiseToken;\r\n\r\n        uint256[] memory amounts =\r\n        UNISWAP_ROUTER.swapExactETHForTokens{value: msg.value}(\r\n            1,\r\n            path,\r\n            msg.sender,\r\n            block.timestamp + 2 hours\r\n        );\r\n\r\n        createStake(\r\n            amounts[1],\r\n            _lockDays,\r\n            _referrer\r\n        );\r\n    }\r\n\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            _lockDays \u003c= MAX_STAKE_DAYS,\r\n            DECREASE_STAKE_DURATION\r\n        );\r\n\r\n        require(\r\n            allowInsurance == true,\r\n            INSURANCE_DISABLED\r\n        );\r\n\r\n        uint256 toStake =  _stakedAmount * stakePercent / 100;\r\n        uint256 toBuffer = _stakedAmount - toStake;\r\n\r\n        uint256 toReturn = _calculateEmergencyAmount(\r\n            toStake,\r\n            principalCut\r\n        );\r\n\r\n        uint256 matureReturn = _calculateMatureAmount(\r\n            toStake,\r\n            toBuffer,\r\n            principalCut\r\n        );\r\n\r\n        address staker = msg.sender;\r\n\r\n        safeTransferFrom(\r\n            wiseToken,\r\n            staker,\r\n            address(this),\r\n            _stakedAmount\r\n        );\r\n\r\n        _increaseTotalStaked(\r\n            toStake\r\n        );\r\n\r\n        _increaseTotalCovers(\r\n            toReturn\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent() \u003e= coverageThreshold,\r\n            BELOW_COVERAGE_THRESHOLD\r\n        );\r\n\r\n        (bytes16 stakeID, uint256 stakedAmount, bytes16 referralID) =\r\n\r\n        WISE_CONTRACT.createStake(\r\n            toStake,\r\n            _lockDays,\r\n            _referrer\r\n        );\r\n\r\n        uint256 stakeIndex = insuranceStakeCounts[staker];\r\n\r\n        insuranceStakes[staker][stakeIndex].stakeID = stakeID;\r\n        insuranceStakes[staker][stakeIndex].stakedAmount = toStake;\r\n        insuranceStakes[staker][stakeIndex].bufferAmount = toBuffer;\r\n        insuranceStakes[staker][stakeIndex].matureAmount = matureReturn;\r\n        insuranceStakes[staker][stakeIndex].emergencyAmount = toReturn;\r\n        insuranceStakes[staker][stakeIndex].currentOwner = staker;\r\n        insuranceStakes[staker][stakeIndex].isActive = true;\r\n\r\n        _increaseInsuranceStakeCounts(staker);\r\n        _increaseActiveInsuranceStakeCount();\r\n\r\n        emit InsurancStakeOpened(\r\n            stakeID,\r\n            stakedAmount,\r\n            toReturn,\r\n            staker,\r\n            stakeIndex,\r\n            referralID\r\n        );\r\n    }\r\n\r\n    function endStake(\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n    {\r\n        address _staker = msg.sender;\r\n\r\n        if (checkMatureStake(\r\n            _staker,\r\n            _stakeIndex\r\n        ) == false) {\r\n\r\n            _emergencyExitStake(\r\n                _staker,\r\n                _stakeIndex\r\n            );\r\n\r\n        } else {\r\n\r\n            _endMatureStake(\r\n                _staker,\r\n                _stakeIndex\r\n            );\r\n        }\r\n    }\r\n\r\n    function _emergencyExitStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            checkActiveStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkOwnership(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_YOUR_STAKE\r\n        );\r\n\r\n        _renounceStakeOwnership(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _trackOwnerlessStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        emit NewOwnerlessStake (\r\n            ownerlessStakeCount,\r\n            _stakeIndex,\r\n            _staker\r\n        );\r\n\r\n        _increaseOwnerlessStakeCount();\r\n        _increaseActiveOwnerlessStakeCount();\r\n\r\n        uint256 toReturn = getEmergencyAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 matureLevel = checkMatureLevel(\r\n            address(this),\r\n            stakeID\r\n        );\r\n\r\n        uint256 amountAfterFee = penaltyFee(\r\n            toReturn,\r\n            matureLevel\r\n        );\r\n\r\n        safeTransfer(\r\n            wiseToken,\r\n            _staker,\r\n            amountAfterFee\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            toReturn - amountAfterFee\r\n        );\r\n\r\n        _decreaseTotalCovers(\r\n            toReturn\r\n        );\r\n\r\n        emit EmergencyExitStake(\r\n            _staker,\r\n            _stakeIndex,\r\n            stakeID,\r\n            amountAfterFee,\r\n            toReturn,\r\n            WISE_CONTRACT.currentWiseDay()\r\n        );\r\n    }\r\n\r\n    function endMatureStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        _endMatureStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n    }\r\n\r\n    function _endMatureStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            checkOwnership(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_YOUR_STAKE\r\n        );\r\n\r\n        require(\r\n            checkMatureStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkActiveStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        _deactivateStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _decreaseActiveInsuranceStakeCount();\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 totalReward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 stakedAmount = getStakedAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 returnAmount = getMatureAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 emergencyAmount = getEmergencyAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        safeTransfer(\r\n            wiseToken,\r\n            _staker,\r\n            returnAmount\r\n        );\r\n\r\n        uint256 rewardAfterFee = applyFee(\r\n            totalReward,\r\n            interestCut\r\n        );\r\n\r\n        safeTransfer(\r\n            wiseToken,\r\n            _staker,\r\n            rewardAfterFee\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            stakedAmount \u003e returnAmount ?\r\n            stakedAmount - returnAmount : 0\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            totalReward - rewardAfterFee\r\n        );\r\n\r\n        _decreaseTotalStaked(\r\n            stakedAmount\r\n        );\r\n\r\n        _decreaseTotalCovers(\r\n            emergencyAmount\r\n        );\r\n\r\n        emit InsuranceStakeClosed(\r\n            _staker,\r\n            _stakeIndex,\r\n            stakeID,\r\n            returnAmount,\r\n            rewardAfterFee\r\n        );\r\n    }\r\n\r\n    function endOwnerlessStake(\r\n        uint256 _ownerlessStakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        (address staker, uint256 stakeIndex) =\r\n        getStakeData(_ownerlessStakeIndex);\r\n\r\n        require(\r\n            checkOwnerlessStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_OWNERLESS_STAKE\r\n        );\r\n\r\n        require(\r\n            checkMatureStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkActiveStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        _deactivateStake(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        _decreaseActiveInsuranceStakeCount();\r\n        _decreaseActiveOwnerlessStakeCount();\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 totalReward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 stakedAmount = getStakedAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 emergencyAmount = getEmergencyAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 bufferAmount = getBufferAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            totalReward\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            stakedAmount - emergencyAmount + bufferAmount\r\n        );\r\n\r\n        _decreaseTotalStaked(\r\n            stakedAmount\r\n        );\r\n\r\n        emit OwnerlessStakeClosed (\r\n            _ownerlessStakeIndex,\r\n            staker,\r\n            stakeIndex,\r\n            stakeID,\r\n            stakedAmount,\r\n            totalReward\r\n        );\r\n    }\r\n\r\n    function contributeAsPublic(\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address contributor = msg.sender;\r\n\r\n        require(\r\n            allowPublicContributions == true,\r\n            PUBLIC_CONTRIBUTIONS_DISABLED\r\n        );\r\n\r\n        safeTransferFrom(\r\n            wiseToken,\r\n            contributor,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        uint256 percent = 100 + publicRewardPercent;\r\n        uint256 toReturn = _amount * percent / 100;\r\n\r\n        _increasePublicReward(\r\n            contributor,\r\n            toReturn\r\n        );\r\n\r\n        _increasePublicDebth(\r\n            toReturn\r\n        );\r\n\r\n        require(\r\n            totalPublicDebth \u003c= publicDebthCap,\r\n            EXCEEDING_PUBLIC_DEBTH_CAP\r\n        );\r\n\r\n        emit TreasuryFunded(\r\n            _amount,\r\n            contributor,\r\n            getCurrentBuffer()\r\n        );\r\n    }\r\n\r\n    function takePublicProfits()\r\n        external\r\n    {\r\n        issuePublicProfits(\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function issuePublicProfits(\r\n        address _contributor\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            publicReward[_contributor] \u003e 0,\r\n            NO_REWARD_FOR_CONTRIBUTOR\r\n        );\r\n\r\n        require(\r\n            totalPublicDebth \u003e 0,\r\n            NO_PUBLIC_DEBTH\r\n        );\r\n\r\n        require(\r\n            totalPublicRewards \u003e 0,\r\n            NO_PUBLIC_REWARD_AVAILABLE\r\n        );\r\n\r\n        uint256 amount = publicReward[_contributor];\r\n\r\n        _decreasePublicDebth(\r\n            amount\r\n        );\r\n\r\n        _decreasePublicRewards(\r\n            amount\r\n        );\r\n\r\n        _decreasePublicReward(\r\n            _contributor,\r\n            amount\r\n        );\r\n\r\n        safeTransfer(\r\n            wiseToken,\r\n            _contributor,\r\n            amount\r\n        );\r\n\r\n        emit PublicProfit(\r\n            _contributor,\r\n            amount,\r\n            totalPublicDebth,\r\n            totalPublicRewards\r\n        );\r\n    }\r\n\r\n    function givePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        _decreaseTotalMasterProfits(\r\n            _amount\r\n        );\r\n\r\n        _increasePublicRewards(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            totalPublicRewards \u003c= totalPublicDebth\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent(totalPublicRewards) \u003e= payoutThreshold,\r\n            BELOW_PAYOUT_THRESHOLD\r\n        );\r\n\r\n        require(\r\n            allowPublicContributions == false,\r\n            PUBLIC_CONTRIBUTION_MUST_BE_DISABLED\r\n        );\r\n\r\n        emit publicRewardsGiven(\r\n            _amount,\r\n            totalPublicDebth,\r\n            totalPublicRewards\r\n        );\r\n    }\r\n\r\n    function takeMasterProfits(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            totalPublicDebth == 0,\r\n            PUBLIC_DEBTH_NOT_PAID\r\n        );\r\n\r\n        safeTransfer(\r\n            wiseToken,\r\n            insuranceMaster,\r\n            _amount\r\n        );\r\n\r\n        if (activeInsuranceStakeCount \u003e 0) {\r\n            require(\r\n                _amount \u003c= totalMasterProfits\r\n            );\r\n        }\r\n\r\n        _decreaseTotalMasterProfits(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent() \u003e= payoutThreshold,\r\n            BELOW_PAYOUT_THRESHOLD\r\n        );\r\n\r\n        emit ProfitsTaken(\r\n            _amount,\r\n            getCurrentBuffer()\r\n        );\r\n    }\r\n\r\n    function openBufferStake(\r\n        uint256 _amount,\r\n        uint64 _duration,\r\n        address _referrer\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        require(\r\n            _duration \u003c= maximumBufferStakeDuration\r\n        );\r\n\r\n        (bytes16 stakeID, uint256 stakedAmount, bytes16 referralID) =\r\n\r\n        WISE_CONTRACT.createStake(\r\n            _amount,\r\n            _duration,\r\n            _referrer\r\n        );\r\n\r\n        bufferStakes[bufferStakeCount].stakedAmount = _amount;\r\n        bufferStakes[bufferStakeCount].stakeID = stakeID;\r\n        bufferStakes[bufferStakeCount].isActive = true;\r\n\r\n        _increaseTotalBufferStaked(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            totalBufferStaked \u003c= bufferStakeCap\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent(_amount) \u003e= coverageThreshold\r\n        );\r\n\r\n        _increaseBufferStakeCount();\r\n        _increaseActiveBufferStakeCount();\r\n\r\n        emit BufferStakeOpened(\r\n            stakeID,\r\n            stakedAmount,\r\n            referralID\r\n        );\r\n    }\r\n\r\n    function closeBufferStake(\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        require(\r\n            bufferStakes[_stakeIndex].isActive,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        bufferStakes[_stakeIndex].isActive = false;\r\n\r\n        bytes16 stakeID = bufferStakes[_stakeIndex].stakeID;\r\n\r\n        require(\r\n            checkMatureStake(stakeID) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        uint256 reward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 staked = bufferStakes[_stakeIndex].stakedAmount;\r\n\r\n        if (getBufferStakeInterest) {\r\n            _withdrawDeveloperFunds(reward);\r\n        } else {\r\n            _increaseTotalMasterProfits(reward);\r\n        }\r\n\r\n        _decreaseTotalBufferStaked(\r\n            staked\r\n        );\r\n\r\n        _decreaseActiveBufferStakeCount();\r\n\r\n        emit BufferStakeClosed(\r\n            stakeID,\r\n            staked,\r\n            reward\r\n        );\r\n    }\r\n\r\n    function enableInsurance()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowInsurance = true;\r\n    }\r\n\r\n    function disableInsurance()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowInsurance = false;\r\n    }\r\n\r\n    /**\r\n     * @notice ability to change worker address\r\n     * @dev this address is used as helper\r\n     * @param _newInsuranceWorker address new worker\r\n     */\r\n    function changeInsuranceWorker(\r\n        address payable _newInsuranceWorker\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        insuranceWorker = _newInsuranceWorker;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the principal that gets staked\r\n     * @param _newStakePercent in range between 85-100%\r\n     */\r\n    function changeStakePercent(\r\n        uint256 _newStakePercent\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newStakePercent \u003e= 85 \u0026\u0026\r\n            _newStakePercent \u003c= 100\r\n        );\r\n\r\n        stakePercent = _newStakePercent;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newInterestCut in range between 0-10%\r\n     */\r\n    function changeInterestCut(\r\n        uint256 _newInterestCut\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newInterestCut \u003e= 0 \u0026\u0026\r\n            _newInterestCut \u003c= 10\r\n        );\r\n\r\n        interestCut = _newInterestCut;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newPrincipalCut in range between 0-10%\r\n     */\r\n    function changePrincipalCut(\r\n        uint256 _newPrincipalCut\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPrincipalCut \u003e= 0 \u0026\u0026\r\n            _newPrincipalCut \u003c= 10\r\n        );\r\n\r\n        principalCut = _newPrincipalCut;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newPublicRewardPercent in range between 0-50%\r\n     */\r\n    function changePublicRewardPercent(\r\n        uint256 _newPublicRewardPercent\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPublicRewardPercent \u003e= 0 \u0026\u0026\r\n            _newPublicRewardPercent \u003c= 50\r\n        );\r\n\r\n        publicRewardPercent = _newPublicRewardPercent;\r\n    }\r\n\r\n    function changePublicDebthCap(\r\n        uint256 _newPublicDebthCap\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        publicDebthCap = _newPublicDebthCap;\r\n    }\r\n\r\n    function changeMaximumBufferStakeDuration(\r\n        uint256 _newMaximumBufferStakeDuration\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        maximumBufferStakeDuration = _newMaximumBufferStakeDuration;\r\n    }\r\n\r\n    function changeBufferStakeCap(\r\n        uint256 _newBufferStakeCap\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        bufferStakeCap = _newBufferStakeCap;\r\n    }\r\n\r\n    function changePenaltyThresholds(\r\n        uint256 _newPenaltyThresholdA,\r\n        uint256 _newPenaltyThresholdB,\r\n        uint256 _newPenaltyA,\r\n        uint256 _newPenaltyB\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPenaltyThresholdB \u003c= 50 \u0026\u0026\r\n            _newPenaltyB \u003c= 15 \u0026\u0026\r\n            _newPenaltyA \u003c= 25\r\n        );\r\n\r\n        require(\r\n            _newPenaltyB \u003c= _newPenaltyA \u0026\u0026\r\n            _newPenaltyThresholdA \u003c= _newPenaltyThresholdB\r\n        );\r\n\r\n        _newPenaltyThresholdA = _newPenaltyThresholdA;\r\n        _newPenaltyThresholdB = _newPenaltyThresholdB;\r\n\r\n        penaltyA = _newPenaltyA;\r\n        penaltyB = _newPenaltyB;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * coverage percent for taking profits from the contract\r\n     * @param _newPayoutThreshold percent that needs to be covered\r\n     */\r\n    function changePayoutThreshold(\r\n        uint256 _newPayoutThreshold\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPayoutThreshold \u003e= coverageThreshold\r\n        );\r\n\r\n        payoutThreshold = _newPayoutThreshold;\r\n    }\r\n\r\n    function changeCoverageThreshold(\r\n        uint256 _newCoverageThreshold\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        coverageThreshold = _newCoverageThreshold;\r\n    }\r\n\r\n    function getCurrentBuffer() public view returns (uint256) {\r\n        return WISE_CONTRACT.balanceOf(\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function getCoveredPercent() public view returns (uint256) {\r\n\t\treturn totalCovers == 0 ? 100 : getCurrentBuffer() * 100 / totalCovers;\r\n\t}\r\n\r\n    function getCoveredPercent(uint256 _amount) public view returns (uint256) {\r\n\t\treturn totalCovers == 0 ? 100 : (getCurrentBuffer() - _amount) * 100 / totalCovers;\r\n\t}\r\n\r\n    /**\r\n     * @notice ability to check if stake opened\r\n     * as insurance stake from contracts perspective\r\n     * has now matured or not inside base layer\r\n     * @param _stakeID percent regular stakeID\r\n     */\r\n    function checkMatureStake(\r\n        bytes16 _stakeID\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return WISE_CONTRACT.checkMatureStake(\r\n            address(this),\r\n            _stakeID\r\n        );\r\n    }\r\n\r\n    function canStake()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getCoveredPercent() \u003e= coverageThreshold;\r\n    }\r\n\r\n    /**\r\n     * @notice ability to check if stake opened\r\n     * as insurance stake from contracts perspective\r\n     * has now matured or not inside base layer\r\n     * @param _stakeOwner original owner\r\n     * @param _stakeIndex index of the stake\r\n     */\r\n    function checkMatureStake(\r\n        address _stakeOwner,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return WISE_CONTRACT.checkMatureStake(\r\n            address(this),\r\n            insuranceStakes[_stakeOwner][_stakeIndex].stakeID\r\n        );\r\n    }\r\n\r\n    function _withdrawDeveloperFunds(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        safeTransfer(\r\n            wiseToken,\r\n            insuranceMaster,\r\n            _amount\r\n        );\r\n\r\n        emit DeveloperFundsRouted(\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function withdrawOriginalFunds()\r\n        external\r\n        onlyMaster\r\n    {\r\n        uint256 amount = teamContribution;\r\n        teamContribution = 0;\r\n        safeTransfer(\r\n            wiseToken,\r\n            insuranceMaster,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function fundTreasury(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        teamContribution =\r\n        teamContribution + _amount;\r\n\r\n        safeTransferFrom(\r\n            wiseToken,\r\n            insuranceMaster,\r\n            address(this),\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function saveTokens(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _tokenAddress != wiseToken\r\n        );\r\n\r\n        safeTransfer(\r\n            _tokenAddress,\r\n            insuranceMaster,\r\n            _tokenAmount\r\n        );\r\n    }\r\n}"},"WiseTokenInterface.sol":{"content":"// SPDX-License-Identifier: --ðŸ¦‰--\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface WiseTokenInterface {\r\n\r\n    function currentWiseDay()\r\n        external view\r\n        returns (uint64);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool success);\r\n\r\n    function generateID(\r\n        address x,\r\n        uint256 y,\r\n        bytes1 z\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes16 b);\r\n\r\n    function createStakeWithETH(\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        payable\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function createStakeWithToken(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function endStake(\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    function checkMatureStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        view\r\n        returns (bool isMature);\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) external view returns (uint256);\r\n\r\n    function checkStakeByID(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 startDay,\r\n            uint256 lockDays,\r\n            uint256 finalDay,\r\n            uint256 closeDay,\r\n            uint256 scrapeDay,\r\n            uint256 stakedAmount,\r\n            uint256 stakesShares,\r\n            uint256 rewardAmount,\r\n            uint256 penaltyAmount,\r\n            bool isActive,\r\n            bool isMature\r\n        );\r\n}"}}