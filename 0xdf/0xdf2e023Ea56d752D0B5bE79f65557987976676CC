
// File: src/contracts/strategies/StrategyFactory.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';

import {AuthorityControl} from '@floor/authorities/AuthorityControl.sol';
import {CannotSetNullAddress, CollectionNotApproved, StrategyNotApproved} from '@floor/utils/Errors.sol';

import {ICollectionRegistry} from '@floor-interfaces/collections/CollectionRegistry.sol';
import {IBaseStrategy} from '@floor-interfaces/strategies/BaseStrategy.sol';
import {IStrategyFactory} from '@floor-interfaces/strategies/StrategyFactory.sol';
import {IStrategyRegistry} from '@floor-interfaces/strategies/StrategyRegistry.sol';
import {ITreasury} from '@floor-interfaces/Treasury.sol';

// No empty names, that's just silly
error StrategyNameCannotBeEmpty();

/**
 * Allows for strategies to be created, pairing them with an approved collection. The strategy
 * creation script needs to be as highly optimised as possible to ensure that the gas
 * costs are kept down.
 *
 * This factory will keep an index of created strategies and secondary information to ensure
 * that external applications can display and maintain a list of available strategies.
 */
contract StrategyFactory is AuthorityControl, IStrategyFactory {
    /// Maintains an array of all strategies created
    address[] private _strategies;

    /// Store our Treasury address
    address public treasury;

    /// Contract mappings to our approved collections
    ICollectionRegistry public immutable collectionRegistry;

    /// Contract mappings to our approved strategy implementations
    IStrategyRegistry public immutable strategyRegistry;

    /// Mappings to aide is discoverability
    mapping(uint => address) private _strategyIds;

    /// Mapping of collection to strategy addresses
    mapping(address => address[]) private _collectionStrategies;

    /// Stores a list of bypassed strategies
    mapping(address => bool) private _bypassStrategy;

    /**
     * Store our registries, mapped to their interfaces.
     *
     * @param _authority {AuthorityRegistry} contract address
     * @param _collectionRegistry Address of our {CollectionRegistry}
     */
    constructor(address _authority, address _collectionRegistry, address _strategyRegistry) AuthorityControl(_authority) {
        if (_collectionRegistry == address(0)) revert CannotSetNullAddress();
        if (_strategyRegistry == address(0)) revert CannotSetNullAddress();

        // Type-cast our interfaces and store our registry contracts
        collectionRegistry = ICollectionRegistry(_collectionRegistry);
        strategyRegistry = IStrategyRegistry(_strategyRegistry);
    }

    /**
     * Provides a list of all strategies created.
     *
     * @return Array of all strategies created by the {StrategyFactory}
     */
    function strategies() external view returns (address[] memory) {
        return _strategies;
    }

    /**
     * Returns an array of all strategies that belong to a specific collection.
     *
     * @param _collection The address of the collection to query
     *
     * @return address[] Array of strategy addresses
     */
    function collectionStrategies(address _collection) external view returns (address[] memory) {
        return _collectionStrategies[_collection];
    }

    /**
     * Provides a strategy against the provided `strategyId` (index). If the index does not exist,
     * then address(0) will be returned.
     *
     * @param _strategyId ID of the strategy to retrieve
     *
     * @return Address of the strategy
     */
    function strategy(uint _strategyId) external view returns (address) {
        return _strategyIds[_strategyId];
    }

    /**
     * Creates a strategy with an approved collection.
     *
     * @dev The strategy is not created using Clones as there are complications when
     * allocated roles and permissions.
     *
     * @param _name Human-readable name of the strategy
     * @param _strategy The strategy implemented by the strategy
     * @param _strategyInitData Bytes data required by the {Strategy} for initialization
     * @param _collection The address of the collection attached to the strategy
     *
     * @return strategyId_ ID of the newly created strategy
     * @return strategyAddr_ Address of the newly created strategy
     */
    function deployStrategy(bytes32 _name, address _strategy, bytes calldata _strategyInitData, address _collection)
        external
        onlyRole(STRATEGY_MANAGER)
        returns (uint strategyId_, address strategyAddr_)
    {
        // No empty names, that's just silly
        if (_name == '') revert StrategyNameCannotBeEmpty();

        // Make sure the strategy implementation is approved
        if (!strategyRegistry.isApproved(_strategy)) revert StrategyNotApproved(_strategy);

        // Make sure the collection is approved
        if (!collectionRegistry.isApproved(_collection)) revert CollectionNotApproved(_collection);

        // Capture our `strategyId`, before we increment the array length
        strategyId_ = _strategies.length;

        // Deploy a new {Strategy} instance using the clone mechanic
        strategyAddr_ = Clones.cloneDeterministic(_strategy, bytes32(strategyId_));

        // We then need to instantiate the strategy using our supplied `strategyInitData`
        IBaseStrategy(strategyAddr_).initialize(_name, strategyId_, _strategyInitData);

        // Add our strategies to our internal tracking
        _strategies.push(strategyAddr_);

        // Add our mappings for onchain discoverability
        _strategyIds[strategyId_] = strategyAddr_;
        _collectionStrategies[_collection].push(strategyAddr_);

        // Finally we can emit our event to notify watchers of a new strategy
        emit StrategyCreated(strategyId_, strategyAddr_, _collection);
    }

    /**
     * Allows individual strategies to be paused, meaning that assets can no longer be deposited,
     * although staked assets can always be withdrawn.
     *
     * @dev Events are fired within the strategy to allow listeners to update.
     *
     * @param _strategyId strategy ID to be updated
     * @param _paused If the strategy should be paused or unpaused
     */
    function pause(uint _strategyId, bool _paused) public onlyRole(STRATEGY_MANAGER) {
        IBaseStrategy(_strategyIds[_strategyId]).pause(_paused);
    }

    /**
     * Reads the yield generated by all strategies since the last time that this
     * function was called.
     */
    function snapshot(uint _epoch)
        external
        onlyRole(STRATEGY_MANAGER)
        returns (address[] memory strategies_, uint[] memory amounts_, uint totalAmount_)
    {
        // Get our underlying WETH address
        address weth = address(ITreasury(treasury).weth());

        // Prefine some variables
        address[] memory tokens;
        uint[] memory amounts;
        uint tokensLength;

        // Get the number of strategies and define our returned array lengths
        uint strategiesLength = _strategies.length;
        strategies_ = new address[](strategiesLength);
        amounts_ = new uint[](strategiesLength);

        // Iterate over strategies to pull out yield
        for (uint i; i < strategiesLength;) {
            // Prevent a bypassed strategy from snapshotting
            if (!_bypassStrategy[_strategies[i]]) {
                // Snapshot our strategy
                (tokens, amounts) = IBaseStrategy(_strategies[i]).snapshot();

                // Capture the strategy address, even if we receive no WETH yield
                strategies_[i] = _strategies[i];

                // Iterate over tokens to just find WETH amounts
                tokensLength = tokens.length;
                for (uint l; l < tokensLength;) {
                    // Ensure that we only handle WETH tokens with amounts
                    if (tokens[l] == address(weth) && amounts[l] != 0) {
                        // Capture the WETH yield relative to the strategy
                        amounts_[i] = amounts[l];

                        // Keep a tally of the total amount of WETH earned
                        totalAmount_ += amounts[l];
                    }

                    unchecked { ++l; }
                }
            }

            unchecked { ++i; }
        }

        emit StrategySnapshot(_epoch, strategies_, amounts_);
    }

    /**
     * Harvest available reward yield from the strategy. This won't affect the amount
     * depositted into the contract and should only harvest rewards directly into the
     * {Treasury}.
     *
     * @param _strategyId Strategy ID to be harvested
     */
    function harvest(uint _strategyId) external onlyRole(STRATEGY_MANAGER) {
        if (_bypassStrategy[_strategyIds[_strategyId]]) return;

        IBaseStrategy(_strategyIds[_strategyId]).harvest(treasury);
    }

    /**
     * Makes a call to a strategy withdraw function by passing the strategy ID and
     * `abi.encodeWithSelector` to build the bytes `_data` parameter. This will then
     * pass the data on to the strategy function and inject the treasury recipient
     * address within the call as the first function parameter.
     *
     * @dev It is required for the transaction to return a successful call, otherwise
     * the transaction will be reverted. The error response will be standardised so
     * debugging will require a trace, rather than just the end message.
     *
     * @param _strategyId Strategy ID to be withdrawn from
     * @param _data Strategy withdraw function call, using `encodeWithSelector`
     */
    function withdraw(uint _strategyId, bytes calldata _data) external onlyRole(STRATEGY_MANAGER) {
        // If we are bypassing the strategy, then skip this call
        if (_bypassStrategy[_strategyIds[_strategyId]]) return;

        // Extract the selector from data
        bytes4 _selector = bytes4(_data);

        // Create a replication of the bytes data that removes the selector
        bytes memory _newData = new bytes(_data.length - 4);
        for (uint i; i < _data.length - 4; i++) {
            _newData[i] = _data[i + 4];
        }

        // Make a call to our strategy that passes on our withdrawal data
        (bool success,) = _strategyIds[_strategyId].call(
            // Sandwich the selector against the recipient and remaining data
            abi.encodePacked(abi.encodeWithSelector(_selector, treasury), _newData)
        );

        // If our call failed, return a standardised message rather than decoding
        require(success, 'Unable to withdraw');
    }

    /**
     * Makes a call to a strategy withdraw function.
     *
     * @param _strategy Strategy address to be updated
     * @param _percentage The percentage of position to withdraw from
     */
    function withdrawPercentage(address _strategy, uint _percentage)
        external
        onlyRole(STRATEGY_MANAGER)
        returns (address[] memory tokens_, uint[] memory amounts_)
    {
        // Ensure our percentage is valid (less than 100% to 2 decimal places)
        require(_percentage > 0, 'Invalid percentage');
        require(_percentage <= 100_00, 'Invalid percentage');

        // Prevent a bypassed strategy from parsing withdrawal calculations
        if (_bypassStrategy[_strategy]) {
            return (tokens_, amounts_);
        }

        // Calls our strategy to withdraw a percentage of the holdings
        return IBaseStrategy(_strategy).withdrawPercentage(msg.sender, _percentage);
    }

    /**
     * Allow a strategy to be skipped when being processing. This is beneficial if a
     * strategy becomes corrupted at an external point and would otherwise prevent an
     * epoch from ending.
     *
     * @dev This does not shutdown the strategy as it can be undone. If a strategy wants
     * to wind down, then it should also be paused and a full withdraw made.
     */
    function bypassStrategy(address _strategy, bool _bypass) external onlyRole(STRATEGY_MANAGER) {
        _bypassStrategy[_strategy] = _bypass;
    }

    /**
     * Allows the {Treasury} contract address to be updated. All withdrawals will
     * be requested to be sent to this address when the `withdraw` is called.
     *
     * @dev This address is dynamically injected into the subsequent strategy
     * withdraw call.
     *
     * @param _treasury The new {Treasury} contract address
     */
    function setTreasury(address _treasury) public onlyRole(TREASURY_MANAGER) {
        if (_treasury == address(0)) revert CannotSetNullAddress();

        treasury = _treasury;
        emit TreasuryUpdated(_treasury);
    }
}


// File: lib/openzeppelin-contracts/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: lib/openzeppelin-contracts/contracts/proxy/Clones.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)

pragma solidity ^0.8.0;

/**
 * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
 * deploying minimal proxy contracts, also known as "clones".
 *
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 *
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 * deterministic method.
 *
 * _Available since v3.4._
 */
library Clones {
    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create opcode, which should never revert.
     */
    function clone(address implementation) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create(0, 0x09, 0x37)
        }
        require(instance != address(0), "ERC1167: create failed");
    }

    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.
     *
     * This function uses the create2 opcode and a `salt` to deterministically deploy
     * the clone. Using the same `implementation` and `salt` multiple time will revert, since
     * the clones cannot be deployed twice at the same address.
     */
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
        /// @solidity memory-safe-assembly
        assembly {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create2(0, 0x09, 0x37, salt)
        }
        require(instance != address(0), "ERC1167: create2 failed");
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt,
        address deployer
    ) internal pure returns (address predicted) {
        /// @solidity memory-safe-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(add(ptr, 0x38), deployer)
            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)
            mstore(add(ptr, 0x14), implementation)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)
            mstore(add(ptr, 0x58), salt)
            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))
            predicted := keccak256(add(ptr, 0x43), 0x55)
        }
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt
    ) internal view returns (address predicted) {
        return predictDeterministicAddress(implementation, salt, address(this));
    }
}


// File: src/contracts/authorities/AuthorityControl.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {Context} from '@openzeppelin/contracts/utils/Context.sol';

import {CannotSetNullAddress} from '@floor/utils/Errors.sol';

import {IAuthorityControl} from '@floor-interfaces/authorities/AuthorityControl.sol';
import {IAuthorityRegistry} from '@floor-interfaces/authorities/AuthorityRegistry.sol';

/// If the account does not have the required role for the call.
/// @param caller The address making the call
/// @param role The role that is required for the call
error AccountDoesNotHaveRole(address caller, bytes32 role);

/// If the account does not have the required admin role for the call.
/// @param caller The address making the call
error AccountDoesNotHaveAdminRole(address caller);

/**
 * This contract is heavily based on the standardised OpenZeppelin `AccessControl` library.
 * This allows for the creation of role based access levels that can be assigned to 1-n
 * addresses.
 *
 * Contracts will be able to implement the AuthorityControl to provide access to the `onlyRole` modifier or the
 * `hasRole` function. This will ensure that the `msg.sender` is allowed to perform an action.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be
 * unique. The best way to achieve this is by using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("TreasuryManager");
 * ```
 */
contract AuthorityControl is Context, IAuthorityControl {
    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies
    bytes32 public constant COLLECTION_MANAGER = keccak256('CollectionManager');

    /// EpochTrigger - Can run epoch trigger contract specific logic
    bytes32 public constant EPOCH_TRIGGER = keccak256('EpochTrigger');

    /// FloorManager - Can mint and manage Floor and VeFloor tokens
    bytes32 public constant FLOOR_MANAGER = keccak256('FloorManager');

    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to
    /// be made and implemented.
    bytes32 public constant GOVERNOR = keccak256('Governor');

    /// Guardian - Wallet address that will allow for Governor based actions, except without
    /// timeframe restrictions.
    bytes32 public constant GUARDIAN = keccak256('Guardian');

    /// TreasuryManager - Access to Treasury asset management
    bytes32 public constant TREASURY_MANAGER = keccak256('TreasuryManager');

    /// StrategyManager - Can create new strategies against approved strategies and collections
    bytes32 public constant STRATEGY_MANAGER = keccak256('StrategyManager');

    /// VoteManager - Can manage account votes
    bytes32 public constant VOTE_MANAGER = keccak256('VoteManager');

    /// Reference to the {AuthorityRegistry} contract that maintains role allocations
    IAuthorityRegistry public immutable registry;

    /**
     * Modifier that checks that an account has a specific role. Reverts with a
     * standardized message if user does not have specified role.
     *
     * @param role The keccak256 encoded role string
     */
    modifier onlyRole(bytes32 role) {
        if (!registry.hasRole(role, _msgSender())) {
            revert AccountDoesNotHaveRole(_msgSender(), role);
        }
        _;
    }

    /**
     * Modifier that checks that an account has a governor or guardian role.
     * Reverts with a standardized message if sender does not have an admin role.
     */
    modifier onlyAdminRole() {
        if (!registry.hasAdminRole(_msgSender())) {
            revert AccountDoesNotHaveAdminRole(_msgSender());
        }
        _;
    }

    /**
     * The address that deploys the {AuthorityControl} becomes the default controller. This
     * can only be overwritten by the existing.
     *
     * @param _registry The address of our deployed AuthorityRegistry contract
     */
    constructor(address _registry) {
        if (_registry == address(0)) revert CannotSetNullAddress();
        registry = IAuthorityRegistry(_registry);
    }

    /**
     * Returns `true` if `account` has been granted `role`.
     *
     * @param role The keccak256 encoded role string
     * @param account Address to check ownership of role
     *
     * @return bool If the address has the specified user role
     */
    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return registry.hasRole(role, account);
    }

    /**
     * Returns `true` if `account` has been granted either GOVERNOR or GUARDIAN role.
     *
     * @param account Address to check ownership of role
     *
     * @return bool If the address has the GOVERNOR or GUARDIAN role
     */
    function hasAdminRole(address account) public view returns (bool) {
        return registry.hasAdminRole(account);
    }
}


// File: src/contracts/utils/Errors.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

/**
 * A collection of generic errors that can be referenced across multiple
 * contracts. Contract-specific errors should still be stored in their
 * individual Solidity files.
 */

/// If a NULL address tries to be stored which should not be accepted
error CannotSetNullAddress();

/// If the caller has entered an insufficient amount to process the action. This
/// will likely be a zero amount.
error InsufficientAmount();

/// If the caller enters a percentage value that is too high for the requirements
error PercentageTooHigh(uint amount);

/// If a required ETH or token `transfer` call fails
error TransferFailed();

/// If a user calls a deposit related function with a zero amount
error CannotDepositZeroAmount();

/// If a user calls a withdrawal related function with a zero amount
error CannotWithdrawZeroAmount();

/// If there are no rewards available to be claimed
error NoRewardsAvailableToClaim();

/// If the requested collection is not approved
/// @param collection Address of the collection requested
error CollectionNotApproved(address collection);

/// If the requested strategy implementation is not approved
/// @param strategyImplementation Address of the strategy implementation requested
error StrategyNotApproved(address strategyImplementation);


// File: src/interfaces/collections/CollectionRegistry.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Allows collection contracts to be approved and revoked by addresses holding the
 * {CollectionManager} role. Only once approved can these collections be applied to
 * new or existing strategies. They will only need to be stored as a mapping of address
 * to boolean.
 */

interface ICollectionRegistry {
    /// Emitted when a collection is successfully approved
    event CollectionApproved(address contractAddr);

    /// Emitted when a collection has been successfully revoked
    event CollectionRevoked(address contractAddr);

    /**
     * Returns `true` if the contract address is an approved collection, otherwise
     * returns `false`.
     */
    function isApproved(address contractAddr) external view returns (bool);

    /**
     * Returns an array of all approved collections.
     */
    function approvedCollections() external view returns (address[] memory);

    /**
     * Approves a collection contract to be used for strategies.
     */
    function approveCollection(address contractAddr) external;
}


// File: src/interfaces/strategies/BaseStrategy.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Strategies will hold the logic for interacting with external platforms to stake
 * and harvest reward yield. Each strategy will require its own strategy implementation
 * to allow for different immutable variables to be defined during construct.
 *
 * This will follow a similar approach to how NFTX offer their eligibility module
 * logic, with a lot of the power coming from inheritence.
 *
 * When constructed, we want to give the {Treasury} a max uint approval of the yield
 * and underlying tokens.
 */
interface IBaseStrategy {
    /// @dev When strategy receives a deposit
    event Deposit(address token, uint amount, address caller);

    /// @dev When strategy is harvested
    event Harvest(address token, uint amount);

    /// @dev When a staked user exits their position
    event Withdraw(address token, uint amount, address recipient);

    /**
     * Allows the strategy to be initialised.
     */
    function initialize(bytes32 name, uint strategyId, bytes calldata initData) external;

    /**
     * Name of the strategy.
     */
    function name() external view returns (bytes32);

    /**
     * The numerical ID of the strategy that acts as an index for the {StrategyFactory}.
     */
    function strategyId() external view returns (uint);

    /**
     * Total rewards generated by the strategy in all time. This is pure bragging rights.
     */
    function lifetimeRewards(address token) external returns (uint amount_);

    /**
     * The amount of rewards claimed in the last claim call.
     */
    function lastEpochRewards(address token) external returns (uint amount_);

    /**
     * Gets rewards that are available to harvest.
     */
    function available() external returns (address[] memory, uint[] memory);

    /**
     * Extracts all rewards from third party and moves it to a recipient. This should
     * only be called by a specific action.
     *
     * @dev This _should_ always be imposed to be the {Treasury} by the {StrategyFactory}.
     */
    function harvest(address /* _recipient */ ) external;

    /**
     * Returns an array of tokens that the strategy supports.
     *
     * @return address[] The address of valid tokens
     */
    function validTokens() external view returns (address[] memory);

    /**
     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.
     *
     * @param recipient Strategy address to be updated
     * @param percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)
     *
     * @return address[] Array of tokens withdrawn
     * @return uint[] Amounts of respective tokens withdrawn
     */
    function withdrawPercentage(address recipient, uint percentage) external returns (address[] memory, uint[] memory);

    /**
     * Pauses deposits from being made into the strategy. This should only be called by
     * a guardian or governor.
     *
     * @param _p Boolean value for if the strategy should be paused
     */
    function pause(bool _p) external;

    /**
     * Gets a read of new yield since the last call. This is what can be called when
     * the epoch ends to determine the amount generated within the epoch.
     */
    function snapshot() external returns (address[] memory, uint[] memory);
}


// File: src/interfaces/strategies/StrategyFactory.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Allows for strategies to be created, pairing them with a {Strategy} and an approved
 * collection. The strategy creation script needs to be as highly optimised as possible
 * to ensure that the gas costs are kept down.
 *
 * This factory will keep an index of created strategies and secondary information to ensure
 * that external applications can display and maintain a list of available strategies.
 *
 * The contract can be paused to prevent the creation of new strategies.
 */

interface IStrategyFactory {
    /// @dev Sent when a strategy is created successfully
    event StrategyCreated(uint indexed strategyId, address strategyAddress, address assetAddress);

    /// @dev Sent when a snapshot is taken
    event StrategySnapshot(uint epoch, address[] tokens, uint[] amounts);

    /// @dev Sent when the Treasury address is updated
    event TreasuryUpdated(address treasury);

    /**
     * Our stored {Treasury} address.
     */
    function treasury() external view returns (address);

    /**
     * Provides a list of all strategies created.
     *
     * @return Array of all strategies created by the {StrategyFactory}
     */
    function strategies() external view returns (address[] memory);

    /**
     * Returns an array of all strategies that belong to a specific collection.
     */
    function collectionStrategies(address _collection) external view returns (address[] memory);

    /**
     * Provides a strategy against the provided `strategyId` (index). If the index does not exist,
     * then address(0) will be returned.
     *
     * @param _strategyId ID of the strategy to retrieve
     *
     * @return Address of the strategy
     */
    function strategy(uint _strategyId) external view returns (address);

    /**
     * Creates a strategy with an approved collection.
     *
     * @dev The strategy is not created using Clones as there are complications when allocated
     * roles and permissions.
     *
     * @param _name Human-readable name of the strategy
     * @param _strategy The strategy implemented by the strategy
     * @param _strategyInitData Bytes data required by the {Strategy} for initialization
     * @param _collection The address of the collection attached to the strategy
     *
     * @return strategyId_ ID of the newly created strategy
     * @return strategyAddr_ Address of the newly created strategy
     */
    function deployStrategy(bytes32 _name, address _strategy, bytes calldata _strategyInitData, address _collection)
        external
        returns (uint strategyId_, address strategyAddr_);

    /**
     * Allows individual strategies to be paused, meaning that assets can no longer be deposited,
     * although staked assets can always be withdrawn.
     *
     * @dev Events are fired within the strategy to allow listeners to update.
     *
     * @param _strategyId Strategy ID to be paused
     * @param _paused If the strategy should be paused or unpaused
     */
    function pause(uint _strategyId, bool _paused) external;

    /**
     * Reads the yield generated by a strategy since the last time that this function was called.
     *
     * @param _epoch The current epoch being snapshotted
     *
     * @return tokens Tokens that have been generated as yield
     * @return amounts The amount of yield generated for the corresponding token
     */
    function snapshot(uint _epoch) external returns (address[] memory tokens, uint[] memory amounts, uint totalAmount);

    /**
     * Harvest available reward yield from the strategy. This won't affect the amount
     * depositted into the contract and should only harvest rewards directly into the
     * {Treasury}.
     *
     * @param _strategyId Strategy ID to be harvested
     */
    function harvest(uint _strategyId) external;

    /**
     * Makes a call to a strategy withdraw function by passing the strategy ID and
     * `abi.encodeWithSelector` to build the bytes `_data` parameter. This will then
     * pass the data on to the strategy function and inject the treasury recipient
     * address within the call as the first function parameter.
     *
     * @dev It is required for the transaction to return a successful call, otherwise
     * the transaction will be reverted. The error response will be standardised so
     * debugging will require a trace, rather than just the end message.
     *
     * @param _strategyId Strategy ID to be withdrawn from
     * @param _data Strategy withdraw function call, using `encodeWithSelector`
     */
    function withdraw(uint _strategyId, bytes calldata _data) external;

    /**
     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.
     *
     * @param _strategy Strategy address to be updated
     * @param _percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)
     */
    function withdrawPercentage(address _strategy, uint _percentage) external returns (address[] memory, uint[] memory);

    /**
     * Allows the {Treasury} contract address to be updated. All withdrawals will
     * be requested to be sent to this address when the `withdraw` is called.
     *
     * @dev This address is dynamically injected into the subsequent strategy
     * withdraw call.
     *
     * @param _treasury The new {Treasury} contract address
     */
    function setTreasury(address _treasury) external;
}


// File: src/interfaces/strategies/StrategyRegistry.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Allows strategy contracts to be approved and revoked by addresses holding the
 * {TREASURY_MANAGER} role. Only once approved can these strategy implementations be deployed
 * to new or existing strategies.
 */
interface IStrategyRegistry {
    /// Emitted when a strategy is approved or unapproved
    event ApprovedStrategyUpdated(address contractAddr, bool approved);

    /**
     * Checks if a strategy has previously been approved.
     *
     * @param contractAddr The strategy implementation address to be checked
     *
     * @return Returns `true` if the contract address is an approved strategy, otherwise
     * returns `false`.
     */
    function isApproved(address contractAddr) external view returns (bool);

    /**
     * Changes the approval state of a strategy implementation contract.
     *
     * The strategy address cannot be null, and if it is already the new state, then
     * no changes will be made.
     *
     * The caller must have the `TREASURY_MANAGER` role.
     *
     * @param contractAddr Address of unapproved strategy to approve
     * @param approved The new approval state for the implementation
     */
    function approveStrategy(address contractAddr, bool approved) external;
}


// File: src/interfaces/Treasury.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IWETH} from '@floor-interfaces/tokens/WETH.sol';


library TreasuryEnums {
    /// Different sweep types that can be specified.
    enum SweepType {
        COLLECTION_ADDITION,
        SWEEP
    }

    /// Different approval types that can be specified.
    enum ApprovalType {
        NATIVE,
        ERC20,
        ERC721,
        ERC1155
    }
}

/**
 * @dev The Treasury will hold all assets.
 */
interface ITreasury {
    /// Stores data that allows the Treasury to action a sweep.
    struct Sweep {
        TreasuryEnums.SweepType sweepType;
        address[] collections;
        uint[] amounts;
        bool completed;
        string message;
    }

    /// The data structure format that will be mapped against to define a token
    /// approval request.
    struct ActionApproval {
        TreasuryEnums.ApprovalType _type; // Token type
        address assetContract; // Used by 20, 721 and 1155
        address target; // Used by 20, 721 and 1155
        uint amount; // Used by native and 20 tokens
    }

    /// @dev When native network token is withdrawn from the Treasury
    event Deposit(uint amount);

    /// @dev When an ERC20 is depositted into the Treasury
    event DepositERC20(address token, uint amount);

    /// @dev When an ERC721 is depositted into the Treasury
    event DepositERC721(address token, uint tokenId);

    /// @dev When an ERC1155 is depositted into the Treasury
    event DepositERC1155(address token, uint tokenId, uint amount);

    /// @dev When native network token is withdrawn from the Treasury
    event Withdraw(uint amount, address recipient);

    /// @dev When an ERC20 token is withdrawn from the Treasury
    event WithdrawERC20(address token, uint amount, address recipient);

    /// @dev When an ERC721 token is withdrawn from the Treasury
    event WithdrawERC721(address token, uint tokenId, address recipient);

    /// @dev When an ERC1155 is withdrawn from the Treasury
    event WithdrawERC1155(address token, uint tokenId, uint amount, address recipient);

    /// @dev When FLOOR is minted
    event FloorMinted(uint amount);

    /// @dev When a {Treasury} action is processed
    event ActionProcessed(address action, bytes data);

    /// @dev When a sweep is registered against an epoch
    event SweepRegistered(uint sweepEpoch, TreasuryEnums.SweepType sweepType, address[] collections, uint[] amounts);

    /// @dev When an action is assigned to a sweep epoch
    event SweepAction(uint sweepEpoch);

    /// @dev When an epoch is swept
    event EpochSwept(uint epochIndex);

    /// Emitted when the {MercenarySweeper} contract address is updated
    event MercenarySweeperUpdated(address mercSweeper);

    /// Emitted when the minimum sweep amount is updated
    event MinSweepAmountUpdated(uint minSweepAmount);

    /// Emitted when the {VeFloorStaking} contract is updated
    event VeFloorStakingUpdated(address veFloorStaking);

    /// Emitted when the {StrategyFactory} contract is updated
    event StrategyFactoryUpdated(address strategyFactory);

    /**
     * Our stored WETH address for the {Treasury}
     */
    function weth() external returns (IWETH);

    /**
     * Allow FLOOR token to be minted. This should be called from the deposit method
     * internally, but a public method will allow a {TreasuryManager} to bypass this
     * and create additional FLOOR tokens if needed.
     *
     * @dev We only want to do this on creation and for inflation. Have a think on how
     * we can implement this!
     */
    function mint(uint amount) external;

    /**
     * Allows an ERC20 token to be deposited and generates FLOOR tokens based on
     * the current determined value of FLOOR and the token.
     */
    function depositERC20(address token, uint amount) external;

    /**
     * Allows an ERC721 token to be deposited and generates FLOOR tokens based on
     * the current determined value of FLOOR and the token.
     */
    function depositERC721(address token, uint tokenId) external;

    /**
     * Allows an ERC1155 token(s) to be deposited and generates FLOOR tokens based on
     * the current determined value of FLOOR and the token.
     */
    function depositERC1155(address token, uint tokenId, uint amount) external;

    /**
     * Allows an approved user to withdraw native token.
     */
    function withdraw(address recipient, uint amount) external;

    /**
     * Allows an approved user to withdraw and ERC20 token from the Treasury.
     */
    function withdrawERC20(address recipient, address token, uint amount) external;

    /**
     * Allows an approved user to withdraw and ERC721 token from the Treasury.
     */
    function withdrawERC721(address recipient, address token, uint tokenId) external;

    /**
     * Allows an approved user to withdraw an ERC1155 token(s) from the Treasury.
     */
    function withdrawERC1155(address recipient, address token, uint tokenId, uint amount) external;

    /**
     * Actions a sweep to be used against a contract that implements {ISweeper}. This
     * will fulfill the sweep and we then mark the sweep as completed.
     */
    function sweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;

    /**
     * Allows the DAO to resweep an already swept "Sweep" struct, using a contract that
     * implements {ISweeper}. This will fulfill the sweep again and keep the sweep marked
     * as completed.
     */
    function resweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;

    /**
     * When an epoch ends, we have the ability to register a sweep against the {Treasury}
     * via an approved contract. This will store a DAO sweep that will need to be actioned
     * using the `sweepEpoch` function.
     */
    function registerSweep(uint epoch, address[] calldata collections, uint[] calldata amounts, TreasuryEnums.SweepType sweepType)
        external;

    /**
     * The minimum sweep amount that can be implemented, or excluded, as desired by the DAO.
     */
    function minSweepAmount() external returns (uint);

    /**
     * Allows the mercenary sweeper contract to be updated.
     */
    function setMercenarySweeper(address _mercSweeper) external;

    /**
     * Allows us to set a new VeFloorStaking contract that is used when sweeping epochs.
     */
    function setVeFloorStaking(address _veFloorStaking) external;
}


// File: lib/openzeppelin-contracts/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: src/interfaces/authorities/AuthorityControl.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IAuthorityControl {
    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies
    function COLLECTION_MANAGER() external returns (bytes32);

    /// EpochTrigger - Can run epoch trigger contract specific logic
    function EPOCH_TRIGGER() external returns (bytes32);

    /// FloorManager - Can mint and manage Floor and VeFloor tokens
    function FLOOR_MANAGER() external returns (bytes32);

    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to
    /// be made and implemented.
    function GOVERNOR() external returns (bytes32);

    /// Guardian - Wallet address that will allow for Governor based actions, except without
    /// timeframe restrictions.
    function GUARDIAN() external returns (bytes32);

    /// TreasuryManager - Access to Treasury asset management
    function TREASURY_MANAGER() external returns (bytes32);

    /// StrategyManager - Can create new strategies against approved strategies and collections
    function STRATEGY_MANAGER() external returns (bytes32);

    /// VoteManager - Can manage account votes
    function VOTE_MANAGER() external returns (bytes32);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns `true` if `account` has been granted either the GOVERNOR or
     * GUARDIAN `role`.
     */
    function hasAdminRole(address account) external view returns (bool);
}


// File: src/interfaces/authorities/AuthorityRegistry.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * This interface expands upon the OpenZeppelin `IAccessControl` interface:
 * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/access/IAccessControl.sol
 */

interface IAuthorityRegistry {
    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns `true` if `account` has been granted either the GOVERNOR or
     * GUARDIAN `role`.
     */
    function hasAdminRole(address account) external view returns (bool);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role) external;
}


// File: src/interfaces/tokens/WETH.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IWETH is IERC20 {
    function allowance(address, address) external view returns (uint);

    function balanceOf(address) external view returns (uint);

    function approve(address, uint) external returns (bool);

    function transfer(address, uint) external returns (bool);

    function transferFrom(address, address, uint) external returns (bool);

    function deposit() external payable;

    function withdraw(uint) external;
}


// File: lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

