
// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    /**
     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    /**
     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
     */
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    /**
     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }

    /**
     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful.
     */
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }

    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }

    /**
     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
     * Revert on invalid signature.
     */
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
        // and not revert is the subcall reverts.

        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     *
     * Furthermore, `isContract` will also return true if the target contract within
     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
     * which only has an effect at the end of a transaction.
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: contracts/core/BorrowerOperations.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../interfaces/ITroveManager.sol";
import "../interfaces/IBorrowerOperations.sol";
import "../interfaces/IWenUSD.sol";
import "../dependencies/WenBase.sol";
import "../dependencies/WenMath.sol";
import "../dependencies/WenOwnable.sol";
import "../dependencies/DelegatedOps.sol";

/**
    @title Wen Borrower Operations
    @notice Based on Liquity's `BorrowerOperations`
            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/BorrowerOperations.sol

            Wen's implementation is modified to support multiple collaterals. There is a 1:n
            relationship between `BorrowerOperations` and each `TroveManager` / `SortedTroves` pair.
 */
contract BorrowerOperations is IBorrowerOperations, WenBase, WenOwnable, DelegatedOps {
	using SafeERC20 for IERC20;

	IWenUSD public immutable WenUSD;
	address public immutable factory;
	uint256 public minNetDebt;

	mapping(ITroveManager => TroveManagerData) public troveManagersData;
	ITroveManager[] internal _troveManagers;

	struct TroveManagerData {
		IERC20 collateralToken;
		uint16 index;
	}

	struct LocalVariables_adjustTrove {
		uint256 price;
		uint256 totalPricedCollateral;
		uint256 totalDebt;
		uint256 collChange;
		uint256 netDebtChange;
		bool isCollIncrease;
		uint256 debt;
		uint256 coll;
		uint256 newDebt;
		uint256 newColl;
		uint256 stake;
		uint256 debtChange;
		address account;
		uint256 MCR;
	}

	struct LocalVariables_openTrove {
		uint256 price;
		uint256 totalPricedCollateral;
		uint256 totalDebt;
		uint256 netDebt;
		uint256 compositeDebt;
		uint256 ICR;
		uint256 NICR;
		uint256 stake;
		uint256 arrayIndex;
	}

	constructor(IWenCore _WenCore, address _WenUSDAddress, address _factory, uint256 _minNetDebt, uint256 _gasCompensation) WenOwnable(_WenCore) WenBase(_gasCompensation) {
		WenUSD = IWenUSD(_WenUSDAddress);
		factory = _factory;
		_setMinNetDebt(_minNetDebt);
	}

	function setMinNetDebt(uint256 _minNetDebt) public onlyOwner {
		_setMinNetDebt(_minNetDebt);
	}

	function _setMinNetDebt(uint256 _minNetDebt) internal {
		require(_minNetDebt > 0, "invalid min net debt");
		minNetDebt = _minNetDebt;
	}

	function configureCollateral(ITroveManager troveManager, IERC20 collateralToken) external {
		require(msg.sender == factory, "!factory");
		troveManagersData[troveManager] = TroveManagerData(collateralToken, uint16(_troveManagers.length));
		_troveManagers.push(troveManager);
		emit CollateralConfigured(troveManager, collateralToken);
	}

	function removeTroveManager(ITroveManager troveManager) external {
		TroveManagerData memory tmData = troveManagersData[troveManager];
		require(address(tmData.collateralToken) != address(0) && troveManager.sunsetting() && troveManager.getEntireSystemDebt() == 0, "Trove Manager cannot be removed");
		delete troveManagersData[troveManager];
		uint256 lastIndex = _troveManagers.length - 1;
		if (tmData.index < lastIndex) {
			ITroveManager lastTm = _troveManagers[lastIndex];
			_troveManagers[tmData.index] = lastTm;
			troveManagersData[lastTm].index = tmData.index;
		}

		_troveManagers.pop();
		emit TroveManagerRemoved(troveManager);
	}

	/**
        @notice Get the global total collateral ratio
        @dev Not a view because fetching from the oracle is state changing.
             Can still be accessed as a view from within the UX.
     */
	function getTCR() external returns (uint256 globalTotalCollateralRatio) {
		SystemBalances memory balances = fetchBalances();
		(globalTotalCollateralRatio, , ) = _getTCRData(balances);
		return globalTotalCollateralRatio;
	}

	/**
        @notice Get total collateral and debt balances for all active collaterals, as well as
                the current collateral prices
        @dev Not a view because fetching from the oracle is state changing.
             Can still be accessed as a view from within the UX.
     */
	function fetchBalances() public returns (SystemBalances memory balances) {
		uint256 loopEnd = _troveManagers.length;
		balances = SystemBalances({ collaterals: new uint256[](loopEnd), debts: new uint256[](loopEnd), prices: new uint256[](loopEnd) });
		for (uint256 i; i < loopEnd; ) {
			ITroveManager troveManager = _troveManagers[i];
			(uint256 collateral, uint256 debt, uint256 price) = troveManager.getEntireSystemBalances();
			balances.collaterals[i] = collateral;
			balances.debts[i] = debt;
			balances.prices[i] = price;
			unchecked {
				++i;
			}
		}
	}

	function checkRecoveryMode(uint256 TCR) public pure returns (bool) {
		return TCR < CCR;
	}

	function getCompositeDebt(uint256 _debt) external view returns (uint256) {
		return _getCompositeDebt(_debt);
	}

	// --- Borrower Trove Operations ---
	function openTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collateralAmount, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		require(!WenCore.paused(), "Deposits are paused");
		troveManager.distributeInterestDebt();
		IERC20 collateralToken;
		LocalVariables_openTrove memory vars;
		bool isRecoveryMode;
		(collateralToken, vars.price, vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);
		_requireValidMaxFeePercentage(_maxFeePercentage);

		vars.netDebt = _debtAmount;

		if (!isRecoveryMode) {
			vars.netDebt = vars.netDebt + _triggerBorrowingFee(troveManager, collateralToken, account, _maxFeePercentage, _debtAmount);
		}
		_requireAtLeastMinNetDebt(vars.netDebt);

		// ICR is based on the composite debt, i.e. the requested Debt amount + Debt borrowing fee + Debt gas comp.
		vars.compositeDebt = _getCompositeDebt(vars.netDebt);
		vars.ICR = WenMath._computeCR(_collateralAmount, vars.compositeDebt, vars.price);
		vars.NICR = WenMath._computeNominalCR(_collateralAmount, vars.compositeDebt);

		if (isRecoveryMode) {
			_requireICRisAboveCCR(vars.ICR);
		} else {
			_requireICRisAboveMCR(vars.ICR, troveManager.MCR());
			uint256 newTCR = _getNewTCRFromTroveChange(vars.totalPricedCollateral, vars.totalDebt, _collateralAmount * vars.price, true, vars.compositeDebt, true); // bools: coll increase, debt increase
			_requireNewTCRisAboveCCR(newTCR);
		}

		// Create the trove
		(vars.stake, vars.arrayIndex) = troveManager.openTrove(account, _collateralAmount, vars.compositeDebt, vars.NICR, _upperHint, _lowerHint);

		// Move the collateral to the Trove Manager
		collateralToken.safeTransferFrom(msg.sender, address(troveManager), _collateralAmount);

		//  and mint the DebtAmount to the caller and gas compensation for Gas Pool
		WenUSD.mintWithGasCompensation(msg.sender, _debtAmount);
	}

	// Send collateral to a trove
	function addColl(ITroveManager troveManager, address account, uint256 _collateralAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		require(!WenCore.paused(), "Trove adjustments are paused");
		_adjustTrove(troveManager, account, 0, _collateralAmount, 0, 0, false, _upperHint, _lowerHint);
	}

	// Withdraw collateral from a trove
	function withdrawColl(ITroveManager troveManager, address account, uint256 _collWithdrawal, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		_adjustTrove(troveManager, account, 0, 0, _collWithdrawal, 0, false, _upperHint, _lowerHint);
	}

	// Withdraw Debt tokens from a trove: mint new Debt tokens to the owner, and increase the trove's debt accordingly
	function withdrawDebt(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		require(!WenCore.paused(), "Withdrawals are paused");
		_adjustTrove(troveManager, account, _maxFeePercentage, 0, 0, _debtAmount, true, _upperHint, _lowerHint);
	}

	// Repay Debt tokens to a Trove: Burn the repaid Debt tokens, and reduce the trove's debt accordingly
	function repayDebt(ITroveManager troveManager, address account, uint256 _debtAmount, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		_adjustTrove(troveManager, account, 0, 0, 0, _debtAmount, false, _upperHint, _lowerHint);
	}

	function adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external callerOrDelegated(account) {
		require((_collDeposit == 0 && !_isDebtIncrease) || !WenCore.paused(), "Trove adjustments are paused");
		require(_collDeposit == 0 || _collWithdrawal == 0, "BorrowerOperations: Cannot withdraw and add coll");
		_adjustTrove(troveManager, account, _maxFeePercentage, _collDeposit, _collWithdrawal, _debtChange, _isDebtIncrease, _upperHint, _lowerHint);
	}

	function _adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) internal {
		require(_collDeposit != 0 || _collWithdrawal != 0 || _debtChange != 0, "BorrowerOps: There must be either a collateral change or a debt change");
		troveManager.distributeInterestDebt();
		IERC20 collateralToken;
		LocalVariables_adjustTrove memory vars;
		bool isRecoveryMode;
		(collateralToken, vars.price, vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);
		(vars.coll, vars.debt) = troveManager.applyPendingRewards(account);
		troveManager.repayInterest(msg.sender, account, vars.debt);

		// Get the collChange based on whether or not collateral was sent in the transaction
		(vars.collChange, vars.isCollIncrease) = _getCollChange(_collDeposit, _collWithdrawal);
		vars.netDebtChange = _debtChange;
		vars.debtChange = _debtChange;
		vars.account = account;
		vars.MCR = troveManager.MCR();

		if (_isDebtIncrease) {
			require(_debtChange > 0, "BorrowerOps: Debt increase requires non-zero debtChange");
			_requireValidMaxFeePercentage(_maxFeePercentage);
			if (!isRecoveryMode) {
				// If the adjustment incorporates a debt increase and system is in Normal Mode, trigger a borrowing fee
				vars.netDebtChange += _triggerBorrowingFee(troveManager, collateralToken, msg.sender, _maxFeePercentage, _debtChange);
			}
		}

		// Calculate old and new ICRs and check if adjustment satisfies all conditions for the current system mode
		_requireValidAdjustmentInCurrentMode(vars.totalPricedCollateral, vars.totalDebt, isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);

		// When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Debt
		if (!_isDebtIncrease && _debtChange > 0) {
			_requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);
		}

		// If we are incrasing collateral, send tokens to the trove manager prior to adjusting the trove
		if (vars.isCollIncrease) collateralToken.safeTransferFrom(msg.sender, address(troveManager), vars.collChange);

		(vars.newColl, vars.newDebt, vars.stake) = troveManager.updateTroveFromAdjustment(_isDebtIncrease, vars.debtChange, vars.netDebtChange, vars.isCollIncrease, vars.collChange, _upperHint, _lowerHint, vars.account, msg.sender);
	}

	function closeTrove(ITroveManager troveManager, address account) external callerOrDelegated(account) {
		IERC20 collateralToken;
		uint256 price;
		bool isRecoveryMode;
		uint256 totalPricedCollateral;
		uint256 totalDebt;
		(collateralToken, price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getCollateralAndTCRData(troveManager);
		require(!isRecoveryMode, "BorrowerOps: Operation not permitted during Recovery Mode");
		troveManager.distributeInterestDebt();
		(uint256 coll, uint256 debt) = troveManager.applyPendingRewards(account);
		troveManager.repayInterest(msg.sender, account, debt);
		uint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, coll * price, false, debt, false);
		_requireNewTCRisAboveCCR(newTCR);
		troveManager.closeTrove(account, msg.sender, coll, debt);
		// Burn the repaid Debt from the user's balance and the gas compensation from the Gas Pool
		WenUSD.burnWithGasCompensation(msg.sender, debt - DEBT_GAS_COMPENSATION);
	}

	// --- Helper functions ---

	function _triggerBorrowingFee(ITroveManager _troveManager, IERC20 collateralToken, address _caller, uint256 _maxFeePercentage, uint256 _debtAmount) internal returns (uint256) {
		uint256 debtFee = _troveManager.decayBaseRateAndGetBorrowingFee(_debtAmount);
		_requireUserAcceptsFee(debtFee, _debtAmount, _maxFeePercentage);
		WenUSD.mint(WenCore.feeReceiver(), debtFee);
		emit BorrowingFeePaid(_caller, collateralToken, debtFee);
		return debtFee;
	}

	function _getCollChange(uint256 _collReceived, uint256 _requestedCollWithdrawal) internal pure returns (uint256 collChange, bool isCollIncrease) {
		if (_collReceived != 0) {
			collChange = _collReceived;
			isCollIncrease = true;
		} else {
			collChange = _requestedCollWithdrawal;
		}
	}

	function _requireValidAdjustmentInCurrentMode(uint256 totalPricedCollateral, uint256 totalDebt, bool _isRecoveryMode, uint256 _collWithdrawal, bool _isDebtIncrease, LocalVariables_adjustTrove memory _vars) internal pure {
		/*
		 *In Recovery Mode, only allow:
		 *
		 * - Pure collateral top-up
		 * - Pure debt repayment
		 * - Collateral top-up with debt repayment
		 * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
		 *
		 * In Normal Mode, ensure:
		 *
		 * - The new ICR is above MCR
		 * - The adjustment won't pull the TCR below CCR
		 */

		// Get the trove's old ICR before the adjustment
		uint256 oldICR = WenMath._computeCR(_vars.coll, _vars.debt, _vars.price);

		// Get the trove's new ICR after the adjustment
		uint256 newICR = _getNewICRFromTroveChange(_vars.coll, _vars.debt, _vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);

		if (_isRecoveryMode) {
			require(_collWithdrawal == 0, "BorrowerOps: Collateral withdrawal not permitted Recovery Mode");
			if (_isDebtIncrease) {
				_requireICRisAboveCCR(newICR);
				_requireNewICRisAboveOldICR(newICR, oldICR);
			}
		} else {
			// if Normal Mode
			_requireICRisAboveMCR(newICR, _vars.MCR);
			uint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, _vars.collChange * _vars.price, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease);
			_requireNewTCRisAboveCCR(newTCR);
		}
	}

	function _requireICRisAboveMCR(uint256 _newICR, uint256 MCR) internal pure {
		require(_newICR >= MCR, "BorrowerOps: An operation that would result in ICR < MCR is not permitted");
	}

	function _requireICRisAboveCCR(uint256 _newICR) internal pure {
		require(_newICR >= CCR, "BorrowerOps: Operation must leave trove with ICR >= CCR");
	}

	function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
		require(_newICR >= _oldICR, "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode");
	}

	function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
		require(_newTCR >= CCR, "BorrowerOps: An operation that would result in TCR < CCR is not permitted");
	}

	function _requireAtLeastMinNetDebt(uint256 _netDebt) internal view {
		require(_netDebt >= minNetDebt, "BorrowerOps: Trove's net debt must be greater than minimum");
	}

	function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {
		require(_maxFeePercentage <= DECIMAL_PRECISION, "Max fee percentage must less than or equal to 100%");
	}

	// Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
	function _getNewICRFromTroveChange(uint256 _coll, uint256 _debt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease, uint256 _price) internal pure returns (uint256) {
		(uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);

		uint256 newICR = WenMath._computeCR(newColl, newDebt, _price);
		return newICR;
	}

	function _getNewTroveAmounts(uint256 _coll, uint256 _debt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease) internal pure returns (uint256, uint256) {
		uint256 newColl = _coll;
		uint256 newDebt = _debt;
		newColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;
		newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;

		return (newColl, newDebt);
	}

	function _getNewTCRFromTroveChange(uint256 totalColl, uint256 totalDebt, uint256 _collChange, bool _isCollIncrease, uint256 _debtChange, bool _isDebtIncrease) internal pure returns (uint256) {
		totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;
		totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;

		uint256 newTCR = WenMath._computeCR(totalColl, totalDebt);
		return newTCR;
	}

	function _getTCRData(SystemBalances memory balances) internal pure returns (uint256 amount, uint256 totalPricedCollateral, uint256 totalDebt) {
		uint256 loopEnd = balances.collaterals.length;
		for (uint256 i; i < loopEnd; ) {
			totalPricedCollateral += (balances.collaterals[i] * balances.prices[i]);
			totalDebt += balances.debts[i];
			unchecked {
				++i;
			}
		}
		amount = WenMath._computeCR(totalPricedCollateral, totalDebt);
		return (amount, totalPricedCollateral, totalDebt);
	}

	function _getCollateralAndTCRData(ITroveManager troveManager) internal returns (IERC20 collateralToken, uint256 price, uint256 totalPricedCollateral, uint256 totalDebt, bool isRecoveryMode) {
		TroveManagerData storage t = troveManagersData[troveManager];
		uint256 index;
		(collateralToken, index) = (t.collateralToken, t.index);
		require(address(collateralToken) != address(0), "Collateral not enabled");
		uint256 amount;
		SystemBalances memory balances = fetchBalances();
		(amount, totalPricedCollateral, totalDebt) = _getTCRData(balances);
		isRecoveryMode = checkRecoveryMode(amount);

		return (collateralToken, balances.prices[index], totalPricedCollateral, totalDebt, isRecoveryMode);
	}

	function getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt) {
		SystemBalances memory balances = fetchBalances();
		(, totalPricedCollateral, totalDebt) = _getTCRData(balances);
	}
}


// File: contracts/dependencies/DelegatedOps.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

/**
    @title Wen Delegated Operations
    @notice Allows delegation to specific contract functionality. Useful for creating
            wrapper contracts to bundle multiple interactions into a single call.

            Functions that supports delegation should include an `account` input allowing
            the delegated caller to indicate who they are calling on behalf of. In executing
            the call, all internal state updates should be applied for `account` and all
            value transfers should occur to or from the caller.

            For example: a delegated call to `openTrove` should transfer collateral
            from the caller, create the debt position for `account`, and send newly
            minted tokens to the caller.
 */
contract DelegatedOps {
	mapping(address => mapping(address => bool)) public isApprovedDelegate;

	modifier callerOrDelegated(address _account) {
		require(msg.sender == _account || isApprovedDelegate[_account][msg.sender], "Delegate not approved");
		_;
	}

	function setDelegateApproval(address _delegate, bool _isApproved) external {
		isApprovedDelegate[msg.sender][_delegate] = _isApproved;
	}
}


// File: contracts/dependencies/WenBase.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;
import "../interfaces/IWenBase.sol";

/*
 * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and
 * common functions.
 */
contract WenBase is IWenBase {
	uint256 public constant override DECIMAL_PRECISION = 1e18;

	// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.
	uint256 public constant override CCR = 1500000000000000000; // 150%

	// Amount of debt to be locked in gas pool on opening troves
	uint256 public immutable override DEBT_GAS_COMPENSATION;

	uint256 public constant override PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%

	constructor(uint256 _gasCompensation) {
		DEBT_GAS_COMPENSATION = _gasCompensation;
	}

	// --- Gas compensation functions ---

	// Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation
	function _getCompositeDebt(uint256 _debt) internal view returns (uint256) {
		return _debt + DEBT_GAS_COMPENSATION;
	}

	function _getNetDebt(uint256 _debt) internal view returns (uint256) {
		return _debt - DEBT_GAS_COMPENSATION;
	}

	// Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
	function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {
		return _entireColl / PERCENT_DIVISOR;
	}

	function _requireUserAcceptsFee(uint256 _fee, uint256 _amount, uint256 _maxFeePercentage) internal pure {
		uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;
		require(feePercentage <= _maxFeePercentage, "Fee exceeded provided maximum");
	}
}


// File: contracts/dependencies/WenMath.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

library WenMath {
	uint256 internal constant DECIMAL_PRECISION = 1e18;

	/* Precision for Nominal ICR (independent of price). Rationale for the value:
	 *
	 * - Making it “too high” could lead to overflows.
	 * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.
	 *
	 * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39,
	 * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.
	 *
	 */
	uint256 internal constant NICR_PRECISION = 1e20;

	function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
		return (_a < _b) ? _a : _b;
	}

	function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
		return (_a >= _b) ? _a : _b;
	}

	/*
	 * Multiply two decimal numbers and use normal rounding rules:
	 * -round product up if 19'th mantissa digit >= 5
	 * -round product down if 19'th mantissa digit < 5
	 *
	 * Used only inside the exponentiation, _decPow().
	 */
	function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {
		uint256 prod_xy = x * y;

		decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;
	}

	/*
	 * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.
	 *
	 * Uses the efficient "exponentiation by squaring" algorithm. O(log(n)) complexity.
	 *
	 * TroveManager._calcDecayedBaseRate
	 *
	 * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals
	 * "minutes in 1000 years": 60 * 24 * 365 * 1000
	 *
	 * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be
	 * negligibly different from just passing the cap, since:
	 *
	 * the decayed base rate will be 0 for 1000 years or > 1000 years
	 */
	function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {
		if (_minutes > 525600000) {
			_minutes = 525600000;
		} // cap to avoid overflow

		if (_minutes == 0) {
			return DECIMAL_PRECISION;
		}

		uint256 y = DECIMAL_PRECISION;
		uint256 x = _base;
		uint256 n = _minutes;

		// Exponentiation-by-squaring
		while (n > 1) {
			if (n % 2 == 0) {
				x = decMul(x, x);
				n = n / 2;
			} else {
				// if (n % 2 != 0)
				y = decMul(x, y);
				x = decMul(x, x);
				n = (n - 1) / 2;
			}
		}

		return decMul(x, y);
	}

	function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {
		return (_a >= _b) ? _a - _b : _b - _a;
	}

	function _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {
		if (_debt > 0) {
			return (_coll * NICR_PRECISION) / _debt;
		}
		// Return the maximal value for uint256 if the Trove has a debt of 0. Represents "infinite" CR.
		else {
			// if (_debt == 0)
			return 2 ** 256 - 1;
		}
	}

	function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint256) {
		if (_debt > 0) {
			uint256 newCollRatio = (_coll * _price) / _debt;

			return newCollRatio;
		}
		// Return the maximal value for uint256 if the Trove has a debt of 0. Represents "infinite" CR.
		else {
			// if (_debt == 0)
			return type(uint256).max;
		}
	}

	function _computeCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {
		if (_debt > 0) {
			uint256 newCollRatio = (_coll) / _debt;

			return newCollRatio;
		}
		// Return the maximal value for uint256 if the Trove has a debt of 0. Represents "infinite" CR.
		else {
			// if (_debt == 0)
			return type(uint256).max;
		}
	}
}


// File: contracts/dependencies/WenOwnable.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "../interfaces/IWenCore.sol";

/**
    @title Wen Ownable
    @notice Contracts inheriting `WenOwnable` have the same owner as `WenCore`.
            The ownership cannot be independently modified or renounced.
 */
contract WenOwnable {
	IWenCore public immutable WenCore;

	constructor(IWenCore _WenCore) {
		WenCore = _WenCore;
	}

	modifier onlyOwner() {
		require(msg.sender == WenCore.owner(), "Only owner");
		_;
	}

	function owner() public view returns (address) {
		return WenCore.owner();
	}

	function guardian() public view returns (address) {
		return WenCore.guardian();
	}
}


// File: contracts/interfaces/IBorrowerOperations.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./ITroveManager.sol";

interface IBorrowerOperations {
	struct SystemBalances {
		uint256[] collaterals;
		uint256[] debts;
		uint256[] prices;
	}

	enum BorrowerOperation {
		openTrove,
		closeTrove,
		adjustTrove
	}

	event BorrowingFeePaid(address indexed borrower, IERC20 collateralToken, uint256 amount);
	event CollateralConfigured(ITroveManager troveManager, IERC20 collateralToken);
	event TroveManagerRemoved(ITroveManager troveManager);

	function addColl(ITroveManager troveManager, address account, uint256 _collateralAmount, address _upperHint, address _lowerHint) external;

	function adjustTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collDeposit, uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint) external;

	function closeTrove(ITroveManager troveManager, address account) external;

	function configureCollateral(ITroveManager troveManager, IERC20 collateralToken) external;

	function fetchBalances() external returns (SystemBalances memory balances);

	function getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt);

	function getTCR() external returns (uint256 globalTotalCollateralRatio);

	function openTrove(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _collateralAmount, uint256 _debtAmount, address _upperHint, address _lowerHint) external;

	function removeTroveManager(ITroveManager troveManager) external;

	function repayDebt(ITroveManager troveManager, address account, uint256 _debtAmount, address _upperHint, address _lowerHint) external;

	function setMinNetDebt(uint256 _minNetDebt) external;

	function withdrawColl(ITroveManager troveManager, address account, uint256 _collWithdrawal, address _upperHint, address _lowerHint) external;

	function withdrawDebt(ITroveManager troveManager, address account, uint256 _maxFeePercentage, uint256 _debtAmount, address _upperHint, address _lowerHint) external;

	function factory() external view returns (address);

	function getCompositeDebt(uint256 _debt) external view returns (uint256);

	function minNetDebt() external view returns (uint256);

	function checkRecoveryMode(uint256 TCR) external pure returns (bool);
}


// File: contracts/interfaces/IPriceFeed.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IPriceFeed {
	event NewOracleRegistered(address token, address chainlinkAggregator, bool isEthIndexed);
	event PriceFeedStatusUpdated(address token, address oracle, bool isWorking);
	event PriceRecordUpdated(address indexed token, uint256 _price);

	function fetchPrice(address _token) external returns (uint256);

	function setOracle(address _token, address _chainlinkOracle, bytes4 sharePriceSignature, uint8 sharePriceDecimals, bool _isEthIndexed) external;

	function MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND() external view returns (uint256);

	function RESPONSE_TIMEOUT() external view returns (uint256);

	function TARGET_DIGITS() external view returns (uint256);

	function guardian() external view returns (address);

	function oracleRecords(address) external view returns (address chainLinkOracle, uint8 decimals, bytes4 sharePriceSignature, uint8 sharePriceDecimals, bool isFeedWorking, bool isEthIndexed);

	function owner() external view returns (address);

	function priceRecords(address) external view returns (uint96 scaledPrice, uint32 timestamp, uint32 lastUpdated, uint80 roundId);
}


// File: contracts/interfaces/ISortedTroves.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface ISortedTroves {
	event NodeAdded(address _id, uint256 _NICR);
	event NodeRemoved(address _id);

	function insert(address _id, uint256 _NICR, address _prevId, address _nextId) external;

	function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external;

	function remove(address _id) external;

	function setAddresses(address _troveManagerAddress) external;

	function contains(address _id) external view returns (bool);

	function data() external view returns (address head, address tail, uint256 size);

	function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (address, address);

	function getFirst() external view returns (address);

	function getLast() external view returns (address);

	function getNext(address _id) external view returns (address);

	function getPrev(address _id) external view returns (address);

	function getSize() external view returns (uint256);

	function isEmpty() external view returns (bool);

	function troveManager() external view returns (address);

	function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view returns (bool);
}


// File: contracts/interfaces/ITroveManager.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./IWenBase.sol";
import "./ISortedTroves.sol";
import "./IPriceFeed.sol";

interface ITroveManager is IWenBase {
	// Store the necessary data for a trove
	struct Trove {
		uint256 debt;
		uint256 coll;
		uint256 stake;
		Status status;
		uint128 arrayIndex;
	}

	struct RedemptionTotals {
		uint256 remainingDebt;
		uint256 totalDebtToRedeem;
		uint256 totalCollateralDrawn;
		uint256 totalInterest;
		uint256 collateralFee;
		uint256 collateralToSendToRedeemer;
		uint256 decayedBaseRate;
		uint256 price;
		uint256 totalDebtSupplyAtStart;
	}

	struct SingleRedemptionValues {
		uint256 debtLot;
		uint256 collateralLot;
		uint256 interestLot;
		bool cancelledPartial;
	}

	// Object containing the collateral and debt snapshots for a given active trove
	struct RewardSnapshot {
		uint256 collateral;
		uint256 debt;
		uint256 interest;
	}

	enum TroveManagerOperation {
		open,
		close,
		adjust,
		liquidate,
		redeemCollateral
	}

	enum Status {
		nonExistent,
		active,
		closedByOwner,
		closedByLiquidation,
		closedByRedemption
	}

	event InterestPaid(address _account, address _borrower, uint256 _interest);
	event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);
	event Redemption(uint256 _attemptedDebtAmount, uint256 _actualDebtAmount, uint256 _collateralSent, uint256 _InterestDebt, uint256 _collateralFee);
	event BaseRateUpdated(uint256 _baseRate);
	event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);
	event TotalStakesUpdated(uint256 _newTotalStakes);
	event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);
	event LTermsUpdated(uint256 _L_collateral, uint256 _L_debt);
	event TroveRewardSnapshotsUpdated(address borrower, uint256 _L_collateral, uint256 _L_debt);
	event TroveInterestSnapshotsUpdated(address borrower, uint256 _L_interest);
	event TroveIndexUpdated(address _borrower, uint256 _newIndex);
	event CollateralSent(address _to, uint256 _amount);
	event RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);

	function addCollateralSurplus(address borrower, uint256 collSurplus) external;

	function applyPendingRewards(address _borrower) external returns (uint256 coll, uint256 debt);

	function claimCollateral(address _receiver) external;

	function closeTrove(address _borrower, address _receiver, uint256 collAmount, uint256 debtAmount) external;

	function closeTroveByLiquidation(address _borrower) external;

	function decayBaseRateAndGetBorrowingFee(uint256 _debt) external returns (uint256);

	function decreaseDebtAndSendCollateral(address account, uint256 debt, uint256 coll) external;

	function finalizeLiquidation(address _liquidator, uint256 _debt, uint256 _coll, uint256 _collSurplus, uint256 _debtGasComp, uint256 _collGasComp, uint256 _interest) external;

	function getEntireSystemBalances() external returns (uint256, uint256, uint256);

	function movePendingTroveRewardsToActiveBalances(uint256 _debt, uint256 _collateral) external;

	function openTrove(address _borrower, uint256 _collateralAmount, uint256 _compositeDebt, uint256 NICR, address _upperHint, address _lowerHint) external returns (uint256 stake, uint256 arrayIndex);

	function redeemCollateral(uint256 _debtAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint256 _partialRedemptionHintNICR, uint256 _maxIterations, uint256 _maxFeePercentage) external;

	function setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, IERC20 _collateralToken) external;

	function setParameters(uint256 _minuteDecayFactor, uint256 _redemptionFeeFloor, uint256 _maxRedemptionFee, uint256 _borrowingFeeFloor, uint256 _maxBorrowingFee, uint256 _maxSystemDebt, uint256 _MCR, uint32 _interestRate) external;

	function setPaused(bool _paused) external;

	function setPriceFeed(address _priceFeedAddress) external;

	function updateTroveFromAdjustment(bool _isDebtIncrease, uint256 _debtChange, uint256 _netDebtChange, bool _isCollIncrease, uint256 _collChange, address _upperHint, address _lowerHint, address _borrower, address _receiver) external returns (uint256, uint256, uint256);

	function fetchPrice() external returns (uint256);

	function distributeInterestDebt() external returns (uint256);

	function repayInterest(address _account, address _borrower, uint256 _debt) external;

	function BOOTSTRAP_PERIOD() external view returns (uint256);

	function L_collateral() external view returns (uint256);

	function L_debt() external view returns (uint256);

	function MCR() external view returns (uint256);

	function getTrove(address _borrower) external view returns (Trove memory);

	function baseRate() external view returns (uint256);

	function borrowerOperationsAddress() external view returns (address);

	function borrowingFeeFloor() external view returns (uint256);

	function collateralToken() external view returns (IERC20);

	function defaultedCollateral() external view returns (uint256);

	function defaultedDebt() external view returns (uint256);

	function getBorrowingFee(uint256 _debt) external view returns (uint256);

	function getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256);

	function getBorrowingRate() external view returns (uint256);

	function getBorrowingRateWithDecay() external view returns (uint256);

	function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);

	function getEntireDebtAndColl(address _borrower) external view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward);

	function getEntireSystemColl() external view returns (uint256);

	function getEntireSystemDebt() external view returns (uint256);

	function getGlobalSystemDebt() external view returns (uint256);

	function getTroveInterest(address _borrower, uint256 _debt) external view returns (uint256);
	function getRedemptionICR(address _borrower, uint256 _price) external view returns (uint256);
	function getNominalICR(address _borrower) external view returns (uint256);

	function getPendingCollAndDebtRewards(address _borrower) external view returns (uint256, uint256);

	function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256);

	function getRedemptionRate() external view returns (uint256);

	function getRedemptionRateWithDecay() external view returns (uint256);

	function getTotalActiveCollateral() external view returns (uint256);

	function getTotalActiveDebt() external view returns (uint256);

	function getTroveCollAndDebt(address _borrower) external view returns (uint256 coll, uint256 debt);

	function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);

	function getTroveOwnersCount() external view returns (uint256);

	function getTroveStake(address _borrower) external view returns (uint256);

	function getTroveStatus(address _borrower) external view returns (uint256);

	function hasPendingRewards(address _borrower) external view returns (bool);

	function lastCollateralError_Redistribution() external view returns (uint256);

	function lastDebtError_Redistribution() external view returns (uint256);

	function lastFeeOperationTime() external view returns (uint256);

	function liquidationManager() external view returns (address);

	function maxBorrowingFee() external view returns (uint256);

	function maxRedemptionFee() external view returns (uint256);

	function maxSystemDebt() external view returns (uint256);

	function minuteDecayFactor() external view returns (uint256);

	function paused() external view returns (bool);

	function redemptionFeeFloor() external view returns (uint256);

	function getRewardSnapshots(address) external view returns (RewardSnapshot memory);

	function priceFeed() external view returns (IPriceFeed);

	function sortedTroves() external view returns (ISortedTroves);

	function sunsetting() external view returns (bool);

	function surplusBalances(address) external view returns (uint256);

	function systemDeploymentTime() external view returns (uint256);

	function totalCollateralSnapshot() external view returns (uint256);

	function totalStakes() external view returns (uint256);

	function totalStakesSnapshot() external view returns (uint256);
}


// File: contracts/interfaces/IWenBase.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IWenBase {
	function DECIMAL_PRECISION() external view returns(uint256);

	// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.
	function CCR() external view returns(uint256); // 150%

	// Amount of debt to be locked in gas pool on opening troves
	function DEBT_GAS_COMPENSATION() external view returns(uint256);

	function PERCENT_DIVISOR() external view returns(uint256);

}


// File: contracts/interfaces/IWenCore.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IWenCore {
	event FeeReceiverSet(address feeReceiver);
	event GuardianSet(address guardian);
	event NewOwnerAccepted(address oldOwner, address owner);
	event NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);
	event NewOwnerRevoked(address owner, address revokedOwner);
	event Paused();
	event PriceFeedSet(address priceFeed);
	event Unpaused();

	function acceptTransferOwnership() external;

	function commitTransferOwnership(address newOwner) external;

	function revokeTransferOwnership() external;

	function setFeeReceiver(address _feeReceiver) external;

	function setGuardian(address _guardian) external;

	function setPaused(bool _paused) external;

	function setPriceFeed(address _priceFeed) external;

	function OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);

	function feeReceiver() external view returns (address);

	function guardian() external view returns (address);

	function owner() external view returns (address);

	function ownershipTransferDeadline() external view returns (uint256);

	function paused() external view returns (bool);

	function pendingOwner() external view returns (address);

	function startTime() external view returns (uint256);
}


// File: contracts/interfaces/IWenUSD.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IWenUSD {
	event Approval(address indexed owner, address indexed spender, uint256 value);
	event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);
	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
	event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint256 _amount);
	event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);
	event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint256 _amount);
	event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint256 _minDstGas);
	event SetPrecrime(address precrime);
	event SetTrustedRemote(uint16 _remoteChainId, bytes _path);
	event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);
	event SetUseCustomAdapterParams(bool _useCustomAdapterParams);
	event Transfer(address indexed from, address indexed to, uint256 value);

	function approve(address spender, uint256 amount) external returns (bool);

	function burn(address _account, uint256 _amount) external;

	function burnWithGasCompensation(address _account, uint256 _amount) external returns (bool);

	function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

	function enableTroveManager(address _troveManager) external;

	function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external returns (bool);

	function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;

	function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

	function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;

	function mint(address _account, uint256 _amount) external;

	function mintWithGasCompensation(address _account, uint256 _amount) external returns (bool);

	function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;

	function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;

	function renounceOwnership() external;

	function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external;

	function sendToSP(address _sender, uint256 _amount) external;

	function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;

	function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint256 _minGas) external;

	function setPayloadSizeLimit(uint16 _dstChainId, uint256 _size) external;

	function setPrecrime(address _precrime) external;

	function setReceiveVersion(uint16 _version) external;

	function setSendVersion(uint16 _version) external;

	function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external;

	function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external;

	function setUseCustomAdapterParams(bool _useCustomAdapterParams) external;

	function transfer(address recipient, uint256 amount) external returns (bool);

	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

	function transferOwnership(address newOwner) external;

	function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external payable;

	function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint256 _amount, address _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;

	function DEBT_GAS_COMPENSATION() external view returns (uint256);

	function DEFAULT_PAYLOAD_SIZE_LIMIT() external view returns (uint256);

	function FLASH_LOAN_FEE() external view returns (uint256);

	function NO_EXTRA_GAS() external view returns (uint256);

	function PT_SEND() external view returns (uint16);

	function allowance(address owner, address spender) external view returns (uint256);

	function balanceOf(address account) external view returns (uint256);

	function borrowerOperationsAddress() external view returns (address);

	function circulatingSupply() external view returns (uint256);

	function decimals() external view returns (uint8);

	function domainSeparator() external view returns (bytes32);

	function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint256 _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint256 nativeFee, uint256 zroFee);

	function factory() external view returns (address);

	function failedMessages(uint16, bytes calldata, uint64) external view returns (bytes32);

	function flashFee(address token, uint256 amount) external view returns (uint256);

	function gasPool() external view returns (address);

	function getConfig(uint16 _version, uint16 _chainId, address, uint256 _configType) external view returns (bytes memory);

	function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory);

	function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);

	function lzEndpoint() external view returns (address);

	function maxFlashLoan(address token) external view returns (uint256);

	function minDstGasLookup(uint16, uint16) external view returns (uint256);

	function name() external view returns (string memory);

	function nonces(address owner) external view returns (uint256);

	function owner() external view returns (address);

	function payloadSizeLimitLookup(uint16) external view returns (uint256);

	function permitTypeHash() external view returns (bytes32);

	function precrime() external view returns (address);

	function stabilityPoolAddress() external view returns (address);

	function supportsInterface(bytes4 interfaceId) external view returns (bool);

	function symbol() external view returns (string memory);

	function token() external view returns (address);

	function totalSupply() external view returns (uint256);

	function troveManager(address) external view returns (bool);

	function trustedRemoteLookup(uint16) external view returns (bytes memory);

	function useCustomAdapterParams() external view returns (bool);

	function version() external view returns (string memory);
}

